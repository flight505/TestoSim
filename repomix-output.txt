This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed, line numbers have been added.

================================================================
Directory Structure
================================================================
TestoSim/
  Assets.xcassets/
    AccentColor.colorset/
      Contents.json
    AppIcon.appiconset/
      Contents.json
    Contents.json
  Models/
    BloodworkModel.swift
    Compound.swift
    CompoundLibrary.swift
    DataPoint.swift
    EsterData.swift
    PKModel.swift
    ProfileModel.swift
    ProtocolModel.swift
    VialBlend.swift
  ViewModels/
    AppDataStore.swift
  Views/
    AddBloodworkView.swift
    ProfileView.swift
    ProtocolDetailView.swift
    ProtocolFormView.swift
    ProtocolListView.swift
    TestosteroneChart.swift
  ContentView.swift
  TestoSim.entitlements
  TestoSimApp.swift
TestoSim.xcodeproj/
  project.xcworkspace/
    xcshareddata/
      swiftpm/
        configuration/
    contents.xcworkspacedata
  project.pbxproj
TestoSimTests/
  TestoSimTests.swift
TestoSimUITests/
  TestoSimUITests.swift
  TestoSimUITestsLaunchTests.swift
.gitignore
buildServer.json
guide.md
guide2.md

================================================================
Files
================================================================

================
File: TestoSim/Assets.xcassets/AccentColor.colorset/Contents.json
================
 1: {
 2:   "colors" : [
 3:     {
 4:       "idiom" : "universal"
 5:     }
 6:   ],
 7:   "info" : {
 8:     "author" : "xcode",
 9:     "version" : 1
10:   }
11: }

================
File: TestoSim/Assets.xcassets/AppIcon.appiconset/Contents.json
================
 1: {
 2:   "images" : [
 3:     {
 4:       "idiom" : "universal",
 5:       "platform" : "ios",
 6:       "size" : "1024x1024"
 7:     },
 8:     {
 9:       "appearances" : [
10:         {
11:           "appearance" : "luminosity",
12:           "value" : "dark"
13:         }
14:       ],
15:       "idiom" : "universal",
16:       "platform" : "ios",
17:       "size" : "1024x1024"
18:     },
19:     {
20:       "appearances" : [
21:         {
22:           "appearance" : "luminosity",
23:           "value" : "tinted"
24:         }
25:       ],
26:       "idiom" : "universal",
27:       "platform" : "ios",
28:       "size" : "1024x1024"
29:     },
30:     {
31:       "idiom" : "mac",
32:       "scale" : "1x",
33:       "size" : "16x16"
34:     },
35:     {
36:       "idiom" : "mac",
37:       "scale" : "2x",
38:       "size" : "16x16"
39:     },
40:     {
41:       "idiom" : "mac",
42:       "scale" : "1x",
43:       "size" : "32x32"
44:     },
45:     {
46:       "idiom" : "mac",
47:       "scale" : "2x",
48:       "size" : "32x32"
49:     },
50:     {
51:       "idiom" : "mac",
52:       "scale" : "1x",
53:       "size" : "128x128"
54:     },
55:     {
56:       "idiom" : "mac",
57:       "scale" : "2x",
58:       "size" : "128x128"
59:     },
60:     {
61:       "idiom" : "mac",
62:       "scale" : "1x",
63:       "size" : "256x256"
64:     },
65:     {
66:       "idiom" : "mac",
67:       "scale" : "2x",
68:       "size" : "256x256"
69:     },
70:     {
71:       "idiom" : "mac",
72:       "scale" : "1x",
73:       "size" : "512x512"
74:     },
75:     {
76:       "idiom" : "mac",
77:       "scale" : "2x",
78:       "size" : "512x512"
79:     }
80:   ],
81:   "info" : {
82:     "author" : "xcode",
83:     "version" : 1
84:   }
85: }

================
File: TestoSim/Assets.xcassets/Contents.json
================
1: {
2:   "info" : {
3:     "author" : "xcode",
4:     "version" : 1
5:   }
6: }

================
File: TestoSim/Models/BloodworkModel.swift
================
 1: import Foundation
 2: struct BloodSample: Identifiable, Codable, Hashable {
 3:     let id: UUID
 4:     let date: Date
 5:     let value: Double
 6:     let unit: String
 7:     init(id: UUID = UUID(), date: Date, value: Double, unit: String) {
 8:         self.id = id
 9:         self.date = date
10:         self.value = value
11:         self.unit = unit
12:     }
13: }

================
File: TestoSim/Models/Compound.swift
================
 1: import Foundation
 2: struct Compound: Identifiable, Codable, Hashable {
 3:     enum Class: String, Codable, CaseIterable {
 4:         case testosterone, nandrolone, trenbolone,
 5:              boldenone, drostanolone, stanozolol, metenolone,
 6:              trestolone, dhb
 7:         var displayName: String {
 8:             switch self {
 9:             case .testosterone: return "Testosterone"
10:             case .nandrolone: return "Nandrolone"
11:             case .trenbolone: return "Trenbolone"
12:             case .boldenone: return "Boldenone"
13:             case .drostanolone: return "Drostanolone (Masteron)"
14:             case .stanozolol: return "Stanozolol (Winstrol)"
15:             case .metenolone: return "Metenolone (Primobolan)"
16:             case .trestolone: return "Trestolone (MENT)"
17:             case .dhb: return "1-Testosterone (DHB)"
18:             }
19:         }
20:     }
21:     enum Route: String, Codable, CaseIterable {
22:         case intramuscular, subcutaneous, oral, transdermal
23:         var displayName: String {
24:             switch self {
25:             case .intramuscular: return "Intramuscular (IM)"
26:             case .subcutaneous: return "Subcutaneous (SubQ)"
27:             case .oral: return "Oral"
28:             case .transdermal: return "Transdermal"
29:             }
30:         }
31:     }
32:     let id: UUID
33:     var commonName: String
34:     var classType: Class
35:     var ester: String?          // nil for suspensions
36:     var halfLifeDays: Double
37:     var defaultBioavailability: [Route: Double]
38:     var defaultAbsorptionRateKa: [Route: Double] // d-¹ (per day)
39:     init(id: UUID = UUID(), 
40:          commonName: String, 
41:          classType: Class, 
42:          ester: String? = nil, 
43:          halfLifeDays: Double, 
44:          defaultBioavailability: [Route: Double], 
45:          defaultAbsorptionRateKa: [Route: Double]) {
46:         self.id = id
47:         self.commonName = commonName
48:         self.classType = classType
49:         self.ester = ester
50:         self.halfLifeDays = halfLifeDays
51:         self.defaultBioavailability = defaultBioavailability
52:         self.defaultAbsorptionRateKa = defaultAbsorptionRateKa
53:     }
54:     // Returns the full display name with class and ester, e.g. "Testosterone Enanthate"
55:     var fullDisplayName: String {
56:         if let ester = ester {
57:             return "\(classType.displayName) \(ester)"
58:         } else {
59:             return "\(classType.displayName) Suspension"
60:         }
61:     }
62: }

================
File: TestoSim/Models/CompoundLibrary.swift
================
  1: import Foundation
  2: class CompoundLibrary: ObservableObject {
  3:     @Published private(set) var compounds: [Compound] = []
  4:     @Published private(set) var blends: [VialBlend] = []
  5:     init() {
  6:         populateCompounds()
  7:         populateBlends()
  8:     }
  9:     // MARK: - Helper Methods
 10:     func compound(withID id: UUID) -> Compound? {
 11:         return compounds.first { $0.id == id }
 12:     }
 13:     func blend(withID id: UUID) -> VialBlend? {
 14:         return blends.first { $0.id == id }
 15:     }
 16:     // MARK: - Filter Methods
 17:     func compounds(ofClass classType: Compound.Class) -> [Compound] {
 18:         return compounds.filter { $0.classType == classType }
 19:     }
 20:     func compounds(forRoute route: Compound.Route) -> [Compound] {
 21:         return compounds.filter { $0.defaultBioavailability[route] != nil }
 22:     }
 23:     func compounds(withEsterName esterName: String) -> [Compound] {
 24:         return compounds.filter { $0.ester == esterName }
 25:     }
 26:     func compounds(withHalfLifeBetween min: Double, and max: Double) -> [Compound] {
 27:         return compounds.filter { $0.halfLifeDays >= min && $0.halfLifeDays <= max }
 28:     }
 29:     func blends(containing compoundID: UUID) -> [VialBlend] {
 30:         return blends.filter { blend in
 31:             blend.components.contains { $0.compoundID == compoundID }
 32:         }
 33:     }
 34:     // MARK: - Populate Data
 35:     private func populateCompounds() {
 36:         // Default values for typical routes
 37:         let defaultIMBioavailability: [Compound.Route: Double] = [.intramuscular: 1.0, .subcutaneous: 0.85]
 38:         let defaultOralBioavailability: [Compound.Route: Double] = [.oral: 0.07] // Low for most oral testosterone
 39:         // Testosterone compounds
 40:         let testosteronePropionate = Compound(
 41:             commonName: "Testosterone Propionate",
 42:             classType: .testosterone,
 43:             ester: "Propionate",
 44:             halfLifeDays: 0.8, // Wikipedia
 45:             defaultBioavailability: defaultIMBioavailability,
 46:             defaultAbsorptionRateKa: [.intramuscular: 0.70, .subcutaneous: 0.50]
 47:         )
 48:         let testosteronePhenylpropionate = Compound(
 49:             commonName: "Testosterone Phenylpropionate",
 50:             classType: .testosterone,
 51:             ester: "Phenylpropionate",
 52:             halfLifeDays: 2.5, // Iron Daddy
 53:             defaultBioavailability: defaultIMBioavailability,
 54:             defaultAbsorptionRateKa: [.intramuscular: 0.50, .subcutaneous: 0.35]
 55:         )
 56:         let testosteroneIsocaproate = Compound(
 57:             commonName: "Testosterone Isocaproate",
 58:             classType: .testosterone,
 59:             ester: "Isocaproate",
 60:             halfLifeDays: 3.1, // Cayman Chemical
 61:             defaultBioavailability: defaultIMBioavailability,
 62:             defaultAbsorptionRateKa: [.intramuscular: 0.35, .subcutaneous: 0.25]
 63:         )
 64:         let testosteroneEnanthate = Compound(
 65:             commonName: "Testosterone Enanthate",
 66:             classType: .testosterone,
 67:             ester: "Enanthate",
 68:             halfLifeDays: 4.5, // From previous app data
 69:             defaultBioavailability: defaultIMBioavailability,
 70:             defaultAbsorptionRateKa: [.intramuscular: 0.30, .subcutaneous: 0.22]
 71:         )
 72:         let testosteroneCypionate = Compound(
 73:             commonName: "Testosterone Cypionate",
 74:             classType: .testosterone,
 75:             ester: "Cypionate",
 76:             halfLifeDays: 7.0, // From previous app data
 77:             defaultBioavailability: defaultIMBioavailability,
 78:             defaultAbsorptionRateKa: [.intramuscular: 0.25, .subcutaneous: 0.18]
 79:         )
 80:         let testosteroneDecanoate = Compound(
 81:             commonName: "Testosterone Decanoate",
 82:             classType: .testosterone,
 83:             ester: "Decanoate",
 84:             halfLifeDays: 10.0, // BloomTechz (7-14 day midpoint)
 85:             defaultBioavailability: defaultIMBioavailability,
 86:             defaultAbsorptionRateKa: [.intramuscular: 0.18, .subcutaneous: 0.14]
 87:         )
 88:         let testosteroneUndecanoateInjectable = Compound(
 89:             commonName: "Testosterone Undecanoate (Injectable)",
 90:             classType: .testosterone,
 91:             ester: "Undecanoate",
 92:             halfLifeDays: 21.0, // PubMed, Wikipedia (18-24 day midpoint)
 93:             defaultBioavailability: defaultIMBioavailability,
 94:             defaultAbsorptionRateKa: [.intramuscular: 0.15, .subcutaneous: 0.10]
 95:         )
 96:         let testosteroneUndecanoateOral = Compound(
 97:             commonName: "Testosterone Undecanoate (Oral)",
 98:             classType: .testosterone,
 99:             ester: "Undecanoate",
100:             halfLifeDays: 0.067, // Wikipedia t½ 1.6h = 0.067d
101:             defaultBioavailability: defaultOralBioavailability,
102:             defaultAbsorptionRateKa: [.oral: 6.0] // Fast absorption orally
103:         )
104:         // Nandrolone
105:         let nandroloneDecanoate = Compound(
106:             commonName: "Nandrolone Decanoate",
107:             classType: .nandrolone,
108:             ester: "Decanoate",
109:             halfLifeDays: 9.0, // Wikipedia (6-12 day midpoint)
110:             defaultBioavailability: defaultIMBioavailability,
111:             defaultAbsorptionRateKa: [.intramuscular: 0.20, .subcutaneous: 0.15]
112:         )
113:         // Boldenone
114:         let boldenoneUndecylenate = Compound(
115:             commonName: "Boldenone Undecylenate",
116:             classType: .boldenone,
117:             ester: "Undecylenate",
118:             halfLifeDays: 5.125, // ScienceDirect ~123h = 5.125d
119:             defaultBioavailability: defaultIMBioavailability,
120:             defaultAbsorptionRateKa: [.intramuscular: 0.25, .subcutaneous: 0.18]
121:         )
122:         // Trenbolone
123:         let trenboloneAcetate = Compound(
124:             commonName: "Trenbolone Acetate",
125:             classType: .trenbolone,
126:             ester: "Acetate",
127:             halfLifeDays: 1.5, // ScienceDirect (1-2 day midpoint)
128:             defaultBioavailability: defaultIMBioavailability,
129:             defaultAbsorptionRateKa: [.intramuscular: 1.00, .subcutaneous: 0.70]
130:         )
131:         let trenboloneEnanthate = Compound(
132:             commonName: "Trenbolone Enanthate",
133:             classType: .trenbolone,
134:             ester: "Enanthate",
135:             halfLifeDays: 11.0, // Wikipedia
136:             defaultBioavailability: defaultIMBioavailability,
137:             defaultAbsorptionRateKa: [.intramuscular: 0.18, .subcutaneous: 0.14]
138:         )
139:         let trenboloneHexahydrobenzylcarbonate = Compound(
140:             commonName: "Trenbolone Hexahydrobenzylcarbonate",
141:             classType: .trenbolone,
142:             ester: "Hexahydrobenzylcarbonate",
143:             halfLifeDays: 8.0, // Wikipedia
144:             defaultBioavailability: defaultIMBioavailability,
145:             defaultAbsorptionRateKa: [.intramuscular: 0.20, .subcutaneous: 0.15]
146:         )
147:         // Stanozolol
148:         let stanozololSuspension = Compound(
149:             commonName: "Stanozolol Suspension",
150:             classType: .stanozolol,
151:             ester: nil, // Suspension has no ester
152:             halfLifeDays: 1.0, // Wikipedia 24h
153:             defaultBioavailability: defaultIMBioavailability,
154:             defaultAbsorptionRateKa: [.intramuscular: 1.50, .subcutaneous: 1.00]
155:         )
156:         // Drostanolone (Masteron)
157:         let drostanolonePropionate = Compound(
158:             commonName: "Drostanolone Propionate",
159:             classType: .drostanolone,
160:             ester: "Propionate",
161:             halfLifeDays: 2.0, // Wikipedia
162:             defaultBioavailability: defaultIMBioavailability,
163:             defaultAbsorptionRateKa: [.intramuscular: 0.70, .subcutaneous: 0.50]
164:         )
165:         let drostanoloneEnanthate = Compound(
166:             commonName: "Drostanolone Enanthate",
167:             classType: .drostanolone,
168:             ester: "Enanthate",
169:             halfLifeDays: 5.0, // Wikipedia approx
170:             defaultBioavailability: defaultIMBioavailability,
171:             defaultAbsorptionRateKa: [.intramuscular: 0.30, .subcutaneous: 0.22]
172:         )
173:         // Metenolone (Primobolan)
174:         let metenoloneEnanthate = Compound(
175:             commonName: "Metenolone Enanthate",
176:             classType: .metenolone,
177:             ester: "Enanthate",
178:             halfLifeDays: 10.5, // Wikipedia
179:             defaultBioavailability: defaultIMBioavailability,
180:             defaultAbsorptionRateKa: [.intramuscular: 0.18, .subcutaneous: 0.15]
181:         )
182:         // Trestolone (MENT)
183:         let trestoloneAcetate = Compound(
184:             commonName: "Trestolone Acetate",
185:             classType: .trestolone,
186:             ester: "Acetate",
187:             halfLifeDays: 0.083, // PubMed 40min IV ~2h SC, conservatively using IV
188:             defaultBioavailability: defaultIMBioavailability,
189:             defaultAbsorptionRateKa: [.intramuscular: 2.00, .subcutaneous: 1.50]
190:         )
191:         // 1-Testosterone (DHB)
192:         let dhbCypionate = Compound(
193:             commonName: "1-Testosterone Cypionate",
194:             classType: .dhb,
195:             ester: "Cypionate",
196:             halfLifeDays: 8.0, // Wikipedia class analogue
197:             defaultBioavailability: defaultIMBioavailability,
198:             defaultAbsorptionRateKa: [.intramuscular: 0.22, .subcutaneous: 0.16]
199:         )
200:         // Add all compounds to the library
201:         compounds = [
202:             testosteronePropionate,
203:             testosteronePhenylpropionate,
204:             testosteroneIsocaproate,
205:             testosteroneEnanthate,
206:             testosteroneCypionate,
207:             testosteroneDecanoate,
208:             testosteroneUndecanoateInjectable,
209:             testosteroneUndecanoateOral,
210:             nandroloneDecanoate,
211:             boldenoneUndecylenate,
212:             trenboloneAcetate,
213:             trenboloneEnanthate,
214:             trenboloneHexahydrobenzylcarbonate,
215:             stanozololSuspension,
216:             drostanolonePropionate,
217:             drostanoloneEnanthate,
218:             metenoloneEnanthate,
219:             trestoloneAcetate,
220:             dhbCypionate
221:         ]
222:     }
223:     private func populateBlends() {
224:         // Helper to find compound ID by common name
225:         func findCompoundID(byName name: String) -> UUID? {
226:             return compounds.first { $0.commonName == name }?.id
227:         }
228:         // Sustanon blends
229:         if let testP = findCompoundID(byName: "Testosterone Propionate"),
230:            let testPP = findCompoundID(byName: "Testosterone Phenylpropionate"),
231:            let testIso = findCompoundID(byName: "Testosterone Isocaproate"),
232:            let testDec = findCompoundID(byName: "Testosterone Decanoate") {
233:             // Sustanon 250
234:             let sustanon250 = VialBlend(
235:                 name: "Sustanon 250",
236:                 manufacturer: "Organon",
237:                 description: "Mixed testosterone esters for TRT",
238:                 components: [
239:                     VialBlend.Component(compoundID: testP, mgPerML: 30),
240:                     VialBlend.Component(compoundID: testPP, mgPerML: 60),
241:                     VialBlend.Component(compoundID: testIso, mgPerML: 60),
242:                     VialBlend.Component(compoundID: testDec, mgPerML: 100)
243:                 ]
244:             )
245:             // Sustanon 350
246:             let sustanon350 = VialBlend(
247:                 name: "Sustanon 350",
248:                 manufacturer: "Generic",
249:                 description: "Higher concentration mixed testosterone esters",
250:                 components: [
251:                     VialBlend.Component(compoundID: testP, mgPerML: 40),
252:                     VialBlend.Component(compoundID: testPP, mgPerML: 80),
253:                     VialBlend.Component(compoundID: testIso, mgPerML: 80),
254:                     VialBlend.Component(compoundID: testDec, mgPerML: 150)
255:                 ]
256:             )
257:             // Sustanon 400
258:             let sustanon400 = VialBlend(
259:                 name: "Sustanon 400",
260:                 manufacturer: "Generic",
261:                 description: "Highest concentration mixed testosterone esters",
262:                 components: [
263:                     VialBlend.Component(compoundID: testP, mgPerML: 50),
264:                     VialBlend.Component(compoundID: testPP, mgPerML: 100),
265:                     VialBlend.Component(compoundID: testIso, mgPerML: 100),
266:                     VialBlend.Component(compoundID: testDec, mgPerML: 150)
267:                 ]
268:             )
269:             blends.append(contentsOf: [sustanon250, sustanon350, sustanon400])
270:         }
271:         // Add more commercial blends as needed - could add Winstrol Susp 50, Masteron P 100, etc.
272:         // as mentioned in the guide, but for brevity I'll focus on just Sustanon blends for now
273:         // The following would be added for a complete implementation:
274:         // - Winstrol Susp 50
275:         // - Masteron P 100 & E 200
276:         // - Primobolan E 100
277:         // - Tren Susp 50, Tren A 100, Tren E 200, Tren Hex 76
278:         // - Tren Mix 150
279:         // - Cut-Stack 150 & 250
280:         // - MENT Ac 50
281:         // - DHB Cyp 100
282:     }
283: }

================
File: TestoSim/Models/DataPoint.swift
================
1: import Foundation
2: struct DataPoint: Identifiable {
3:     let id = UUID()
4:     let time: Date
5:     let level: Double
6: }

================
File: TestoSim/Models/EsterData.swift
================
 1: import Foundation
 2: struct TestosteroneEster: Identifiable, Codable, Hashable {
 3:     let id: UUID
 4:     let name: String
 5:     let halfLifeDays: Double
 6:     init(id: UUID = UUID(), name: String, halfLifeDays: Double) {
 7:         self.id = id
 8:         self.name = name
 9:         self.halfLifeDays = halfLifeDays
10:     }
11:     static let propionate = TestosteroneEster(name: "Propionate", halfLifeDays: 0.8)
12:     static let enanthate = TestosteroneEster(name: "Enanthate", halfLifeDays: 4.5)
13:     static let cypionate = TestosteroneEster(name: "Cypionate", halfLifeDays: 7.0)
14:     static let undecanoate = TestosteroneEster(name: "Undecanoate", halfLifeDays: 30.0)
15:     static let all: [TestosteroneEster] = [.propionate, .enanthate, .cypionate, .undecanoate]
16: }

================
File: TestoSim/Models/PKModel.swift
================
  1: import Foundation
  2: /// Pharmacokinetic model for calculating hormone concentrations
  3: struct PKModel {
  4:     // MARK: - Constants
  5:     /// Typical volume of distribution for a 70kg person in liters
  6:     static let defaultVolumeOfDistribution70kg: Double = 4.0 // L
  7:     /// Default clearance for a 70kg person in L/day
  8:     static let defaultClearance70kg: Double = 0.8 // L/day
  9:     // MARK: - Properties
 10:     /// Whether to use the two-compartment model (more accurate but more computationally intensive)
 11:     var useTwoCompartmentModel: Bool
 12:     /// Fixed compartment transfer rates if using two-compartment model (from guide)
 13:     let k12: Double = 0.3 // d⁻¹
 14:     let k21: Double = 0.15 // d⁻¹
 15:     // MARK: - Initialization
 16:     init(useTwoCompartmentModel: Bool = false) {
 17:         self.useTwoCompartmentModel = useTwoCompartmentModel
 18:     }
 19:     // MARK: - Concentration Calculations
 20:     /// Calculate concentration for a single dose administration
 21:     /// - Parameters:
 22:     ///   - time: Time in days since administration
 23:     ///   - dose: Dose in mg
 24:     ///   - halfLifeDays: Half-life in days
 25:     ///   - absorptionRateKa: Absorption rate constant (ka) in d⁻¹
 26:     ///   - bioavailability: Fraction of drug absorbed (0-1)
 27:     ///   - weight: Patient weight in kg (for allometric scaling)
 28:     ///   - calibrationFactor: User-specific calibration factor
 29:     /// - Returns: Concentration in the appropriate units
 30:     func concentration(
 31:         at time: Double,
 32:         dose: Double,
 33:         halfLifeDays: Double,
 34:         absorptionRateKa: Double,
 35:         bioavailability: Double,
 36:         weight: Double = 70.0,
 37:         calibrationFactor: Double = 1.0
 38:     ) -> Double {
 39:         // Skip calculation if time is negative or zero
 40:         guard time > 0 && halfLifeDays > 0 else { return 0 }
 41:         // Elimination rate constant (ke) = ln(2)/t_1/2
 42:         let ke = log(2) / halfLifeDays
 43:         // Skip calculation if ka ≤ ke (avoid division by zero or negative value)
 44:         guard absorptionRateKa > ke else {
 45:             return oneCompartmentBolus(
 46:                 time: time,
 47:                 dose: dose,
 48:                 ke: ke,
 49:                 bioavailability: bioavailability,
 50:                 weight: weight,
 51:                 calibrationFactor: calibrationFactor
 52:             )
 53:         }
 54:         // Calculate volume of distribution and clearance with allometric scaling
 55:         let vd = PKModel.defaultVolumeOfDistribution70kg * pow(weight / 70.0, 1.0)
 56:         // One-compartment model with first-order absorption (standard PK formula)
 57:         let scaledDose = dose * bioavailability
 58:         let factor = (scaledDose * absorptionRateKa) / (vd * (absorptionRateKa - ke))
 59:         if useTwoCompartmentModel {
 60:             // Calculate alpha and beta for two-compartment model
 61:             // These are the hybrid rate constants derived from k12, k21, and ke
 62:             let beta = 0.5 * ((k12 + k21 + ke) - sqrt(pow(k12 + k21 + ke, 2) - 4 * k21 * ke))
 63:             let alpha = (k21 * ke) / beta
 64:             // Two-compartment model with first-order absorption
 65:             let term1 = absorptionRateKa / ((absorptionRateKa - alpha) * (absorptionRateKa - beta))
 66:             let term2 = absorptionRateKa / ((alpha - absorptionRateKa) * (alpha - beta))
 67:             let term3 = absorptionRateKa / ((beta - absorptionRateKa) * (beta - alpha))
 68:             let result = (scaledDose / vd) * (
 69:                 term1 * exp(-absorptionRateKa * time) +
 70:                 term2 * exp(-alpha * time) +
 71:                 term3 * exp(-beta * time)
 72:             )
 73:             return result * calibrationFactor
 74:         } else {
 75:             // One-compartment model with first-order absorption (standard PK formula)
 76:             // C(t) = (F·D·ka)/(Vd·(ka-ke))·(e^(-ke·t)-e^(-ka·t))
 77:             let result = factor * (exp(-ke * time) - exp(-absorptionRateKa * time))
 78:             return result * calibrationFactor
 79:         }
 80:     }
 81:     /// Calculate concentration for a bolus injection (immediate absorption)
 82:     /// This is a fallback for when ka ≤ ke or as direct calculation when needed
 83:     private func oneCompartmentBolus(
 84:         time: Double,
 85:         dose: Double,
 86:         ke: Double,
 87:         bioavailability: Double,
 88:         weight: Double,
 89:         calibrationFactor: Double
 90:     ) -> Double {
 91:         // Calculate volume of distribution with allometric scaling
 92:         let vd = PKModel.defaultVolumeOfDistribution70kg * pow(weight / 70.0, 1.0)
 93:         // Simple one-compartment bolus model: C(t) = (F·D/Vd)·e^(-ke·t)
 94:         let initialConcentration = (dose * bioavailability) / vd
 95:         return initialConcentration * exp(-ke * time) * calibrationFactor
 96:     }
 97:     /// Calculate the total concentration for a blend at a specific time
 98:     /// - Parameters:
 99:     ///   - time: Time in days since administration
100:     ///   - components: Array of tuples containing (compound, dose)
101:     ///   - route: Administration route
102:     ///   - weight: Patient weight in kg
103:     ///   - calibrationFactor: User-specific calibration factor
104:     /// - Returns: Total concentration
105:     func blendConcentration(
106:         at time: Double,
107:         components: [(compound: Compound, doseMg: Double)],
108:         route: Compound.Route,
109:         weight: Double = 70.0,
110:         calibrationFactor: Double = 1.0
111:     ) -> Double {
112:         // Sum the concentrations of all components
113:         return components.reduce(0.0) { totalConcentration, component in
114:             let bioavailability = component.compound.defaultBioavailability[route] ?? 1.0
115:             let absorptionRate = component.compound.defaultAbsorptionRateKa[route] ?? 0.7 // Default ka if not specified
116:             let componentConcentration = concentration(
117:                 at: time,
118:                 dose: component.doseMg,
119:                 halfLifeDays: component.compound.halfLifeDays,
120:                 absorptionRateKa: absorptionRate,
121:                 bioavailability: bioavailability,
122:                 weight: weight,
123:                 calibrationFactor: calibrationFactor
124:             )
125:             return totalConcentration + componentConcentration
126:         }
127:     }
128:     /// Calculate the concentration over time for a protocol with multiple injections
129:     /// - Parameters:
130:     ///   - times: Array of time points in days to calculate concentrations for
131:     ///   - injectionDates: Dates of all injections
132:     ///   - compounds: Array of tuples containing (compound, dose per injection)
133:     ///   - route: Administration route
134:     ///   - weight: Patient weight in kg
135:     ///   - calibrationFactor: User-specific calibration factor
136:     /// - Returns: Array of concentrations at specified time points
137:     func protocolConcentrations(
138:         at times: [Date],
139:         injectionDates: [Date],
140:         compounds: [(compound: Compound, dosePerInjectionMg: Double)],
141:         route: Compound.Route,
142:         weight: Double = 70.0,
143:         calibrationFactor: Double = 1.0
144:     ) -> [Double] {
145:         // Calculate concentration at each time point
146:         return times.map { timePoint in
147:             // Sum contributions from all injections
148:             let totalConcentration = injectionDates.reduce(0.0) { totalConc, injectionDate in
149:                 // Skip future injections
150:                 guard injectionDate <= timePoint else { return totalConc }
151:                 // Calculate time difference in days
152:                 let timeDiffDays = timePoint.timeIntervalSince(injectionDate) / (24 * 3600)
153:                 // Sum contributions from all compounds in this injection
154:                 let injectionContribution = compounds.reduce(0.0) { compoundSum, compound in
155:                     let bioavailability = compound.compound.defaultBioavailability[route] ?? 1.0
156:                     let absorptionRate = compound.compound.defaultAbsorptionRateKa[route] ?? 0.7
157:                     let contribution = concentration(
158:                         at: timeDiffDays,
159:                         dose: compound.dosePerInjectionMg,
160:                         halfLifeDays: compound.compound.halfLifeDays,
161:                         absorptionRateKa: absorptionRate,
162:                         bioavailability: bioavailability,
163:                         weight: weight,
164:                         calibrationFactor: calibrationFactor
165:                     )
166:                     return compoundSum + contribution
167:                 }
168:                 return totalConc + injectionContribution
169:             }
170:             return totalConcentration
171:         }
172:     }
173:     // MARK: - Bayesian Calibration
174:     /// Struct to represent a blood sample with timestamp and lab value
175:     struct SamplePoint {
176:         let timestamp: Date
177:         let labValue: Double
178:     }
179:     /// Result of Bayesian calibration
180:     struct CalibrationResult {
181:         let adjustedKe: Double
182:         let adjustedKa: Double
183:         let originalKe: Double
184:         let originalKa: Double
185:         let halfLifeDays: Double
186:         let correlation: Double
187:         let samples: [SamplePoint]
188:         var halfLifeChangePercent: Double {
189:             let originalHalfLife = log(2) / originalKe
190:             let newHalfLife = log(2) / adjustedKe
191:             return ((newHalfLife / originalHalfLife) - 1.0) * 100.0
192:         }
193:     }
194:     /// Perform Bayesian calibration to refine ke and ka based on lab values
195:     /// - Parameters:
196:     ///   - samples: Dictionary of timestamps and lab values
197:     ///   - injectionDates: Dates of all injections
198:     ///   - compound: Compound being used
199:     ///   - dose: Dose in mg
200:     ///   - route: Administration route
201:     ///   - weight: Patient weight in kg
202:     /// - Returns: Calibration result with adjusted parameters
203:     func bayesianCalibration(
204:         samples: [SamplePoint],
205:         injectionDates: [Date],
206:         compound: Compound,
207:         dose: Double,
208:         route: Compound.Route,
209:         weight: Double = 70.0
210:     ) -> CalibrationResult? {
211:         // Need at least 2 samples for meaningful calibration
212:         guard samples.count >= 2, let defaultKa = compound.defaultAbsorptionRateKa[route] else {
213:             return nil
214:         }
215:         // Original parameters
216:         let originalKe = log(2) / compound.halfLifeDays
217:         let originalKa = defaultKa
218:         // Stub implementation that returns slightly adjusted parameters
219:         // In a real implementation, this would use more sophisticated statistical methods
220:         // such as Markov Chain Monte Carlo or Maximum Likelihood Estimation
221:         // For demonstration, adjust ke by ±10% randomly and ka by ±15% randomly
222:         let keAdjustmentFactor = 1.0 + (Double.random(in: -0.1...0.1))
223:         let kaAdjustmentFactor = 1.0 + (Double.random(in: -0.15...0.15))
224:         let adjustedKe = originalKe * keAdjustmentFactor
225:         let adjustedKa = originalKa * kaAdjustmentFactor
226:         // Calculate a dummy correlation value (would be actual fit quality in real implementation)
227:         let correlation = 0.85 + Double.random(in: 0...0.1)
228:         return CalibrationResult(
229:             adjustedKe: adjustedKe,
230:             adjustedKa: adjustedKa,
231:             originalKe: originalKe,
232:             originalKa: originalKa,
233:             halfLifeDays: log(2) / adjustedKe,
234:             correlation: correlation,
235:             samples: samples
236:         )
237:     }
238: }

================
File: TestoSim/Models/ProtocolModel.swift
================
 1: import Foundation
 2: struct InjectionProtocol: Identifiable, Codable {
 3:     var id: UUID = UUID()
 4:     var name: String
 5:     var ester: TestosteroneEster
 6:     var doseMg: Double
 7:     var frequencyDays: Double
 8:     var startDate: Date
 9:     var notes: String?
10:     var bloodSamples: [BloodSample] = []
11:     func injectionDates(from simulationStartDate: Date, upto endDate: Date) -> [Date] {
12:         var dates: [Date] = []
13:         var current = startDate
14:         var injectionIndex = 0
15:         // Find the first injection date that is on or after the simulation's start date
16:         while current < simulationStartDate {
17:             // Check for zero/negative frequency to avoid infinite loop
18:             guard frequencyDays > 0 else {
19:                 // If first injection is before sim start, add it if it's the *only* injection
20:                 if injectionIndex == 0 && current <= endDate { dates.append(current) }
21:                 return dates // Only one injection possible
22:             }
23:             injectionIndex += 1
24:             current = Calendar.current.date(byAdding: .day, value: Int(frequencyDays * Double(injectionIndex)), to: startDate)! // More robust date calculation
25:             // Safety Break
26:             if injectionIndex > 10000 { break }
27:         }
28:         // Now add dates within the simulation range [simStartDate, endDate]
29:         // Reset index based on where we are starting relative to protocol start
30:         injectionIndex = Int(round(current.timeIntervalSince(startDate) / (frequencyDays * 24 * 3600)))
31:         while current <= endDate {
32:             // Only add if it's within the simulation's actual display window start
33:             if current >= simulationStartDate {
34:                 dates.append(current)
35:             }
36:             // Check for zero/negative frequency
37:             guard frequencyDays > 0 else { break } // Should only add the first one if freq <= 0
38:             injectionIndex += 1
39:             // Use calendar calculation for adding days to avoid potential DST issues if frequency isn't integer days
40:             // However, since frequency is Double, TimeInterval is more direct. Stick to TimeInterval for consistency with PK math.
41:             current = startDate.addingTimeInterval(Double(injectionIndex) * frequencyDays * 24 * 3600)
42:             // Safety Break
43:             if injectionIndex > 10000 { break }
44:         }
45:         return dates
46:     }
47: }

================
File: TestoSim/Models/VialBlend.swift
================
 1: import Foundation
 2: struct VialBlend: Identifiable, Codable, Hashable {
 3:     struct Component: Codable, Hashable {
 4:         let compoundID: UUID
 5:         let mgPerML: Double
 6:         init(compoundID: UUID, mgPerML: Double) {
 7:             self.compoundID = compoundID
 8:             self.mgPerML = mgPerML
 9:         }
10:     }
11:     let id: UUID
12:     var name: String
13:     var manufacturer: String?
14:     var description: String?
15:     var components: [Component]
16:     init(id: UUID = UUID(), 
17:          name: String, 
18:          manufacturer: String? = nil, 
19:          description: String? = nil, 
20:          components: [Component]) {
21:         self.id = id
22:         self.name = name
23:         self.manufacturer = manufacturer
24:         self.description = description
25:         self.components = components
26:     }
27:     // Total concentration in mg/mL
28:     var totalConcentration: Double {
29:         components.reduce(0) { $0 + $1.mgPerML }
30:     }
31:     // Returns components with their actual compounds (requires CompoundLibrary lookup)
32:     func resolvedComponents(using library: CompoundLibrary) -> [(compound: Compound, mgPerML: Double)] {
33:         return components.compactMap { component in
34:             guard let compound = library.compound(withID: component.compoundID) else {
35:                 return nil
36:             }
37:             return (compound: compound, mgPerML: component.mgPerML)
38:         }
39:     }
40:     // Creates a descriptive string representing the blend contents
41:     func compositionDescription(using library: CompoundLibrary) -> String {
42:         let resolved = resolvedComponents(using: library)
43:         if resolved.isEmpty {
44:             return "Unknown composition"
45:         }
46:         // Completely rewritten to avoid any string interpolation complexity
47:         let descriptions = resolved.map { component -> String in
48:             let name = component.compound.fullDisplayName
49:             let dosage = Int(component.mgPerML)
50:             return name + " " + String(dosage) + "mg/mL"
51:         }
52:         return descriptions.joined(separator: ", ")
53:     }
54: }

================
File: TestoSim/Views/AddBloodworkView.swift
================
 1: import SwiftUI
 2: struct AddBloodworkView: View {
 3:     @EnvironmentObject var dataStore: AppDataStore
 4:     @Environment(\.dismiss) var dismiss
 5:     let injectionProtocol: InjectionProtocol
 6:     @State private var date: Date = Date()
 7:     @State private var valueText: String = ""
 8:     @State private var selectedUnit: String = "ng/dL"
 9:     var body: some View {
10:         NavigationView {
11:             Form {
12:                 Section(header: Text("Blood Test Details")) {
13:                     DatePicker("Date", selection: $date, in: injectionProtocol.startDate..., displayedComponents: [.date, .hourAndMinute])
14:                     TextField("Testosterone Level", text: $valueText)
15:                         .keyboardType(.decimalPad)
16:                     Picker("Unit", selection: $selectedUnit) {
17:                         Text("ng/dL").tag("ng/dL")
18:                         Text("nmol/L").tag("nmol/L")
19:                     }
20:                 }
21:                 Section {
22:                     HStack {
23:                         Spacer()
24:                         VStack(spacing: 4) {
25:                             Text("Protocol: \(injectionProtocol.name)")
26:                                 .font(.subheadline)
27:                             Text("\(injectionProtocol.doseMg, format: .number.precision(.fractionLength(0))) mg \(injectionProtocol.ester.name) every \(injectionProtocol.frequencyDays, format: .number.precision(.fractionLength(1))) days")
28:                                 .font(.caption)
29:                                 .foregroundColor(.secondary)
30:                         }
31:                         Spacer()
32:                     }
33:                     .padding(.vertical, 4)
34:                 }
35:             }
36:             .navigationTitle("Add Blood Test Result")
37:             .toolbar {
38:                 ToolbarItem(placement: .cancellationAction) {
39:                     Button("Cancel") {
40:                         dismiss()
41:                     }
42:                 }
43:                 ToolbarItem(placement: .confirmationAction) {
44:                     Button("Save") {
45:                         saveBloodwork()
46:                     }
47:                     .disabled(Double(valueText) == nil)
48:                 }
49:             }
50:             .onAppear {
51:                 // Default to user's preferred unit
52:                 selectedUnit = dataStore.profile.unit
53:             }
54:         }
55:     }
56:     private func saveBloodwork() {
57:         guard let value = Double(valueText) else { return }
58:         let newSample = BloodSample(
59:             date: date,
60:             value: value,
61:             unit: selectedUnit
62:         )
63:         if let index = dataStore.profile.protocols.firstIndex(where: { $0.id == injectionProtocol.id }) {
64:             dataStore.profile.protocols[index].bloodSamples.append(newSample)
65:             dataStore.saveProfile()
66:             dismiss()
67:         }
68:     }
69: }
70: #Preview {
71:     AddBloodworkView(injectionProtocol: InjectionProtocol(
72:         name: "Test Protocol",
73:         ester: .cypionate,
74:         doseMg: 100,
75:         frequencyDays: 7,
76:         startDate: Date().addingTimeInterval(-30 * 24 * 3600) // 30 days ago
77:     ))
78:     .environmentObject(AppDataStore())
79: }

================
File: TestoSim/Views/ProfileView.swift
================
 1: import SwiftUI
 2: struct ProfileView: View {
 3:     @EnvironmentObject var dataStore: AppDataStore
 4:     var body: some View {
 5:         Form {
 6:             Section("User") {
 7:                 TextField("Name", text: $dataStore.profile.name)
 8:             }
 9:             Section("Settings") {
10:                 Picker("Preferred Unit", selection: $dataStore.profile.unit) {
11:                     Text("ng/dL").tag("ng/dL")
12:                     Text("nmol/L").tag("nmol/L")
13:                 }
14:             }
15:             Section("Calibration") {
16:                 Text("Model Calibration Factor: \(dataStore.profile.calibrationFactor.formatted(.number.precision(.fractionLength(2))))")
17:                 Button("Reset Calibration to 1.0") {
18:                     dataStore.profile.calibrationFactor = 1.0
19:                     dataStore.recalcSimulation()
20:                     dataStore.saveProfile()
21:                 }
22:             }
23:         }
24:         .navigationTitle("Profile Settings")
25:         .onDisappear {
26:             dataStore.saveProfile()
27:         }
28:     }
29: }
30: #Preview {
31:     NavigationStack {
32:         ProfileView()
33:             .environmentObject(AppDataStore())
34:     }
35: }

================
File: TestoSim/Views/ProtocolDetailView.swift
================
  1: import SwiftUI
  2: struct ProtocolDetailView: View {
  3:     @EnvironmentObject var dataStore: AppDataStore
  4:     @State private var showingAddBloodSheet = false
  5:     @State private var showingCalibrateConfirm = false
  6:     let injectionProtocol: InjectionProtocol
  7:     var body: some View {
  8:         ScrollView {
  9:             VStack(alignment: .leading, spacing: 16) {
 10:                 // Protocol summary
 11:                 VStack(alignment: .leading, spacing: 8) {
 12:                     Text("Dose: \(injectionProtocol.doseMg, format: .number.precision(.fractionLength(0))) mg")
 13:                         .font(.headline)
 14:                     Text("Ester: \(injectionProtocol.ester.name)")
 15:                         .font(.headline)
 16:                     Text("Frequency: Every \(injectionProtocol.frequencyDays, format: .number.precision(.fractionLength(1))) days")
 17:                         .font(.headline)
 18:                     Text("Started: \(formatDate(injectionProtocol.startDate))")
 19:                         .font(.headline)
 20:                     if let notes = injectionProtocol.notes, !notes.isEmpty {
 21:                         Text("Notes:")
 22:                             .font(.headline)
 23:                             .padding(.top, 4)
 24:                         Text(notes)
 25:                             .font(.body)
 26:                     }
 27:                 }
 28:                 .padding(.bottom, 8)
 29:                 // Latest blood work display
 30:                 if let latestSample = injectionProtocol.bloodSamples.max(by: { $0.date < $1.date }) {
 31:                     VStack(alignment: .leading, spacing: 4) {
 32:                         Text("Latest Blood Test")
 33:                             .font(.headline)
 34:                         let modelPrediction = dataStore.calculateLevel(at: latestSample.date, 
 35:                                                                       for: injectionProtocol, 
 36:                                                                       using: dataStore.profile.calibrationFactor)
 37:                         Text("Date: \(formatDate(latestSample.date))")
 38:                         Text("Measured: \(dataStore.formatValue(latestSample.value, unit: latestSample.unit)) \(latestSample.unit)")
 39:                         Text("Predicted: \(dataStore.formatValue(modelPrediction, unit: dataStore.profile.unit)) \(dataStore.profile.unit)")
 40:                     }
 41:                     .padding(.vertical, 8)
 42:                     .padding(.horizontal, 12)
 43:                     .background(Color.secondary.opacity(0.1))
 44:                     .cornerRadius(8)
 45:                 }
 46:                 // Simulation chart
 47:                 TestosteroneChart(injectionProtocol: injectionProtocol)
 48:                 // Action buttons
 49:                 HStack(spacing: 20) {
 50:                     Button {
 51:                         showingAddBloodSheet = true
 52:                     } label: {
 53:                         Label("Add Blood Test", systemImage: "drop.fill")
 54:                             .padding(.vertical, 8)
 55:                             .padding(.horizontal, 12)
 56:                     }
 57:                     .buttonStyle(.borderedProminent)
 58:                     Button {
 59:                         dataStore.calibrateProtocol(injectionProtocol)
 60:                         showingCalibrateConfirm = true
 61:                     } label: {
 62:                         Label("Recalibrate Model", systemImage: "slider.horizontal.3")
 63:                             .padding(.vertical, 8)
 64:                             .padding(.horizontal, 12)
 65:                     }
 66:                     .buttonStyle(.bordered)
 67:                     .disabled(injectionProtocol.bloodSamples.isEmpty)
 68:                 }
 69:                 .padding(.top, 8)
 70:             }
 71:             .padding()
 72:         }
 73:         .navigationTitle(injectionProtocol.name)
 74:         .navigationBarTitleDisplayMode(.inline)
 75:         .toolbar {
 76:             ToolbarItem(placement: .primaryAction) {
 77:                 Button("Edit") {
 78:                     dataStore.protocolToEdit = injectionProtocol
 79:                     dataStore.isPresentingProtocolForm = true
 80:                 }
 81:             }
 82:         }
 83:         .onAppear {
 84:             dataStore.selectProtocol(id: injectionProtocol.id)
 85:         }
 86:         .alert("Calibration Updated", isPresented: $showingCalibrateConfirm) {
 87:             Button("OK", role: .cancel) { }
 88:         }
 89:         .sheet(isPresented: $showingAddBloodSheet) {
 90:             AddBloodworkView(injectionProtocol: injectionProtocol)
 91:                 .environmentObject(dataStore)
 92:         }
 93:     }
 94:     private func formatDate(_ date: Date) -> String {
 95:         let formatter = DateFormatter()
 96:         formatter.dateStyle = .medium
 97:         formatter.timeStyle = .none
 98:         return formatter.string(from: date)
 99:     }
100: }
101: #Preview {
102:     NavigationStack {
103:         ProtocolDetailView(injectionProtocol: InjectionProtocol(
104:             name: "Test Protocol",
105:             ester: .cypionate,
106:             doseMg: 100,
107:             frequencyDays: 7,
108:             startDate: Date()
109:         ))
110:         .environmentObject(AppDataStore())
111:     }
112: }

================
File: TestoSim/Views/ProtocolFormView.swift
================
 1: import SwiftUI
 2: struct ProtocolFormView: View {
 3:     @EnvironmentObject var dataStore: AppDataStore
 4:     @Environment(\.dismiss) var dismiss
 5:     var protocolToEdit: InjectionProtocol?
 6:     @State private var name: String = ""
 7:     @State private var selectedEster: TestosteroneEster = .cypionate
 8:     @State private var doseMg: String = ""
 9:     @State private var frequencyDays: String = ""
10:     @State private var startDate: Date = Date()
11:     @State private var notes: String = ""
12:     var isEditing: Bool {
13:         protocolToEdit != nil
14:     }
15:     var body: some View {
16:         NavigationView {
17:             Form {
18:                 Section(header: Text("Protocol Details")) {
19:                     TextField("Name", text: $name)
20:                     Picker("Testosterone Ester", selection: $selectedEster) {
21:                         ForEach(TestosteroneEster.all) { ester in
22:                             Text(ester.name).tag(ester)
23:                         }
24:                     }
25:                     TextField("Dose (mg)", text: $doseMg)
26:                         .keyboardType(.decimalPad)
27:                     TextField("Frequency (days)", text: $frequencyDays)
28:                         .keyboardType(.decimalPad)
29:                     DatePicker("Start Date", selection: $startDate, displayedComponents: [.date])
30:                 }
31:                 Section(header: Text("Notes")) {
32:                     TextEditor(text: $notes)
33:                         .frame(height: 100)
34:                 }
35:             }
36:             .navigationTitle(isEditing ? "Edit Protocol" : "New Protocol")
37:             .toolbar {
38:                 ToolbarItem(placement: .cancellationAction) {
39:                     Button("Cancel") {
40:                         dismiss()
41:                     }
42:                 }
43:                 ToolbarItem(placement: .confirmationAction) {
44:                     Button(isEditing ? "Update" : "Add") {
45:                         saveProtocol()
46:                     }
47:                     .disabled(!isValid)
48:                 }
49:             }
50:             .onAppear {
51:                 if let protocolToEdit = protocolToEdit {
52:                     // Fill form with existing protocol data
53:                     name = protocolToEdit.name
54:                     selectedEster = protocolToEdit.ester
55:                     doseMg = String(format: "%.1f", protocolToEdit.doseMg)
56:                     frequencyDays = String(format: "%.1f", protocolToEdit.frequencyDays)
57:                     startDate = protocolToEdit.startDate
58:                     notes = protocolToEdit.notes ?? ""
59:                 }
60:             }
61:         }
62:     }
63:     private var isValid: Bool {
64:         !name.isEmpty && Double(doseMg) != nil && Double(frequencyDays) != nil
65:     }
66:     private func saveProtocol() {
67:         guard let doseValue = Double(doseMg),
68:               let frequencyValue = Double(frequencyDays) else {
69:             return
70:         }
71:         if isEditing, let protocolToEdit = protocolToEdit {
72:             var updatedProtocol = protocolToEdit
73:             updatedProtocol.name = name
74:             updatedProtocol.ester = selectedEster
75:             updatedProtocol.doseMg = doseValue
76:             updatedProtocol.frequencyDays = frequencyValue
77:             updatedProtocol.startDate = startDate
78:             updatedProtocol.notes = notes.isEmpty ? nil : notes
79:             dataStore.updateProtocol(updatedProtocol)
80:         } else {
81:             let newProtocol = InjectionProtocol(
82:                 name: name,
83:                 ester: selectedEster,
84:                 doseMg: doseValue,
85:                 frequencyDays: frequencyValue,
86:                 startDate: startDate,
87:                 notes: notes.isEmpty ? nil : notes
88:             )
89:             dataStore.addProtocol(newProtocol)
90:         }
91:         dismiss()
92:     }
93: }
94: #Preview {
95:     ProtocolFormView()
96:         .environmentObject(AppDataStore())
97: }

================
File: TestoSim/TestoSim.entitlements
================
 1: <?xml version="1.0" encoding="UTF-8"?>
 2: <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
 3: <plist version="1.0">
 4: <dict>
 5:     <key>com.apple.security.app-sandbox</key>
 6:     <true/>
 7:     <key>com.apple.security.files.user-selected.read-only</key>
 8:     <true/>
 9: </dict>
10: </plist>

================
File: TestoSim.xcodeproj/project.xcworkspace/contents.xcworkspacedata
================
1: <?xml version="1.0" encoding="UTF-8"?>
2: <Workspace
3:    version = "1.0">
4:    <FileRef
5:       location = "self:">
6:    </FileRef>
7: </Workspace>

================
File: TestoSim.xcodeproj/project.pbxproj
================
  1: // !$*UTF8*$!
  2: {
  3: 	archiveVersion = 1;
  4: 	classes = {
  5: 	};
  6: 	objectVersion = 77;
  7: 	objects = {
  8: 
  9: /* Begin PBXContainerItemProxy section */
 10: 		241E9FB42DC3FFA300458576 /* PBXContainerItemProxy */ = {
 11: 			isa = PBXContainerItemProxy;
 12: 			containerPortal = 241E9F9D2DC3FFA200458576 /* Project object */;
 13: 			proxyType = 1;
 14: 			remoteGlobalIDString = 241E9FA42DC3FFA200458576;
 15: 			remoteInfo = TestoSim;
 16: 		};
 17: 		241E9FBE2DC3FFA300458576 /* PBXContainerItemProxy */ = {
 18: 			isa = PBXContainerItemProxy;
 19: 			containerPortal = 241E9F9D2DC3FFA200458576 /* Project object */;
 20: 			proxyType = 1;
 21: 			remoteGlobalIDString = 241E9FA42DC3FFA200458576;
 22: 			remoteInfo = TestoSim;
 23: 		};
 24: /* End PBXContainerItemProxy section */
 25: 
 26: /* Begin PBXFileReference section */
 27: 		241E9FA52DC3FFA200458576 /* TestoSim.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = TestoSim.app; sourceTree = BUILT_PRODUCTS_DIR; };
 28: 		241E9FB32DC3FFA300458576 /* TestoSimTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = TestoSimTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
 29: 		241E9FBD2DC3FFA300458576 /* TestoSimUITests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = TestoSimUITests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
 30: /* End PBXFileReference section */
 31: 
 32: /* Begin PBXFileSystemSynchronizedRootGroup section */
 33: 		241E9FA72DC3FFA200458576 /* TestoSim */ = {
 34: 			isa = PBXFileSystemSynchronizedRootGroup;
 35: 			path = TestoSim;
 36: 			sourceTree = "<group>";
 37: 		};
 38: 		241E9FB62DC3FFA300458576 /* TestoSimTests */ = {
 39: 			isa = PBXFileSystemSynchronizedRootGroup;
 40: 			path = TestoSimTests;
 41: 			sourceTree = "<group>";
 42: 		};
 43: 		241E9FC02DC3FFA300458576 /* TestoSimUITests */ = {
 44: 			isa = PBXFileSystemSynchronizedRootGroup;
 45: 			path = TestoSimUITests;
 46: 			sourceTree = "<group>";
 47: 		};
 48: /* End PBXFileSystemSynchronizedRootGroup section */
 49: 
 50: /* Begin PBXFrameworksBuildPhase section */
 51: 		241E9FA22DC3FFA200458576 /* Frameworks */ = {
 52: 			isa = PBXFrameworksBuildPhase;
 53: 			buildActionMask = 2147483647;
 54: 			files = (
 55: 			);
 56: 			runOnlyForDeploymentPostprocessing = 0;
 57: 		};
 58: 		241E9FB02DC3FFA300458576 /* Frameworks */ = {
 59: 			isa = PBXFrameworksBuildPhase;
 60: 			buildActionMask = 2147483647;
 61: 			files = (
 62: 			);
 63: 			runOnlyForDeploymentPostprocessing = 0;
 64: 		};
 65: 		241E9FBA2DC3FFA300458576 /* Frameworks */ = {
 66: 			isa = PBXFrameworksBuildPhase;
 67: 			buildActionMask = 2147483647;
 68: 			files = (
 69: 			);
 70: 			runOnlyForDeploymentPostprocessing = 0;
 71: 		};
 72: /* End PBXFrameworksBuildPhase section */
 73: 
 74: /* Begin PBXGroup section */
 75: 		241E9F9C2DC3FFA200458576 = {
 76: 			isa = PBXGroup;
 77: 			children = (
 78: 				241E9FA72DC3FFA200458576 /* TestoSim */,
 79: 				241E9FB62DC3FFA300458576 /* TestoSimTests */,
 80: 				241E9FC02DC3FFA300458576 /* TestoSimUITests */,
 81: 				241E9FA62DC3FFA200458576 /* Products */,
 82: 			);
 83: 			sourceTree = "<group>";
 84: 		};
 85: 		241E9FA62DC3FFA200458576 /* Products */ = {
 86: 			isa = PBXGroup;
 87: 			children = (
 88: 				241E9FA52DC3FFA200458576 /* TestoSim.app */,
 89: 				241E9FB32DC3FFA300458576 /* TestoSimTests.xctest */,
 90: 				241E9FBD2DC3FFA300458576 /* TestoSimUITests.xctest */,
 91: 			);
 92: 			name = Products;
 93: 			sourceTree = "<group>";
 94: 		};
 95: /* End PBXGroup section */
 96: 
 97: /* Begin PBXNativeTarget section */
 98: 		241E9FA42DC3FFA200458576 /* TestoSim */ = {
 99: 			isa = PBXNativeTarget;
100: 			buildConfigurationList = 241E9FC72DC3FFA300458576 /* Build configuration list for PBXNativeTarget "TestoSim" */;
101: 			buildPhases = (
102: 				241E9FA12DC3FFA200458576 /* Sources */,
103: 				241E9FA22DC3FFA200458576 /* Frameworks */,
104: 				241E9FA32DC3FFA200458576 /* Resources */,
105: 			);
106: 			buildRules = (
107: 			);
108: 			dependencies = (
109: 			);
110: 			fileSystemSynchronizedGroups = (
111: 				241E9FA72DC3FFA200458576 /* TestoSim */,
112: 			);
113: 			name = TestoSim;
114: 			packageProductDependencies = (
115: 			);
116: 			productName = TestoSim;
117: 			productReference = 241E9FA52DC3FFA200458576 /* TestoSim.app */;
118: 			productType = "com.apple.product-type.application";
119: 		};
120: 		241E9FB22DC3FFA300458576 /* TestoSimTests */ = {
121: 			isa = PBXNativeTarget;
122: 			buildConfigurationList = 241E9FCA2DC3FFA300458576 /* Build configuration list for PBXNativeTarget "TestoSimTests" */;
123: 			buildPhases = (
124: 				241E9FAF2DC3FFA300458576 /* Sources */,
125: 				241E9FB02DC3FFA300458576 /* Frameworks */,
126: 				241E9FB12DC3FFA300458576 /* Resources */,
127: 			);
128: 			buildRules = (
129: 			);
130: 			dependencies = (
131: 				241E9FB52DC3FFA300458576 /* PBXTargetDependency */,
132: 			);
133: 			fileSystemSynchronizedGroups = (
134: 				241E9FB62DC3FFA300458576 /* TestoSimTests */,
135: 			);
136: 			name = TestoSimTests;
137: 			packageProductDependencies = (
138: 			);
139: 			productName = TestoSimTests;
140: 			productReference = 241E9FB32DC3FFA300458576 /* TestoSimTests.xctest */;
141: 			productType = "com.apple.product-type.bundle.unit-test";
142: 		};
143: 		241E9FBC2DC3FFA300458576 /* TestoSimUITests */ = {
144: 			isa = PBXNativeTarget;
145: 			buildConfigurationList = 241E9FCD2DC3FFA300458576 /* Build configuration list for PBXNativeTarget "TestoSimUITests" */;
146: 			buildPhases = (
147: 				241E9FB92DC3FFA300458576 /* Sources */,
148: 				241E9FBA2DC3FFA300458576 /* Frameworks */,
149: 				241E9FBB2DC3FFA300458576 /* Resources */,
150: 			);
151: 			buildRules = (
152: 			);
153: 			dependencies = (
154: 				241E9FBF2DC3FFA300458576 /* PBXTargetDependency */,
155: 			);
156: 			fileSystemSynchronizedGroups = (
157: 				241E9FC02DC3FFA300458576 /* TestoSimUITests */,
158: 			);
159: 			name = TestoSimUITests;
160: 			packageProductDependencies = (
161: 			);
162: 			productName = TestoSimUITests;
163: 			productReference = 241E9FBD2DC3FFA300458576 /* TestoSimUITests.xctest */;
164: 			productType = "com.apple.product-type.bundle.ui-testing";
165: 		};
166: /* End PBXNativeTarget section */
167: 
168: /* Begin PBXProject section */
169: 		241E9F9D2DC3FFA200458576 /* Project object */ = {
170: 			isa = PBXProject;
171: 			attributes = {
172: 				BuildIndependentTargetsInParallel = 1;
173: 				LastSwiftUpdateCheck = 1630;
174: 				LastUpgradeCheck = 1630;
175: 				TargetAttributes = {
176: 					241E9FA42DC3FFA200458576 = {
177: 						CreatedOnToolsVersion = 16.3;
178: 					};
179: 					241E9FB22DC3FFA300458576 = {
180: 						CreatedOnToolsVersion = 16.3;
181: 						TestTargetID = 241E9FA42DC3FFA200458576;
182: 					};
183: 					241E9FBC2DC3FFA300458576 = {
184: 						CreatedOnToolsVersion = 16.3;
185: 						TestTargetID = 241E9FA42DC3FFA200458576;
186: 					};
187: 				};
188: 			};
189: 			buildConfigurationList = 241E9FA02DC3FFA200458576 /* Build configuration list for PBXProject "TestoSim" */;
190: 			developmentRegion = en;
191: 			hasScannedForEncodings = 0;
192: 			knownRegions = (
193: 				en,
194: 				Base,
195: 			);
196: 			mainGroup = 241E9F9C2DC3FFA200458576;
197: 			minimizedProjectReferenceProxies = 1;
198: 			preferredProjectObjectVersion = 77;
199: 			productRefGroup = 241E9FA62DC3FFA200458576 /* Products */;
200: 			projectDirPath = "";
201: 			projectRoot = "";
202: 			targets = (
203: 				241E9FA42DC3FFA200458576 /* TestoSim */,
204: 				241E9FB22DC3FFA300458576 /* TestoSimTests */,
205: 				241E9FBC2DC3FFA300458576 /* TestoSimUITests */,
206: 			);
207: 		};
208: /* End PBXProject section */
209: 
210: /* Begin PBXResourcesBuildPhase section */
211: 		241E9FA32DC3FFA200458576 /* Resources */ = {
212: 			isa = PBXResourcesBuildPhase;
213: 			buildActionMask = 2147483647;
214: 			files = (
215: 			);
216: 			runOnlyForDeploymentPostprocessing = 0;
217: 		};
218: 		241E9FB12DC3FFA300458576 /* Resources */ = {
219: 			isa = PBXResourcesBuildPhase;
220: 			buildActionMask = 2147483647;
221: 			files = (
222: 			);
223: 			runOnlyForDeploymentPostprocessing = 0;
224: 		};
225: 		241E9FBB2DC3FFA300458576 /* Resources */ = {
226: 			isa = PBXResourcesBuildPhase;
227: 			buildActionMask = 2147483647;
228: 			files = (
229: 			);
230: 			runOnlyForDeploymentPostprocessing = 0;
231: 		};
232: /* End PBXResourcesBuildPhase section */
233: 
234: /* Begin PBXSourcesBuildPhase section */
235: 		241E9FA12DC3FFA200458576 /* Sources */ = {
236: 			isa = PBXSourcesBuildPhase;
237: 			buildActionMask = 2147483647;
238: 			files = (
239: 			);
240: 			runOnlyForDeploymentPostprocessing = 0;
241: 		};
242: 		241E9FAF2DC3FFA300458576 /* Sources */ = {
243: 			isa = PBXSourcesBuildPhase;
244: 			buildActionMask = 2147483647;
245: 			files = (
246: 			);
247: 			runOnlyForDeploymentPostprocessing = 0;
248: 		};
249: 		241E9FB92DC3FFA300458576 /* Sources */ = {
250: 			isa = PBXSourcesBuildPhase;
251: 			buildActionMask = 2147483647;
252: 			files = (
253: 			);
254: 			runOnlyForDeploymentPostprocessing = 0;
255: 		};
256: /* End PBXSourcesBuildPhase section */
257: 
258: /* Begin PBXTargetDependency section */
259: 		241E9FB52DC3FFA300458576 /* PBXTargetDependency */ = {
260: 			isa = PBXTargetDependency;
261: 			target = 241E9FA42DC3FFA200458576 /* TestoSim */;
262: 			targetProxy = 241E9FB42DC3FFA300458576 /* PBXContainerItemProxy */;
263: 		};
264: 		241E9FBF2DC3FFA300458576 /* PBXTargetDependency */ = {
265: 			isa = PBXTargetDependency;
266: 			target = 241E9FA42DC3FFA200458576 /* TestoSim */;
267: 			targetProxy = 241E9FBE2DC3FFA300458576 /* PBXContainerItemProxy */;
268: 		};
269: /* End PBXTargetDependency section */
270: 
271: /* Begin XCBuildConfiguration section */
272: 		241E9FC52DC3FFA300458576 /* Debug */ = {
273: 			isa = XCBuildConfiguration;
274: 			buildSettings = {
275: 				ALWAYS_SEARCH_USER_PATHS = NO;
276: 				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
277: 				CLANG_ANALYZER_NONNULL = YES;
278: 				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
279: 				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
280: 				CLANG_ENABLE_MODULES = YES;
281: 				CLANG_ENABLE_OBJC_ARC = YES;
282: 				CLANG_ENABLE_OBJC_WEAK = YES;
283: 				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
284: 				CLANG_WARN_BOOL_CONVERSION = YES;
285: 				CLANG_WARN_COMMA = YES;
286: 				CLANG_WARN_CONSTANT_CONVERSION = YES;
287: 				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
288: 				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
289: 				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
290: 				CLANG_WARN_EMPTY_BODY = YES;
291: 				CLANG_WARN_ENUM_CONVERSION = YES;
292: 				CLANG_WARN_INFINITE_RECURSION = YES;
293: 				CLANG_WARN_INT_CONVERSION = YES;
294: 				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
295: 				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
296: 				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
297: 				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
298: 				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
299: 				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
300: 				CLANG_WARN_STRICT_PROTOTYPES = YES;
301: 				CLANG_WARN_SUSPICIOUS_MOVE = YES;
302: 				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
303: 				CLANG_WARN_UNREACHABLE_CODE = YES;
304: 				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
305: 				COPY_PHASE_STRIP = NO;
306: 				DEBUG_INFORMATION_FORMAT = dwarf;
307: 				DEVELOPMENT_TEAM = LF5UPMD2CC;
308: 				ENABLE_STRICT_OBJC_MSGSEND = YES;
309: 				ENABLE_TESTABILITY = YES;
310: 				ENABLE_USER_SCRIPT_SANDBOXING = YES;
311: 				GCC_C_LANGUAGE_STANDARD = gnu17;
312: 				GCC_DYNAMIC_NO_PIC = NO;
313: 				GCC_NO_COMMON_BLOCKS = YES;
314: 				GCC_OPTIMIZATION_LEVEL = 0;
315: 				GCC_PREPROCESSOR_DEFINITIONS = (
316: 					"DEBUG=1",
317: 					"$(inherited)",
318: 				);
319: 				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
320: 				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
321: 				GCC_WARN_UNDECLARED_SELECTOR = YES;
322: 				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
323: 				GCC_WARN_UNUSED_FUNCTION = YES;
324: 				GCC_WARN_UNUSED_VARIABLE = YES;
325: 				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
326: 				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
327: 				MTL_FAST_MATH = YES;
328: 				ONLY_ACTIVE_ARCH = YES;
329: 				SWIFT_ACTIVE_COMPILATION_CONDITIONS = "DEBUG $(inherited)";
330: 				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
331: 			};
332: 			name = Debug;
333: 		};
334: 		241E9FC62DC3FFA300458576 /* Release */ = {
335: 			isa = XCBuildConfiguration;
336: 			buildSettings = {
337: 				ALWAYS_SEARCH_USER_PATHS = NO;
338: 				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
339: 				CLANG_ANALYZER_NONNULL = YES;
340: 				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
341: 				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
342: 				CLANG_ENABLE_MODULES = YES;
343: 				CLANG_ENABLE_OBJC_ARC = YES;
344: 				CLANG_ENABLE_OBJC_WEAK = YES;
345: 				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
346: 				CLANG_WARN_BOOL_CONVERSION = YES;
347: 				CLANG_WARN_COMMA = YES;
348: 				CLANG_WARN_CONSTANT_CONVERSION = YES;
349: 				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
350: 				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
351: 				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
352: 				CLANG_WARN_EMPTY_BODY = YES;
353: 				CLANG_WARN_ENUM_CONVERSION = YES;
354: 				CLANG_WARN_INFINITE_RECURSION = YES;
355: 				CLANG_WARN_INT_CONVERSION = YES;
356: 				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
357: 				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
358: 				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
359: 				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
360: 				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
361: 				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
362: 				CLANG_WARN_STRICT_PROTOTYPES = YES;
363: 				CLANG_WARN_SUSPICIOUS_MOVE = YES;
364: 				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
365: 				CLANG_WARN_UNREACHABLE_CODE = YES;
366: 				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
367: 				COPY_PHASE_STRIP = NO;
368: 				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
369: 				DEVELOPMENT_TEAM = LF5UPMD2CC;
370: 				ENABLE_NS_ASSERTIONS = NO;
371: 				ENABLE_STRICT_OBJC_MSGSEND = YES;
372: 				ENABLE_USER_SCRIPT_SANDBOXING = YES;
373: 				GCC_C_LANGUAGE_STANDARD = gnu17;
374: 				GCC_NO_COMMON_BLOCKS = YES;
375: 				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
376: 				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
377: 				GCC_WARN_UNDECLARED_SELECTOR = YES;
378: 				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
379: 				GCC_WARN_UNUSED_FUNCTION = YES;
380: 				GCC_WARN_UNUSED_VARIABLE = YES;
381: 				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
382: 				MTL_ENABLE_DEBUG_INFO = NO;
383: 				MTL_FAST_MATH = YES;
384: 				SWIFT_COMPILATION_MODE = wholemodule;
385: 			};
386: 			name = Release;
387: 		};
388: 		241E9FC82DC3FFA300458576 /* Debug */ = {
389: 			isa = XCBuildConfiguration;
390: 			buildSettings = {
391: 				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
392: 				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
393: 				CODE_SIGN_ENTITLEMENTS = TestoSim/TestoSim.entitlements;
394: 				CODE_SIGN_STYLE = Automatic;
395: 				CURRENT_PROJECT_VERSION = 1;
396: 				DEVELOPMENT_TEAM = LF5UPMD2CC;
397: 				ENABLE_HARDENED_RUNTIME = YES;
398: 				ENABLE_PREVIEWS = YES;
399: 				GENERATE_INFOPLIST_FILE = YES;
400: 				"INFOPLIST_KEY_UIApplicationSceneManifest_Generation[sdk=iphoneos*]" = YES;
401: 				"INFOPLIST_KEY_UIApplicationSceneManifest_Generation[sdk=iphonesimulator*]" = YES;
402: 				"INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents[sdk=iphoneos*]" = YES;
403: 				"INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents[sdk=iphonesimulator*]" = YES;
404: 				"INFOPLIST_KEY_UILaunchScreen_Generation[sdk=iphoneos*]" = YES;
405: 				"INFOPLIST_KEY_UILaunchScreen_Generation[sdk=iphonesimulator*]" = YES;
406: 				"INFOPLIST_KEY_UIStatusBarStyle[sdk=iphoneos*]" = UIStatusBarStyleDefault;
407: 				"INFOPLIST_KEY_UIStatusBarStyle[sdk=iphonesimulator*]" = UIStatusBarStyleDefault;
408: 				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
409: 				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = "UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
410: 				IPHONEOS_DEPLOYMENT_TARGET = 18.4;
411: 				LD_RUNPATH_SEARCH_PATHS = "@executable_path/Frameworks";
412: 				"LD_RUNPATH_SEARCH_PATHS[sdk=macosx*]" = "@executable_path/../Frameworks";
413: 				MACOSX_DEPLOYMENT_TARGET = 15.4;
414: 				MARKETING_VERSION = 1.0;
415: 				PRODUCT_BUNDLE_IDENTIFIER = LF5UPMD2CC.TestoSim;
416: 				PRODUCT_NAME = "$(TARGET_NAME)";
417: 				REGISTER_APP_GROUPS = YES;
418: 				SDKROOT = auto;
419: 				SUPPORTED_PLATFORMS = "iphoneos iphonesimulator macosx xros xrsimulator";
420: 				SWIFT_EMIT_LOC_STRINGS = YES;
421: 				SWIFT_VERSION = 5.0;
422: 				TARGETED_DEVICE_FAMILY = "1,2,7";
423: 				XROS_DEPLOYMENT_TARGET = 2.4;
424: 			};
425: 			name = Debug;
426: 		};
427: 		241E9FC92DC3FFA300458576 /* Release */ = {
428: 			isa = XCBuildConfiguration;
429: 			buildSettings = {
430: 				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
431: 				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
432: 				CODE_SIGN_ENTITLEMENTS = TestoSim/TestoSim.entitlements;
433: 				CODE_SIGN_STYLE = Automatic;
434: 				CURRENT_PROJECT_VERSION = 1;
435: 				DEVELOPMENT_TEAM = LF5UPMD2CC;
436: 				ENABLE_HARDENED_RUNTIME = YES;
437: 				ENABLE_PREVIEWS = YES;
438: 				GENERATE_INFOPLIST_FILE = YES;
439: 				"INFOPLIST_KEY_UIApplicationSceneManifest_Generation[sdk=iphoneos*]" = YES;
440: 				"INFOPLIST_KEY_UIApplicationSceneManifest_Generation[sdk=iphonesimulator*]" = YES;
441: 				"INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents[sdk=iphoneos*]" = YES;
442: 				"INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents[sdk=iphonesimulator*]" = YES;
443: 				"INFOPLIST_KEY_UILaunchScreen_Generation[sdk=iphoneos*]" = YES;
444: 				"INFOPLIST_KEY_UILaunchScreen_Generation[sdk=iphonesimulator*]" = YES;
445: 				"INFOPLIST_KEY_UIStatusBarStyle[sdk=iphoneos*]" = UIStatusBarStyleDefault;
446: 				"INFOPLIST_KEY_UIStatusBarStyle[sdk=iphonesimulator*]" = UIStatusBarStyleDefault;
447: 				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
448: 				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = "UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
449: 				IPHONEOS_DEPLOYMENT_TARGET = 18.4;
450: 				LD_RUNPATH_SEARCH_PATHS = "@executable_path/Frameworks";
451: 				"LD_RUNPATH_SEARCH_PATHS[sdk=macosx*]" = "@executable_path/../Frameworks";
452: 				MACOSX_DEPLOYMENT_TARGET = 15.4;
453: 				MARKETING_VERSION = 1.0;
454: 				PRODUCT_BUNDLE_IDENTIFIER = LF5UPMD2CC.TestoSim;
455: 				PRODUCT_NAME = "$(TARGET_NAME)";
456: 				REGISTER_APP_GROUPS = YES;
457: 				SDKROOT = auto;
458: 				SUPPORTED_PLATFORMS = "iphoneos iphonesimulator macosx xros xrsimulator";
459: 				SWIFT_EMIT_LOC_STRINGS = YES;
460: 				SWIFT_VERSION = 5.0;
461: 				TARGETED_DEVICE_FAMILY = "1,2,7";
462: 				XROS_DEPLOYMENT_TARGET = 2.4;
463: 			};
464: 			name = Release;
465: 		};
466: 		241E9FCB2DC3FFA300458576 /* Debug */ = {
467: 			isa = XCBuildConfiguration;
468: 			buildSettings = {
469: 				BUNDLE_LOADER = "$(TEST_HOST)";
470: 				CODE_SIGN_STYLE = Automatic;
471: 				CURRENT_PROJECT_VERSION = 1;
472: 				DEVELOPMENT_TEAM = LF5UPMD2CC;
473: 				GENERATE_INFOPLIST_FILE = YES;
474: 				IPHONEOS_DEPLOYMENT_TARGET = 18.4;
475: 				MACOSX_DEPLOYMENT_TARGET = 15.4;
476: 				MARKETING_VERSION = 1.0;
477: 				PRODUCT_BUNDLE_IDENTIFIER = LF5UPMD2CC.TestoSimTests;
478: 				PRODUCT_NAME = "$(TARGET_NAME)";
479: 				SDKROOT = auto;
480: 				SUPPORTED_PLATFORMS = "iphoneos iphonesimulator macosx xros xrsimulator";
481: 				SWIFT_EMIT_LOC_STRINGS = NO;
482: 				SWIFT_VERSION = 5.0;
483: 				TARGETED_DEVICE_FAMILY = "1,2,7";
484: 				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/TestoSim.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/TestoSim";
485: 				XROS_DEPLOYMENT_TARGET = 2.4;
486: 			};
487: 			name = Debug;
488: 		};
489: 		241E9FCC2DC3FFA300458576 /* Release */ = {
490: 			isa = XCBuildConfiguration;
491: 			buildSettings = {
492: 				BUNDLE_LOADER = "$(TEST_HOST)";
493: 				CODE_SIGN_STYLE = Automatic;
494: 				CURRENT_PROJECT_VERSION = 1;
495: 				DEVELOPMENT_TEAM = LF5UPMD2CC;
496: 				GENERATE_INFOPLIST_FILE = YES;
497: 				IPHONEOS_DEPLOYMENT_TARGET = 18.4;
498: 				MACOSX_DEPLOYMENT_TARGET = 15.4;
499: 				MARKETING_VERSION = 1.0;
500: 				PRODUCT_BUNDLE_IDENTIFIER = LF5UPMD2CC.TestoSimTests;
501: 				PRODUCT_NAME = "$(TARGET_NAME)";
502: 				SDKROOT = auto;
503: 				SUPPORTED_PLATFORMS = "iphoneos iphonesimulator macosx xros xrsimulator";
504: 				SWIFT_EMIT_LOC_STRINGS = NO;
505: 				SWIFT_VERSION = 5.0;
506: 				TARGETED_DEVICE_FAMILY = "1,2,7";
507: 				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/TestoSim.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/TestoSim";
508: 				XROS_DEPLOYMENT_TARGET = 2.4;
509: 			};
510: 			name = Release;
511: 		};
512: 		241E9FCE2DC3FFA300458576 /* Debug */ = {
513: 			isa = XCBuildConfiguration;
514: 			buildSettings = {
515: 				CODE_SIGN_STYLE = Automatic;
516: 				CURRENT_PROJECT_VERSION = 1;
517: 				DEVELOPMENT_TEAM = LF5UPMD2CC;
518: 				GENERATE_INFOPLIST_FILE = YES;
519: 				IPHONEOS_DEPLOYMENT_TARGET = 18.4;
520: 				MACOSX_DEPLOYMENT_TARGET = 15.4;
521: 				MARKETING_VERSION = 1.0;
522: 				PRODUCT_BUNDLE_IDENTIFIER = LF5UPMD2CC.TestoSimUITests;
523: 				PRODUCT_NAME = "$(TARGET_NAME)";
524: 				SDKROOT = auto;
525: 				SUPPORTED_PLATFORMS = "iphoneos iphonesimulator macosx xros xrsimulator";
526: 				SWIFT_EMIT_LOC_STRINGS = NO;
527: 				SWIFT_VERSION = 5.0;
528: 				TARGETED_DEVICE_FAMILY = "1,2,7";
529: 				TEST_TARGET_NAME = TestoSim;
530: 				XROS_DEPLOYMENT_TARGET = 2.4;
531: 			};
532: 			name = Debug;
533: 		};
534: 		241E9FCF2DC3FFA300458576 /* Release */ = {
535: 			isa = XCBuildConfiguration;
536: 			buildSettings = {
537: 				CODE_SIGN_STYLE = Automatic;
538: 				CURRENT_PROJECT_VERSION = 1;
539: 				DEVELOPMENT_TEAM = LF5UPMD2CC;
540: 				GENERATE_INFOPLIST_FILE = YES;
541: 				IPHONEOS_DEPLOYMENT_TARGET = 18.4;
542: 				MACOSX_DEPLOYMENT_TARGET = 15.4;
543: 				MARKETING_VERSION = 1.0;
544: 				PRODUCT_BUNDLE_IDENTIFIER = LF5UPMD2CC.TestoSimUITests;
545: 				PRODUCT_NAME = "$(TARGET_NAME)";
546: 				SDKROOT = auto;
547: 				SUPPORTED_PLATFORMS = "iphoneos iphonesimulator macosx xros xrsimulator";
548: 				SWIFT_EMIT_LOC_STRINGS = NO;
549: 				SWIFT_VERSION = 5.0;
550: 				TARGETED_DEVICE_FAMILY = "1,2,7";
551: 				TEST_TARGET_NAME = TestoSim;
552: 				XROS_DEPLOYMENT_TARGET = 2.4;
553: 			};
554: 			name = Release;
555: 		};
556: /* End XCBuildConfiguration section */
557: 
558: /* Begin XCConfigurationList section */
559: 		241E9FA02DC3FFA200458576 /* Build configuration list for PBXProject "TestoSim" */ = {
560: 			isa = XCConfigurationList;
561: 			buildConfigurations = (
562: 				241E9FC52DC3FFA300458576 /* Debug */,
563: 				241E9FC62DC3FFA300458576 /* Release */,
564: 			);
565: 			defaultConfigurationIsVisible = 0;
566: 			defaultConfigurationName = Release;
567: 		};
568: 		241E9FC72DC3FFA300458576 /* Build configuration list for PBXNativeTarget "TestoSim" */ = {
569: 			isa = XCConfigurationList;
570: 			buildConfigurations = (
571: 				241E9FC82DC3FFA300458576 /* Debug */,
572: 				241E9FC92DC3FFA300458576 /* Release */,
573: 			);
574: 			defaultConfigurationIsVisible = 0;
575: 			defaultConfigurationName = Release;
576: 		};
577: 		241E9FCA2DC3FFA300458576 /* Build configuration list for PBXNativeTarget "TestoSimTests" */ = {
578: 			isa = XCConfigurationList;
579: 			buildConfigurations = (
580: 				241E9FCB2DC3FFA300458576 /* Debug */,
581: 				241E9FCC2DC3FFA300458576 /* Release */,
582: 			);
583: 			defaultConfigurationIsVisible = 0;
584: 			defaultConfigurationName = Release;
585: 		};
586: 		241E9FCD2DC3FFA300458576 /* Build configuration list for PBXNativeTarget "TestoSimUITests" */ = {
587: 			isa = XCConfigurationList;
588: 			buildConfigurations = (
589: 				241E9FCE2DC3FFA300458576 /* Debug */,
590: 				241E9FCF2DC3FFA300458576 /* Release */,
591: 			);
592: 			defaultConfigurationIsVisible = 0;
593: 			defaultConfigurationName = Release;
594: 		};
595: /* End XCConfigurationList section */
596: 	};
597: 	rootObject = 241E9F9D2DC3FFA200458576 /* Project object */;
598: }

================
File: TestoSimTests/TestoSimTests.swift
================
 1: //
 2: //  TestoSimTests.swift
 3: //  TestoSimTests
 4: //
 5: //  Created by Jesper Vang on 01/05/2025.
 6: //
 7: import Testing
 8: struct TestoSimTests {
 9:     @Test func example() async throws {
10:         // Write your test here and use APIs like `#expect(...)` to check expected conditions.
11:     }
12: }

================
File: TestoSimUITests/TestoSimUITests.swift
================
 1: //
 2: //  TestoSimUITests.swift
 3: //  TestoSimUITests
 4: //
 5: //  Created by Jesper Vang on 01/05/2025.
 6: //
 7: import XCTest
 8: final class TestoSimUITests: XCTestCase {
 9:     override func setUpWithError() throws {
10:         // Put setup code here. This method is called before the invocation of each test method in the class.
11:         // In UI tests it is usually best to stop immediately when a failure occurs.
12:         continueAfterFailure = false
13:         // In UI tests it’s important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.
14:     }
15:     override func tearDownWithError() throws {
16:         // Put teardown code here. This method is called after the invocation of each test method in the class.
17:     }
18:     @MainActor
19:     func testExample() throws {
20:         // UI tests must launch the application that they test.
21:         let app = XCUIApplication()
22:         app.launch()
23:         // Use XCTAssert and related functions to verify your tests produce the correct results.
24:     }
25:     @MainActor
26:     func testLaunchPerformance() throws {
27:         // This measures how long it takes to launch your application.
28:         measure(metrics: [XCTApplicationLaunchMetric()]) {
29:             XCUIApplication().launch()
30:         }
31:     }
32: }

================
File: TestoSimUITests/TestoSimUITestsLaunchTests.swift
================
 1: //
 2: //  TestoSimUITestsLaunchTests.swift
 3: //  TestoSimUITests
 4: //
 5: //  Created by Jesper Vang on 01/05/2025.
 6: //
 7: import XCTest
 8: final class TestoSimUITestsLaunchTests: XCTestCase {
 9:     override class var runsForEachTargetApplicationUIConfiguration: Bool {
10:         true
11:     }
12:     override func setUpWithError() throws {
13:         continueAfterFailure = false
14:     }
15:     @MainActor
16:     func testLaunch() throws {
17:         let app = XCUIApplication()
18:         app.launch()
19:         // Insert steps here to perform after app launch but before taking a screenshot,
20:         // such as logging into a test account or navigating somewhere in the app
21:         let attachment = XCTAttachment(screenshot: app.screenshot())
22:         attachment.name = "Launch Screen"
23:         attachment.lifetime = .keepAlways
24:         add(attachment)
25:     }
26: }

================
File: .gitignore
================
  1: # Xcode
  2: #
  3: # gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore & Swift.gitignore
  4: 
  5: ## User settings
  6: xcuserdata/
  7: 
  8: ## Compatibility with Xcode
  9: *.moved-aside
 10: *.xccheckout
 11: *.xcscmblueprint
 12: 
 13: ## Build generated
 14: build/
 15: DerivedData/
 16: 
 17: ## Various settings
 18: *.pbxuser
 19: !default.pbxuser
 20: *.mode1v3
 21: !default.mode1v3
 22: *.mode2v3
 23: !default.mode2v3
 24: *.perspectivev3
 25: !default.perspectivev3
 26: 
 27: ## Other
 28: *.moved-aside
 29: *.xcuserdata
 30: *.xcscmblueprint
 31: 
 32: ## Obj-C/Swift specific
 33: *.hmap
 34: *.ipa
 35: *.dSYM.zip
 36: *.dSYM
 37: 
 38: ## Playgrounds
 39: timeline.xctimeline
 40: playground.xcworkspace
 41: 
 42: # Swift Package Manager
 43: #
 44: # Add this line if you want to avoid checking in source code from Swift Package Manager dependencies.
 45: # Packages/
 46: # Package.pins
 47: # Package.resolved
 48: # *.xcodeproj
 49: #
 50: # Xcode automatically generates this directory with a .xcworkspacedata file and xcuserdata
 51: # hence it is not needed unless you have added a package configuration file to your project
 52: # .swiftpm
 53: 
 54: # CocoaPods
 55: #
 56: # We recommend against adding the Pods directory to your .gitignore. However
 57: # you should judge for yourself, the pros and cons are mentioned at:
 58: # https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control
 59: #
 60: # Pods/
 61: #
 62: # Add this line if you want to avoid checking in source code from the Xcode workspace
 63: # *.xcworkspace
 64: 
 65: # Carthage
 66: #
 67: # Add this line if you want to avoid checking in source code from Carthage dependencies.
 68: # Carthage/Checkouts
 69: 
 70: Carthage/Build/
 71: 
 72: # Accio dependency management
 73: Dependencies/
 74: .accio/
 75: 
 76: # fastlane
 77: #
 78: # It is recommended to not store the screenshots in the git repo.
 79: # Instead, use fastlane to re-generate the screenshots whenever they are needed.
 80: # For more information about the recommended setup visit:
 81: # https://docs.fastlane.tools/best-practices/source-control/#source-control
 82: 
 83: fastlane/report.xml
 84: fastlane/Preview.html
 85: fastlane/screenshots/**/*.png
 86: fastlane/test_output
 87: 
 88: # Code Injection
 89: #
 90: # After new code Injection tools there's a generated folder /iOSInjectionProject
 91: # https://github.com/johnno1962/injectionforxcode
 92: 
 93: iOSInjectionProject/
 94: 
 95: # macOS
 96: .DS_Store
 97: 
 98: # cursor
 99: .cursor/
100: 
101: # App specific
102: memory.jsonl

================
File: buildServer.json
================
 1: {
 2: 	"name": "xcode build server",
 3: 	"version": "0.2",
 4: 	"bspVersion": "2.0",
 5: 	"languages": [
 6: 		"c",
 7: 		"cpp",
 8: 		"objective-c",
 9: 		"objective-cpp",
10: 		"swift"
11: 	],
12: 	"argv": [
13: 		"/opt/homebrew/bin/xcode-build-server"
14: 	],
15: 	"workspace": "/Users/jesper/Projects/Dev_projects/Xcode/TestoSim/TestoSim.xcodeproj/project.xcworkspace",
16: 	"build_root": "/Users/jesper/Library/Developer/Xcode/DerivedData/TestoSim-amdpjdmzwgneoqgnxzlcnphserjo",
17: 	"scheme": "TestoSim",
18: 	"kind": "xcode"
19: }

================
File: TestoSim/Models/ProfileModel.swift
================
 1: import Foundation
 2: struct UserProfile: Codable {
 3:     var id: UUID = UUID()
 4:     var name: String = "My Profile"
 5:     var unit: String = "ng/dL" // Default unit
 6:     var calibrationFactor: Double = 1.0 // Default calibration
 7:     var protocols: [InjectionProtocol] = []
 8:     // New parameters for Story 9 and 10
 9:     var dateOfBirth: Date?
10:     var heightCm: Double?
11:     var weight: Double? = 70.0 // Default weight in kg
12:     enum BiologicalSex: String, Codable, CaseIterable {
13:         case male, female
14:     }
15:     var biologicalSex: BiologicalSex = .male
16:     var usesICloudSync: Bool = false
17:     // Computed property for body surface area (DuBois formula)
18:     var bodySurfaceArea: Double? {
19:         guard let weight = weight, let heightCm = heightCm else {
20:             return nil
21:         }
22:         // DuBois formula: BSA (m²) = 0.007184 × height(cm)^0.725 × weight(kg)^0.425
23:         return 0.007184 * pow(heightCm, 0.725) * pow(weight, 0.425)
24:     }
25:     // Computed property for age
26:     var age: Int? {
27:         guard let dob = dateOfBirth else {
28:             return nil
29:         }
30:         let calendar = Calendar.current
31:         let ageComponents = calendar.dateComponents([.year], from: dob, to: Date())
32:         return ageComponents.year
33:     }
34: }

================
File: TestoSim/Views/ProtocolListView.swift
================
 1: import SwiftUI
 2: struct ProtocolListView: View {
 3:     @EnvironmentObject var dataStore: AppDataStore
 4:     var body: some View {
 5:         List {
 6:             if dataStore.profile.protocols.isEmpty {
 7:                 Text("No protocols yet. Tap + to add one.")
 8:                     .foregroundColor(.secondary)
 9:             } else {
10:                 ForEach(dataStore.profile.protocols) { injectionProtocol in
11:                     NavigationLink(destination: ProtocolDetailView(injectionProtocol: injectionProtocol)) {
12:                         VStack(alignment: .leading) {
13:                             Text(injectionProtocol.name)
14:                                 .font(.headline)
15:                             Text("\(injectionProtocol.doseMg, format: .number.precision(.fractionLength(0))) mg \(injectionProtocol.ester.name) every \(injectionProtocol.frequencyDays, format: .number.precision(.fractionLength(1))) days")
16:                                 .font(.subheadline)
17:                                 .foregroundColor(.secondary)
18:                         }
19:                     }
20:                 }
21:                 .onDelete(perform: deleteItems)
22:             }
23:         }
24:         .navigationTitle("Protocols")
25:         .toolbar {
26:             ToolbarItem(placement: .automatic) {
27:                 NavigationLink(destination: ProfileView()) {
28:                     Label("Profile", systemImage: "person.circle")
29:                 }
30:             }
31:             ToolbarItem(placement: .primaryAction) {
32:                 Button {
33:                     dataStore.protocolToEdit = nil
34:                     dataStore.isPresentingProtocolForm = true
35:                 } label: {
36:                     Label("Add Protocol", systemImage: "plus")
37:                 }
38:             }
39:         }
40:         .sheet(isPresented: $dataStore.isPresentingProtocolForm) {
41:             ProtocolFormView(protocolToEdit: dataStore.protocolToEdit)
42:                 .environmentObject(dataStore)
43:         }
44:     }
45:     private func deleteItems(at offsets: IndexSet) {
46:         dataStore.removeProtocol(at: offsets)
47:     }
48: }
49: #Preview {
50:     NavigationStack {
51:         ProtocolListView()
52:             .environmentObject(AppDataStore())
53:     }
54: }

================
File: TestoSim/Views/TestosteroneChart.swift
================
 1: import SwiftUI
 2: import Charts
 3: struct TestosteroneChart: View {
 4:     @EnvironmentObject var dataStore: AppDataStore
 5:     let injectionProtocol: InjectionProtocol
 6:     var simStartDate: Date {
 7:         dataStore.simulationData.first?.time ?? injectionProtocol.startDate
 8:     }
 9:     var simEndDate: Date {
10:         dataStore.simulationData.last?.time ?? dataStore.simulationEndDate
11:     }
12:     var body: some View {
13:         VStack(alignment: .leading) {
14:             Text("Simulated Testosterone Levels")
15:                 .font(.headline)
16:                 .padding(.bottom, 4)
17:             if dataStore.simulationData.isEmpty {
18:                 Text("No simulation data available")
19:                     .foregroundColor(.secondary)
20:             } else {
21:                 Chart {
22:                     // Simulation curve
23:                     ForEach(dataStore.simulationData) { point in
24:                         LineMark(
25:                             x: .value("Date", point.time),
26:                             y: .value("Level", point.level)
27:                         )
28:                         .foregroundStyle(.blue)
29:                         AreaMark(
30:                             x: .value("Date", point.time),
31:                             y: .value("Level", point.level)
32:                         )
33:                         .foregroundStyle(
34:                             LinearGradient(
35:                                 gradient: Gradient(colors: [.blue.opacity(0.3), .blue.opacity(0.0)]), 
36:                                 startPoint: .top, 
37:                                 endPoint: .bottom
38:                             )
39:                         )
40:                     }
41:                     // Injection markers
42:                     ForEach(injectionProtocol.injectionDates(from: simStartDate, upto: simEndDate), id: \.self) { injDate in
43:                         RuleMark(x: .value("Injection Date", injDate))
44:                             .lineStyle(StrokeStyle(lineWidth: 1, dash: [2, 4]))
45:                             .foregroundStyle(.gray)
46:                             .annotation(position: .bottom, alignment: .center) {
47:                                 Image(systemName: "syringe")
48:                                     .font(.caption)
49:                                     .foregroundColor(.gray)
50:                             }
51:                     }
52:                     // Blood sample points
53:                     ForEach(injectionProtocol.bloodSamples) { sample in
54:                         PointMark(
55:                             x: .value("Sample Date", sample.date),
56:                             y: .value("Sample Level", sample.value)
57:                         )
58:                         .foregroundStyle(.red)
59:                         .annotation(position: .top) {
60:                             Text(dataStore.formatValue(sample.value, unit: sample.unit))
61:                                 .font(.caption)
62:                                 .foregroundColor(.red)
63:                                 .padding(.bottom, 8)
64:                         }
65:                     }
66:                 }
67:                 .frame(height: 300)
68:                 .chartXAxis {
69:                     AxisMarks(values: .automatic(desiredCount: 8)) {
70:                         AxisGridLine()
71:                         AxisValueLabel(format: .dateTime.month().day(), centered: true)
72:                     }
73:                 }
74:                 .chartYAxis {
75:                     AxisMarks {
76:                         AxisGridLine()
77:                         AxisValueLabel()
78:                     }
79:                 }
80:                 .chartYAxisLabel("Level (\(dataStore.profile.unit))")
81:                 .chartXAxisLabel("Date")
82:             }
83:         }
84:         .padding()
85:     }
86: }
87: #Preview {
88:     TestosteroneChart(injectionProtocol: InjectionProtocol(
89:         name: "Test Protocol",
90:         ester: .cypionate,
91:         doseMg: 100,
92:         frequencyDays: 7,
93:         startDate: Date()
94:     ))
95:     .environmentObject(AppDataStore())
96: }

================
File: TestoSim/ContentView.swift
================
 1: //
 2: //  ContentView.swift
 3: //  TestoSim
 4: //
 5: //  Created by Jesper Vang on 01/05/2025.
 6: //
 7: import SwiftUI
 8: struct ContentView: View {
 9:     @EnvironmentObject var dataStore: AppDataStore
10:     var body: some View {
11:         NavigationStack {
12:             ProtocolListView()
13:         }
14:     }
15: }
16: #Preview {
17:     ContentView()
18:         .environmentObject(AppDataStore())
19: }

================
File: TestoSim/TestoSimApp.swift
================
 1: //
 2: //  TestoSimApp.swift
 3: //  TestoSim
 4: //
 5: //  Created by Jesper Vang on 01/05/2025.
 6: //
 7: import SwiftUI
 8: @main
 9: struct TestoSimApp: App {
10:     @StateObject private var dataStore = AppDataStore()
11:     var body: some Scene {
12:         WindowGroup {
13:             ContentView()
14:                 .environmentObject(dataStore)
15:         }
16:     }
17: }

================
File: guide.md
================
  1: Okay, this is an excellent and highly detailed implementation plan. Let's transform it into the precise checklist format suitable for a code assistant. Each item will be a specific, actionable task with an unchecked checkbox `[ ]`.
  2: 
  3: Here is the detailed checklist:
  4: 
  5: **Testosterone Pharmacokinetics Simulation App – Detailed Implementation Checklist**
  6: 
  7: **Instructions for Code Assistant:** Follow this checklist step-by-step. Each `[ ]` represents a task to complete. Implement the code exactly as described, using the provided names, structures, formulas, and UI components. Assume you are working within an Xcode project targeting iOS 16+ and macOS 13+.
  8: 
  9: ---
 10: 
 11: ### Story 1: Project Setup and Structure
 12: 
 13: *   [x] **Initialize SwiftUI Project:**
 14:     *   Create a new Xcode project using the **SwiftUI App** template.
 15:     *   Name the project `TestoSim`.
 16:     *   Ensure the targets include **iOS** (and optionally **macOS**).
 17:     *   Set the minimum deployment target to **iOS 16.0** and **macOS 13.0**.
 18: *   [x] **Create Project Groups:**
 19:     *   In the Xcode Project Navigator, create the following groups (folders):
 20:         *   `Models`
 21:         *   `Views`
 22:         *   `ViewModels` (or `Stores`)
 23:         *   `Resources` (for assets like AppIcon later)
 24: *   [x] **Add Frameworks:**
 25:     *   Confirm the **Charts** framework is available (part of SwiftUI on iOS 16+). Add `import Charts` in files that will use it.
 26:     *   *(Optional - If adding Lottie)* Add the Lottie package via Swift Package Manager: `File > Add Packages...`, search for `airbnb/lottie-ios`, and add the package dependency.
 27: *   [x] **Setup SwiftUI App Struct:**
 28:     *   Open the main App struct file (e.g., `TestoSimApp.swift`).
 29:     *   Declare an `@StateObject` for the central data store (which will be created later).
 30:     *   Provide this store as an `@EnvironmentObject` to the `ContentView`.
 31:     ```swift
 32:     import SwiftUI
 33: 
 34:     @main
 35:     struct TestoSimApp: App {
 36:         @StateObject private var dataStore = AppDataStore() // Implementation follows in Story 3
 37: 
 38:         var body: some Scene {
 39:             WindowGroup {
 40:                 ContentView() // Implementation follows in Story 4
 41:                     .environmentObject(dataStore)
 42:             }
 43:         }
 44:     }
 45:     ```
 46: 
 47: ---
 48: 
 49: ### Story 2: Data Models and Persistence
 50: 
 51: *   [x] **Define Testosterone Ester Data:**
 52:     *   Create a new Swift file named `EsterData.swift` inside the `Models` group.
 53:     *   Define the `TestosteroneEster` struct:
 54:         *   Make it conform to `Identifiable` and `Codable`.
 55:         *   Include properties: `id: UUID`, `name: String`, `halfLifeDays: Double`.
 56:         *   Define static constants for the supported esters using the provided half-life values:
 57:             *   `propionate`: name "Propionate", halfLifeDays `0.8`
 58:             *   `enanthate`: name "Enanthate", halfLifeDays `4.5`
 59:             *   `cypionate`: name "Cypionate", halfLifeDays `7.0`
 60:             *   `undecanoate`: name "Undecanoate", halfLifeDays `30.0`
 61:         *   Add a static property `all: [TestosteroneEster]` containing all defined esters.
 62:     ```swift
 63:     import Foundation
 64: 
 65:     struct TestosteroneEster: Identifiable, Codable, Hashable { // Added Hashable for potential use in Pickers
 66:         let id: UUID
 67:         let name: String
 68:         let halfLifeDays: Double
 69: 
 70:         // Default initializer if needed, or rely on memberwise
 71:         init(id: UUID = UUID(), name: String, halfLifeDays: Double) {
 72:             self.id = id
 73:             self.name = name
 74:             self.halfLifeDays = halfLifeDays
 75:         }
 76: 
 77:         static let propionate = TestosteroneEster(name: "Propionate", halfLifeDays: 0.8)
 78:         static let enanthate = TestosteroneEster(name: "Enanthate", halfLifeDays: 4.5)
 79:         static let cypionate = TestosteroneEster(name: "Cypionate", halfLifeDays: 7.0)
 80:         static let undecanoate = TestosteroneEster(name: "Undecanoate", halfLifeDays: 30.0)
 81: 
 82:         static let all: [TestosteroneEster] = [ .propionate, .enanthate, .cypionate, .undecanoate ]
 83:     }
 84:     ```
 85: *   [x] **Define Injection Protocol Model:**
 86:     *   Create a new Swift file named `ProtocolModel.swift` inside the `Models` group.
 87:     *   Define the `InjectionProtocol` struct:
 88:         *   Make it conform to `Identifiable` and `Codable`.
 89:         *   Include properties:
 90:             *   `id: UUID`
 91:             *   `name: String`
 92:             *   `ester: TestosteroneEster`
 93:             *   `doseMg: Double`
 94:             *   `frequencyDays: Double`
 95:             *   `startDate: Date`
 96:             *   `notes: String?` (optional)
 97:             *   `bloodSamples: [BloodSample]` (initialize as `[]`. `BloodSample` defined next).
 98:     ```swift
 99:     import Foundation
100: 
101:     struct InjectionProtocol: Identifiable, Codable {
102:         var id: UUID = UUID() // Use var if you might need to replace it during edits
103:         var name: String
104:         var ester: TestosteroneEster
105:         var doseMg: Double
106:         var frequencyDays: Double
107:         var startDate: Date
108:         var notes: String?
109:         var bloodSamples: [BloodSample] = [] // BloodSample struct defined next
110:     }
111:     ```
112: *   [x] **Define Bloodwork Model:**
113:     *   Create a new Swift file named `BloodworkModel.swift` inside the `Models` group.
114:     *   Define the `BloodSample` struct:
115:         *   Make it conform to `Identifiable` and `Codable`.
116:         *   Include properties:
117:             *   `id: UUID`
118:             *   `date: Date`
119:             *   `value: Double`
120:             *   `unit: String` (e.g., "ng/dL" or "nmol/L")
121:     ```swift
122:     import Foundation
123: 
124:     struct BloodSample: Identifiable, Codable, Hashable { // Added Hashable for ForEach iteration if needed
125:         let id: UUID
126:         let date: Date
127:         let value: Double
128:         let unit: String
129: 
130:         // Default initializer if needed
131:         init(id: UUID = UUID(), date: Date, value: Double, unit: String) {
132:             self.id = id
133:             self.date = date
134:             self.value = value
135:             self.unit = unit
136:         }
137:     }
138:     ```
139: *   [x] **Define User Profile Model:**
140:     *   Create a new Swift file named `ProfileModel.swift` inside the `Models` group.
141:     *   Define the `UserProfile` struct:
142:         *   Make it conform to `Codable`.
143:         *   Include properties:
144:             *   `id: UUID`
145:             *   `name: String`
146:             *   `unit: String` (default "ng/dL")
147:             *   `calibrationFactor: Double` (default `1.0`)
148:             *   `protocols: [InjectionProtocol]` (initialize as `[]`)
149:     ```swift
150:     import Foundation
151: 
152:     struct UserProfile: Codable {
153:         var id: UUID = UUID()
154:         var name: String = "My Profile"
155:         var unit: String = "ng/dL" // Default unit
156:         var calibrationFactor: Double = 1.0 // Default calibration
157:         var protocols: [InjectionProtocol] = []
158:     }
159:     ```
160: *   [x] **Implement Default Data Creation:**
161:     *   Inside the `AppDataStore` class initializer (to be created in Story 3), implement logic to create a default `UserProfile` if none is loaded.
162:     *   This default profile should include at least one sample `InjectionProtocol`. Example:
163:         *   Name: "Default TRT"
164:         *   Ester: `.cypionate`
165:         *   Dose: `100.0` mg
166:         *   Frequency: `7.0` days
167:         *   Start Date: `Date()` (today)
168: *   [x] **Implement Persistence Logic (in AppDataStore):**
169:     *   Inside the `AppDataStore` class (Story 3), add methods for saving and loading the `UserProfile`.
170:     *   **Saving:** Create `func saveProfile()`. Use `JSONEncoder` to encode the `profile` property and save it to `UserDefaults` under the key `"userProfileData"`.
171:     *   **Loading:** In the `init()` of `AppDataStore`, attempt to load data from `UserDefaults` using the key `"userProfileData"`. Use `JSONDecoder` to decode it into a `UserProfile`. If loading fails or no data exists, create the default profile (as defined in the previous step). Handle potential decoding errors (e.g., using `try?` and falling back to default).
172: 
173: ---
174: 
175: ### Story 3: Pharmacokinetic Simulation Logic
176: 
177: *   [x] **Define Simulation Parameters:**
178:     *   In `AppDataStore`, add properties to control the simulation duration.
179:     *   `let simulationDurationDays: Double = 90.0` (or adjust based on half-life later if desired).
180:     *   Add a computed property `simulationEndDate` based on the *selected* protocol's `startDate` and `simulationDurationDays`.
181: *   [x] **Implement Level Calculation Function:**
182:     *   Create a helper function, perhaps within `AppDataStore` or as a static method, to calculate the concentration at a specific time `t` for a given protocol.
183:     *   Signature idea: `func calculateLevel(at targetDate: Date, for protocol: InjectionProtocol, using calibrationFactor: Double) -> Double`
184:     *   Implement the logic based on the formula:
185:         1.  Calculate time `t_days` in days from `protocol.startDate` to `targetDate`. Return 0 if `targetDate` is before `startDate`.
186:         2.  Calculate the elimination constant `k = log(2) / protocol.ester.halfLifeDays`. Use `log` from `Foundation` (natural logarithm).
187:         3.  Initialize `totalLevel = 0.0`.
188:         4.  Iterate through injection indices `n = 0, 1, 2, ...`.
189:         5.  For each `n`, calculate injection time `injTime_days = Double(n) * protocol.frequencyDays`.
190:         6.  If `injTime_days > t_days`, break the loop.
191:         7.  Calculate time since this injection: `timeDiff_days = t_days - injTime_days`.
192:         8.  Calculate contribution: `contribution = protocol.doseMg * exp(-k * timeDiff_days)`. Use `exp` from `Foundation`.
193:         9.  Add contribution to `totalLevel`.
194:         10. After the loop, multiply `totalLevel` by the `calibrationFactor`.
195:         11. Return the final `totalLevel`.
196:     ```swift
197:     // Example placement inside AppDataStore or a dedicated utility struct/file
198:     func calculateLevel(at targetDate: Date, for protocol: InjectionProtocol, using calibrationFactor: Double) -> Double {
199:         let t_days = targetDate.timeIntervalSince(protocol.startDate) / (24 * 3600) // Time in days since start
200:         guard t_days >= 0 else { return 0.0 }
201: 
202:         guard protocol.ester.halfLifeDays > 0 else { return 0.0 } // Avoid division by zero if halfLife is 0
203:         let k = log(2) / protocol.ester.halfLifeDays // Natural log
204: 
205:         var totalLevel = 0.0
206:         var injIndex = 0
207:         while true {
208:             let injTime_days = Double(injIndex) * protocol.frequencyDays
209:             // Optimization: If frequency is 0 or negative, only consider the first injection
210:             if protocol.frequencyDays <= 0 && injIndex > 0 { break }
211: 
212:             if injTime_days > t_days { break } // Stop if injection time is after target time
213: 
214:             let timeDiff_days = t_days - injTime_days
215:             if timeDiff_days >= 0 { // Ensure we only calculate for times after injection
216:                  let contribution = protocol.doseMg * exp(-k * timeDiff_days)
217:                  totalLevel += contribution
218:             }
219: 
220:             // Check for infinite loop condition if frequency is 0
221:              if protocol.frequencyDays <= 0 { break }
222: 
223:             injIndex += 1
224:              // Safety break if index gets excessively large (e.g., > 10000) though unlikely with date limits
225:              if injIndex > 10000 { break }
226:         }
227: 
228:         return totalLevel * calibrationFactor
229:     }
230:     ```
231: *   [x] **Define DataPoint Struct:**
232:     *   Create a simple struct to hold simulation data points for the chart. Place it maybe near `AppDataStore` or in `Models`.
233:     ```swift
234:     import Foundation
235: 
236:     struct DataPoint: Identifiable {
237:         let id = UUID() // For ForEach iteration if needed
238:         let time: Date // Use Date for direct use with Swift Charts axis
239:         let level: Double
240:     }
241:     ```
242: *   [x] **Implement Data Series Generation Function:**
243:     *   Create a method in `AppDataStore`, e.g., `func generateSimulationData(for protocol: InjectionProtocol) -> [DataPoint]`.
244:     *   Determine the `endDate` (e.g., `protocol.startDate + simulationDurationDays * 24 * 3600`).
245:     *   Define the time step (e.g., `stepInterval: TimeInterval = 24 * 3600` for daily points, or smaller like `4 * 3600` for 4-hourly).
246:     *   Iterate from `protocol.startDate` up to `endDate` with the chosen `stepInterval`.
247:     *   In each step, call `calculateLevel(at: currentDate, for: protocol, using: profile.calibrationFactor)`.
248:     *   Create a `DataPoint` with the `currentDate` and calculated `level`.
249:     *   Append the `DataPoint` to an array.
250:     *   Return the completed array of `DataPoint`.
251: *   [x] **Setup AppDataStore Class:**
252:     *   Create a new Swift file named `AppDataStore.swift` inside the `ViewModels` group.
253:     *   Define the class `AppDataStore: ObservableObject`. Mark it with `@MainActor`.
254:     *   Add `@Published var profile: UserProfile`.
255:     *   Add `@Published var simulationData: [DataPoint] = []`.
256:     *   Add `@Published var selectedProtocolID: UUID?`.
257:     *   Add `@Published var isPresentingProtocolForm = false`. // For add/edit sheet
258:     *   Add `@Published var protocolToEdit: InjectionProtocol?`. // To know if adding or editing
259: 
260:     *   Implement the `init()` method:
261:         *   Call the loading logic (defined in Story 2) to load `profile` from UserDefaults or create a default one.
262:         *   If `profile.protocols` is not empty, set `selectedProtocolID = profile.protocols.first?.id`.
263:         *   Call `recalcSimulation()` to generate initial data for the selected protocol.
264: *   [x] **Implement AppDataStore Methods:**
265:     *   Implement `func addProtocol(_ newProtocol: InjectionProtocol)`:
266:         *   Append `newProtocol` to `profile.protocols`.
267:         *   Optionally set `selectedProtocolID = newProtocol.id`.
268:         *   Call `recalcSimulation()`.
269:         *   Call `saveProfile()`.
270:     *   Implement `func updateProtocol(_ updatedProtocol: InjectionProtocol)`:
271:         *   Find the index of the protocol with the same `id` in `profile.protocols`.
272:         *   If found, replace the protocol at that index with `updatedProtocol`.
273:         *   If the updated protocol is the currently selected one (`updatedProtocol.id == selectedProtocolID`), call `recalcSimulation()`.
274:         *   Call `saveProfile()`.
275:     *   Implement `func removeProtocol(at offsets: IndexSet)` (for List onDelete):
276:         *   Remove protocols from `profile.protocols` using the provided `offsets`.
277:         *   If the deleted protocol was the selected one, potentially select the first remaining one or set `selectedProtocolID = nil`.
278:         *   Recalculate simulation data if selection changed or list is now empty.
279:         *   Call `saveProfile()`.
280:     *   Implement `func selectProtocol(id: UUID)`:
281:         *   Set `selectedProtocolID = id`.
282:         *   Call `recalcSimulation()`.
283:     *   Implement `func recalcSimulation()`:
284:         *   Guard that `selectedProtocolID` is not nil and find the corresponding `protocol` in `profile.protocols`.
285:         *   If found, call `generateSimulationData(for: foundProtocol)` and assign the result to the `@Published var simulationData`.
286:         *   If not found (e.g., protocol was deleted), clear `simulationData = []`.
287:         *   *(Optimization Note: Consider DispatchQueue only if generation proves slow for very long durations/small steps)*.
288:     *   Implement placeholder `func calibrateProtocol(_ protocol: InjectionProtocol)` (logic in Story 6).
289:     *   Implement placeholder `func predictedLevel(on date: Date, for protocol: InjectionProtocol) -> Double` (reuse `calculateLevel`).
290: *   [x] **Implement Helper Function: Injection Dates:**
291:     *   Add this instance method to the `InjectionProtocol` struct in `ProtocolModel.swift`.
292:     ```swift
293:     // Inside struct InjectionProtocol
294:     func injectionDates(from simulationStartDate: Date, upto endDate: Date) -> [Date] {
295:         var dates: [Date] = []
296:         var current = startDate // Protocol's own start date
297:         var injectionIndex = 0
298: 
299:         // Find the first injection date that is on or after the simulation's start date
300:         while current < simulationStartDate {
301:             // Check for zero/negative frequency to avoid infinite loop
302:             guard frequencyDays > 0 else {
303:                 // If first injection is before sim start, add it if it's the *only* injection
304:                 if injectionIndex == 0 && current <= endDate { dates.append(current) }
305:                 return dates // Only one injection possible
306:             }
307:             injectionIndex += 1
308:             current = Calendar.current.date(byAdding: .day, value: Int(frequencyDays * Double(injectionIndex)), to: startDate)! // More robust date calculation
309:             // Safety Break
310:             if injectionIndex > 10000 { break }
311:         }
312: 
313: 
314:         // Now add dates within the simulation range [simStartDate, endDate]
315:         // Reset index based on where we are starting relative to protocol start
316:         injectionIndex = Int(round(current.timeIntervalSince(startDate) / (frequencyDays * 24 * 3600)))
317: 
318: 
319:         while current <= endDate {
320:             // Only add if it's within the simulation's actual display window start
321:              if current >= simulationStartDate {
322:                  dates.append(current)
323:              }
324: 
325:              // Check for zero/negative frequency
326:              guard frequencyDays > 0 else { break } // Should only add the first one if freq <= 0
327: 
328:             injectionIndex += 1
329:             // Use calendar calculation for adding days to avoid potential DST issues if frequency isn't integer days
330:             // However, since frequency is Double, TimeInterval is more direct. Stick to TimeInterval for consistency with PK math.
331:             current = startDate.addingTimeInterval(Double(injectionIndex) * frequencyDays * 24 * 3600)
332:              // Safety Break
333:              if injectionIndex > 10000 { break }
334:         }
335:         return dates
336:     }
337:     ```
338:     *   *Correction:* The chart needs dates relative to the simulation window, not just the protocol start. The `injectionDates` function needs the simulation's start/end. Update signature and logic.
339: *   [x] **Implement Helper Function: Formatting Value:**
340:     *   Add a helper function, maybe in `AppDataStore` or a utility file, to format numbers.
341:     ```swift
342:     func formatValue(_ value: Double, unit: String) -> String {
343:         let formatter = NumberFormatter()
344:         formatter.numberStyle = .decimal
345:         if unit == "nmol/L" {
346:             formatter.maximumFractionDigits = 1
347:         } else { // ng/dL typically whole numbers
348:             formatter.maximumFractionDigits = 0
349:         }
350:         formatter.minimumFractionDigits = formatter.maximumFractionDigits // Ensure consistency
351:         return formatter.string(from: NSNumber(value: value)) ?? "\(value)"
352:     }
353: 
354:     // Add unit conversion helper if needed later, for now assume values are stored correctly
355:     // let NGDL_PER_NMOL = 28.85
356:     ```
357: 
358: ---
359: 
360: ### Story 4: UI – Protocol List & Navigation
361: 
362: *   [x] **Implement ContentView:**
363:     *   Create `ContentView.swift` in the `Views` group.
364:     *   Use `NavigationStack`.
365:     *   Embed `ProtocolListView`.
366:     *   Inject `AppDataStore` using `@EnvironmentObject`.
367:     ```swift
368:     import SwiftUI
369: 
370:     struct ContentView: View {
371:         @EnvironmentObject var dataStore: AppDataStore
372: 
373:         var body: some View {
374:             NavigationStack {
375:                 ProtocolListView()
376:             }
377:         }
378:     }
379:     ```
380: *   [x] **Implement ProtocolListView:**
381:     *   Create `ProtocolListView.swift` in the `Views` group.
382:     *   Use `@EnvironmentObject var dataStore: AppDataStore`.
383:     *   Use a `List` to display `dataStore.profile.protocols`.
384:     *   Inside the `List`, use `ForEach` over the protocols.
385:     *   Each row should be a `NavigationLink` pointing to `ProtocolDetailView(protocol: proto)`.
386:     *   The `NavigationLink` label should display the protocol `name` (e.g., `.headline`) and a summary (`dose`, `ester`, `frequency` - e.g., `.subheadline`, `.secondary`).
387:     *   Add `.navigationTitle("Protocols")`.
388:     *   Handle the case where `dataStore.profile.protocols` is empty (display a message like "No protocols yet. Tap + to add one.").
389: *   [x] **Implement List Delete Functionality:**
390:     *   Add the `.onDelete(perform: deleteItems)` modifier to the `ForEach` inside the `List`.
391:     *   Implement the `private func deleteItems(at offsets: IndexSet)` method in `ProtocolListView`.
392:     *   This method should call the corresponding removal function in `dataStore` (e.g., `dataStore.removeProtocol(at: offsets)`).
393: *   [x] **Implement Toolbar Actions:**
394:     *   Add a `.toolbar` modifier to the `List` or containing `VStack`.
395:     *   Add a `ToolbarItem(placement: .primaryAction)` with a `Button` containing a `Label("Add Protocol", systemImage: "plus")`.
396:     *   The button's action should set `dataStore.protocolToEdit = nil` and `dataStore.isPresentingProtocolForm = true`.
397:     *   Add a `ToolbarItem(placement: .navigationBarLeading)` with a `NavigationLink` to `ProfileView()` using a `Label("Profile", systemImage: "person.circle")`.
398: *   [x] **Implement Sheet Presentation for Form:**
399:     *   Add the `.sheet(isPresented: $dataStore.isPresentingProtocolForm)` modifier.
400:     *   The sheet's content should be `ProtocolFormView(protocolToEdit: dataStore.protocolToEdit)`. ( `ProtocolFormView` is defined later).
401:     *   Pass the `environmentObject` to the sheet content: `.environmentObject(dataStore)`.
402: *   [x] **Implement ProfileView:**
403:     *   Create `ProfileView.swift` in the `Views` group.
404:     *   Use `@EnvironmentObject var dataStore: AppDataStore`.
405:     *   Use a `Form` for the layout.
406:     *   Add a `Section("User")` with a `TextField("Name", text: $dataStore.profile.name)`.
407:     *   Add a `Section("Settings")` with a `Picker("Preferred Unit", selection: $dataStore.profile.unit)` containing options "ng/dL" and "nmol/L". Use `Text` views for the options.
408:     *   Add a `Section("Calibration")` displaying the current `dataStore.profile.calibrationFactor` (read-only for now, or add a Reset button).
409:         ```swift
410:         Text("Model Calibration Factor: \(dataStore.profile.calibrationFactor, specifier: "%.2f")")
411:         Button("Reset Calibration to 1.0") {
412:             dataStore.profile.calibrationFactor = 1.0
413:             dataStore.recalcSimulation() // Recalculate if factor changed
414:              dataStore.saveProfile() // Save change
415:         }
416:         ```
417:     *   Use `.onChange` or `.onDisappear` to trigger `dataStore.saveProfile()` when relevant profile properties change. Add `.navigationTitle("Profile Settings")`.
418:     *   *Note on Binding:* To bind directly to `dataStore.profile.name` etc., ensure `AppDataStore` publishes changes correctly when sub-properties of `profile` are modified. Wrapping setters in `objectWillChange.send()` might be needed if direct binding doesn't trigger saves, or trigger save `onDisappear`. A simple approach is adding explicit save calls.
419: 
420: ---
421: 
422: ### Story 5: UI – Protocol Detail & Simulation Chart
423: 
424: *   [x] **Implement ProtocolDetailView Structure:**
425:     *   Create `ProtocolDetailView.swift` in the `Views` group.
426:     *   Add `@EnvironmentObject var dataStore: AppDataStore`.
427:     *   Add `let injectionProtocol: InjectionProtocol` property (passed via `NavigationLink`).
428:     *   Use a `ScrollView` containing a `VStack(alignment: .leading, spacing: 16)`.
429:     *   Add `Text` views to display the protocol summary (Dose, Ester, Frequency).
430:     *   Add a placeholder where the chart will go.
431:     *   Use `.padding()` on the `VStack`.
432:     *   Set `.navigationTitle(injectionProtocol.name)`.
433:     *   Add `.navigationBarTitleDisplayMode(.inline)` if preferred.
434: *   [x] **Implement Detail View Data Loading:**
435:     *   Add an `.onAppear` modifier to the main view inside `ProtocolDetailView`.
436:     *   Inside `.onAppear`, call `dataStore.selectProtocol(id: injectionProtocol.id)`. This ensures the `simulationData` in the store corresponds to *this* protocol when the view appears.
437: *   [x] **Implement Last Bloodwork Display:**
438:     *   Inside the `VStack`, add logic to display info about the latest blood sample:
439:     *   Find the latest sample: `let latestSample = injectionProtocol.bloodSamples.max(by: { $0.date < $1.date })`.
440:     *   If `latestSample` exists:
441:         *   Calculate the model's prediction for that date: `let modelPrediction = dataStore.calculateLevel(at: latestSample.date, for: injectionProtocol, using: dataStore.profile.calibrationFactor)`
442:         *   Display `Text` showing the sample date, measured value (`formatValue`), and the model prediction (`formatValue`) using the profile's preferred unit (`dataStore.profile.unit`). Format the date clearly.
443: *   [x] **Implement Detail View Action Buttons:**
444:     *   Add an `HStack` below the chart area.
445:     *   Add a `Button` with `Label("Add Bloodwork", systemImage: "drop.fill")`.
446:         *   Action: Set `@State private var showingAddBloodSheet = false` to `true`.
447:     *   Add a `Button` with `Label("Recalibrate Model", systemImage: "slider.horizontal.3")`.
448:         *   Action: Call `dataStore.calibrateProtocol(injectionProtocol)` (implement logic in Story 6). Show confirmation alert: `@State private var showingCalibrateConfirm = false`. Set this state bool to true in the button action.
449:         *   Disable this button if `injectionProtocol.bloodSamples.isEmpty`. Use `.disabled(injectionProtocol.bloodSamples.isEmpty)`.
450: *   [x] **Implement Detail View Toolbar/Sheet:**
451:     *   Add a `.toolbar` modifier.
452:     *   Add `ToolbarItem(placement: .primaryAction)` with a `Button("Edit")`.
453:         *   Action: Set `dataStore.protocolToEdit = injectionProtocol` and `dataStore.isPresentingProtocolForm = true`.
454:     *   Add the `.sheet(isPresented: $showingAddBloodSheet)` modifier.
455:         *   Content: `AddBloodworkView(injectionProtocol: injectionProtocol)`. Pass environment object. (`AddBloodworkView` defined in Story 6).
456:     *   Add the `.alert("Calibration Updated", isPresented: $showingCalibrateConfirm)` modifier with a dismiss Button("OK").
457: *   [x] **Implement TestosteroneChart View:**
458:     *   Create `TestosteroneChart.swift` in the `Views` group (or embed code directly in `ProtocolDetailView`).
459:     *   Add `@EnvironmentObject var dataStore: AppDataStore`.
460:     *   Add `let protocol: InjectionProtocol`.
461:     *   Import `Charts`.
462:     *   The `body` should return a `Chart { ... }`.
463:     *   Set a frame, e.g., `.frame(height: 300)`.
464: *   [x] **Implement Chart: Simulation Curve:**
465:     *   Inside `Chart`, add `ForEach(dataStore.simulationData) { point in ... }`. (Ensure `DataPoint` is `Identifiable`).
466:     *   Inside the `ForEach`, add `LineMark(x: .value("Date", point.time), y: .value("Level", point.level))`. Style with `.foregroundStyle(.blue)`.
467:     *   Inside the `ForEach`, also add `AreaMark(x: .value("Date", point.time), y: .value("Level", point.level))`. Style with `.foregroundStyle(LinearGradient(...))` using blue opacity gradient from top (e.g., 0.3) to bottom (0.0).
468: *   [x] **Implement Chart: Injection Markers:**
469:     *   Calculate the simulation start/end dates needed for `injectionDates`. Use `dataStore.simulationData.first?.time` and `dataStore.simulationData.last?.time` if available, or calculate based on `protocol.startDate` and `simulationDurationDays`.
470:     *   Add `ForEach(protocol.injectionDates(from: simStartDate, upto: simEndDate), id: \.self) { injDate in ... }`.
471:     *   Inside, add `RuleMark(x: .value("Injection Date", injDate))`.
472:     *   Style it: `.lineStyle(StrokeStyle(lineWidth: 1, dash: [2, 4]))`, `.foregroundStyle(.gray)`.
473:     *   Add an annotation: `.annotation(position: .bottom, alignment: .center) { Image(systemName: "syringe").font(.caption).foregroundColor(.gray) }`.
474: *   [x] **Implement Chart: Bloodwork Points:**
475:     *   Add `ForEach(protocol.bloodSamples) { sample in ... }`.
476:     *   Inside, add `PointMark(x: .value("Sample Date", sample.date), y: .value("Sample Level", sample.value))`.
477:     *   Style it: `.foregroundStyle(.red)`.
478:     *   Add annotation: `.annotation(position: .overlay, alignment: .top) { Text(formatValue(sample.value, unit: sample.unit)).font(.caption).foregroundColor(.red).padding(.bottom, 8) }`. Adjust position/padding as needed.
479:     *   *(Optional: Add `.symbol(by: .value("Data Type", "Bloodwork"))` if a legend distinguishing points is desired).*
480: *   [x] **Implement Chart Axes Customization:**
481:     *   Add `.chartXAxis { AxisMarks(values: .automatic(desiredCount: 8)) { AxisGridLine() AxisValueLabel(format: .dateTime.month().day(), centered: true) } }`. Adjust desiredCount and format as needed.
482:     *   Add `.chartYAxis { AxisMarks { AxisGridLine() AxisValueLabel() } }`.
483:     *   Add `.chartYAxisLabel("Level (\(dataStore.profile.unit))")`.
484:     *   Add `.chartXAxisLabel("Date")`.
485:     *   *(Optional: Hide legend if automatically generated and not needed: `.chartLegend(.hidden)`)*.
486: 
487: ---
488: 
489: ### Story 6: UI – Add Bloodwork and Calibration
490: 
491: *   [x] **Implement AddBloodworkView Structure:**
492:     *   Create `AddBloodworkView.swift` in the `Views` group.
493:     *   Add `@EnvironmentObject var dataStore: AppDataStore`.
494:     *   Add `@Environment(\.dismiss) var dismiss`.
495:     *   Add `let injectionProtocol: InjectionProtocol`.
496:     *   Add `@State private var date: Date = Date()`.
497:     *   Add `@State private var valueText: String = ""`.
498:     *   Add `@State private var selectedUnit: String = "ng/dL"`. // Default or initialize from profile.unit
499:     *   Use a `NavigationView` (to get a toolbar in the sheet). Inside, use a `Form`. Set a `.navigationTitle("Add Blood Test Result")`.
500: *   [x] **Implement AddBloodworkView Fields:**
501:     *   Inside the `Form`, add a `DatePicker("Date", selection: $date, in: injectionProtocol.startDate..., displayedComponents: [.date, .hourAndMinute])`. Limit the range from protocol start date onwards.
502:     *   Add a `TextField("Testosterone Level", text: $valueText)`. Use `.keyboardType(.decimalPad)`.
503:     *   Add a `Picker("Unit", selection: $selectedUnit)` with `Text("ng/dL").tag("ng/dL")` and `Text("nmol/L").tag("nmol/L")`.
504: *   [x] **Implement AddBloodworkView Save/Cancel Toolbar:**
505:     *   Add a `.toolbar` to the `NavigationView`.
506:     *   Add `ToolbarItem(placement: .navigationBarLeading)` with a `Button("Cancel") { dismiss() }`.
507:     *   Add `ToolbarItem(placement: .navigationBarTrailing)` with a `Button("Save") { saveBloodwork() }`. Disable the Save button if `valueText` is empty or not a valid number: `.disabled(Double(valueText) == nil)`.
508: *   [x] **Implement AddBloodworkView Save Logic:**
509:     *   Create `private func saveBloodwork()`.
510:     *   Inside the function:
511:         1.  Guard that `valueText` can be converted to a `Double`, else return. `guard let value = Double(valueText) else { return }`.
512:         2.  Create a `newSample = BloodSample(date: date, value: value, unit: selectedUnit)`.
513:         3.  Find the index of the current `injectionProtocol` in `dataStore.profile.protocols`.
514:         4.  If found, append `newSample` to `dataStore.profile.protocols[index].bloodSamples`.
515:         5.  Call `dataStore.saveProfile()`.
516:         6.  Call `dismiss()`.
517: *   [x] **Implement Calibration Logic Function:**
518:     *   Implement the `func calibrateProtocol(_ protocolToCalibrate: InjectionProtocol)` method in `AppDataStore`.
519:     *   Inside the function:
520:         1.  Find the protocol in the `profile.protocols` array using `protocolToCalibrate.id`. Ensure it exists.
521:         2.  Get the latest blood sample: `guard let latestSample = protocolToCalibrate.bloodSamples.max(by: { $0.date < $1.date }) else { return }` (or handle error/message).
522:         3.  Calculate the model's prediction *at the sample date*, using the *current* calibration factor: `let modelPrediction = calculateLevel(at: latestSample.date, for: protocolToCalibrate, using: profile.calibrationFactor)`.
523:         4.  Guard against division by zero or near-zero: `guard modelPrediction > 0.01 else { print("Model prediction too low, cannot calibrate."); return }`.
524:         5.  Calculate the required factor *relative to the current one*: `let adjustmentRatio = latestSample.value / modelPrediction`.
525:         6.  Update the profile's factor: `profile.calibrationFactor *= adjustmentRatio`.
526:         7.  Call `recalcSimulation()` to update the chart data with the new factor.
527:         8.  Call `saveProfile()` to persist the new factor.
528: *   [x] **Connect Calibration UI:**
529:     *   Verify the "Recalibrate Model" button in `ProtocolDetailView` correctly calls `dataStore.calibrateProtocol(injectionProtocol)` and sets the state variable to show the confirmation alert.
530: 
531: ---
532: 
533: ### Story 7: Polish and Testing
534: 
535: *   [ ] **UI Polish: Appearance:**
536:     *   Test the app in both **Light Mode** and **Dark Mode**. Ensure text is legible and colors (especially chart colors) look good. Adjust opacities or use adaptive colors if needed.
537:     *   Check font sizes and text wrapping. Ensure UI elements resize reasonably on different screen sizes (e.g., iPhone vs iPad if supported).
538:     *   Verify padding and spacing provide a clean layout.
539: *   [ ] **UI Polish: App Icon & Launch Screen:**
540:     *   *(Optional)* Add a custom AppIcon asset set in `Resources`.
541:     *   *(Optional)* Configure a basic Launch Screen (e.g., using `Info.plist` settings or a Launch Screen storyboard - though SwiftUI prefers quick launch).
542: *   [ ] **UI Polish: Optional Animation:**
543:     *   *(Optional)* If Lottie was included, integrate a simple `LottieView` animation (e.g., a checkmark animation shown briefly after saving or calibration).
544: *   [ ] **Accessibility:**
545:     *   *(Basic Pass)* Ensure standard controls (Buttons, TextFields, Pickers) have default accessibility support. Add `.accessibilityLabel` or `.accessibilityHint` to custom controls or complex elements if time permits (especially chart elements).
546: *   [ ] **Testing: Simulation Accuracy:**
547:     *   Manually run simulations for known protocols (e.g., 100mg Cypionate weekly). Check if the plotted curve visually matches expected pharmacokinetics (e.g., reaches steady state, trough levels relative to peak look reasonable based on half-life). Print key values (peak, trough after X weeks) to console if needed for verification.
548:     *   Test with different esters (Propionate, Enanthate, Undecanoate) to ensure their different half-lives produce visibly different curve shapes.
549: *   [ ] **Testing: Calibration:**
550:     *   Add a blood sample manually. Note the model's prediction at that point.
551:     *   Press "Recalibrate Model".
552:     *   Verify the chart curve shifts and now passes through (or very close to) the blood sample point used for calibration.
553:     *   Verify the `calibrationFactor` stored in `UserProfile` has changed.
554: *   [ ] **Testing: Bug Fixes & Edge Cases:**
555:     *   Test deleting the last protocol. Does the UI update gracefully?
556:     *   Test adding the first protocol.
557:     *   Test editing a protocol (dose, frequency, ester). Does the chart update correctly when returning to the detail view?
558:     *   Attempt to add bloodwork with a date *before* the protocol start date (should be prevented by the `DatePicker` range).
559:     *   Attempt to save bloodwork with non-numeric input (Save button should be disabled).
560:     *   Test calibration with only one sample. Test recalibrating with a second, different sample.
561: *   [ ] **Documentation & Preparation:**
562:     *   Create a basic `README.md` file in the project root explaining the app's purpose and how to build/run it.
563:     *   Add comments to complex code sections (especially `calculateLevel` and `calibrateProtocol`).
564:     *   Add a `LICENSE` file (e.g., MIT).
565: *   [ ] **Multi-Platform Testing (If Applicable):**
566:     *   If macOS target was enabled, run the app on macOS. Check for any layout issues or platform-specific behaviors that need adjustment (e.g., toolbar items, sheet presentation).
567: 
568: ---
569: 
570: This checklist should provide a clear, sequential path for the code assistant to implement the TestoSim application.

================
File: guide2.md
================
  1: ## Story 8 — Compound Library & Blends
  2: 
  3: *Data and utilities for single esters **and** multi-ester vials.*
  4: 
  5: * [x] **Create `Compound.swift`** data model (see code block).
  6: * [x] **Create `VialBlend.swift`** to describe commercial mixtures (each `Component` maps to a `Compound`).
  7: * [x] **Populate `CompoundLibrary.swift`** with the literature half-lives below:
  8: 
  9:   * [x] Testosterone propionate 0.8 d ([Wikipedia][1])
 10:   * [x] Testosterone phenylpropionate 2.5 d ([Iron Daddy][2])
 11:   * [x] Testosterone isocaproate 3.1 d ([Cayman Chemical][3])
 12:   * [x] Testosterone decanoate 7-14 d (use 10 d midpoint) ([BloomTechz][4])
 13:   * [x] Injectable testosterone undecanoate 18-24 d ([PubMed][5], [Wikipedia][6])
 14:   * [x] Oral testosterone undecanoate t½ 1.6 h, F = 0.07 ([Wikipedia][6])
 15:   * [x] Nandrolone decanoate 6-12 d ([Wikipedia][7])
 16:   * [x] Boldenone undecylenate ≈123 h ([ScienceDirect][8])
 17:   * [x] Trenbolone acetate 1-2 d ([ScienceDirect][9])
 18:   * [x] Trenbolone enanthate 11 d / hexahydrobenzylcarbonate 8 d ([Wikipedia][10])
 19:   * [x] Stanozolol IM suspension 24 h ([Wikipedia][11])
 20:   * [x] Drostanolone propionate 2 d ([Wikipedia][12])
 21:   * [x] Drostanolone enanthate ≈5 d ([Wikipedia][12])
 22:   * [x] Metenolone enanthate 10.5 d ([Wikipedia][13])
 23:   * [x] Trestolone (MENT) acetate t½ 40 min IV ≈ 2 h SC ([PubMed][14])
 24:   * [x] 1-Testosterone (DHB) cypionate ≈8 d (class analogue) ([Wikipedia][15])
 25: * [x] **Define `VialBlend` constants** for: Sustanon 250/350/400, Winstrol Susp 50, Masteron P 100 & E 200, Primobolan E 100, Tren Susp 50, Tren A 100, Tren E 200, Tren Hex 76, Tren Mix 150, Cut-Stack 150 & 250, MENT Ac 50, DHB Cyp 100 (per-mL mg in guide's table).
 26: * [x] **Library helpers**: `blends(containing:)`, `class(is:)`, `route(_:)`, and half-life range filters.
 27: 
 28: ```swift
 29: struct Compound: Identifiable, Codable, Hashable {
 30:     enum Class: String, Codable { case testosterone, nandrolone, trenbolone,
 31:                                    boldenone, drostanolone, stanozolol, metenolone,
 32:                                    trestolone, dhb }
 33:     enum Route: String, Codable { case intramuscular, subcutaneous, oral, transdermal }
 34:     let id: UUID
 35:     var commonName: String
 36:     var classType: Class
 37:     var ester: String?          // nil for suspensions
 38:     var halfLifeDays: Double
 39:     var defaultBioavailability: [Route: Double]
 40:     var defaultAbsorptionRateKa: [Route: Double] // d-¹
 41: }
 42: ```
 43: 
 44: ---
 45: 
 46: ## Story 9 — Refined PK Engine
 47: 
 48: *Accurate curves for any route, any blend.*
 49: 
 50: * [x] **Implement `PKModel.concentration`**
 51: 
 52:   $$
 53:   C(t)=\frac{F\,D\,k_a}{V_d\,(k_a-k_e)}\bigl(e^{-k_e t}-e^{-k_a t}\bigr)
 54:   $$
 55: 
 56:   where $k_e=\ln2/t_{1/2}$.\* Units = days\* ([UF College of Pharmacy][16])
 57: 
 58: * [x] **Optional two-compartment flag**; derive α, β from $k_{12}=0.3$, $k_{21}=0.15$ d⁻¹ ([UF College of Pharmacy][16])
 59: 
 60: * [x] **Allometric scaling**:
 61:   $V_{d,\text{user}} = V_{d,70}(WT/70)^{1.0}$;
 62:   $CL_{\text{user}} = CL_{70}(WT/70)^{0.75}$ ([PubMed][17])
 63: 
 64: * [x] **Route parameters** (defaults in `CompoundLibrary`):
 65: 
 66:   | Ester               | k<sub>a</sub> (d⁻¹ IM) | Oral F | Notes                               |
 67:   | ------------------- | ---------------------- | ------ | ----------------------------------- |
 68:   | Propionate          | 0.70                   | —      | inj q2-3 d advised ([Wikipedia][1]) |
 69:   | Phenylpropionate    | 0.50                   | —      | —                                   |
 70:   | Isocaproate         | 0.35                   | —      | —                                   |
 71:   | Decanoate           | 0.18                   | —      | —                                   |
 72:   | Hex-carb            | 0.20                   | —      | —                                   |
 73:   | Acetate (Tren/Test) | 1.00                   | —      | very fast                           |
 74:   | Stanozolol susp     | 1.50                   | —      | 24 h t½ ([Wikipedia][11])           |
 75:   | Oral TU             | —                      | 0.07   | t½ 1.6 h ([Wikipedia][6])           |
 76:   | MENT Ac             | 2.00                   | —      | 40 min IV t½ ([PubMed][14])         |
 77: 
 78: * [x] **Blend handling**: loop through each `Component` and sum concentrations.
 79: 
 80: * [x] **Bayesian calibration stub** – accept `[TimeStamp:LabT]` to refine $k_e,k_a$.
 81: 
 82: ---
 83: 
 84: ## Story 10 — User Profile 2.0 & Persistence
 85: 
 86: *Personalisation + seamless cloud backup.*
 87: 
 88: * [x] Extend `UserProfile` with DOB, height cm, weight kg, biologicalSex, `usesICloudSync`; compute `bodySurfaceArea` (DuBois).
 89: * [ ] Migrate storage to **Core Data + CloudKit** with `NSPersistentCloudKitContainer` ([Apple Developer][18])
 90: * [ ] Write one-time JSON-to-CoreData migrator flag `UserDefaults.migrated = true`.
 91: 
 92: ---
 93: 
 94: ## Story 11 — Notifications & Adherence
 95: 
 96: *Keep users on-schedule.*
 97: 
 98: * [ ] Request permission via `UNUserNotificationCenter.requestAuthorization` ([Apple Developer][19])
 99: * [ ] After each protocol edit, schedule next-dose alert with `UNCalendarNotificationTrigger`.
100: * [ ] Add settings: lead-time (1 h / 6 h / 12 h) and sound toggle.
101: 
102: ---
103: 
104: ## Story 12 — Cycle Builder
105: 
106: *Visual timeline for multi-compound plans.*
107: 
108: * [ ] `Cycle` model (name, startDate, totalWeeks, stages:\[CycleStage]).
109: * [ ] SwiftUI `CyclePlannerView`: horizontal weeks, drag-and-drop `VialBlend` cards; render Gantt bars with **Swift Charts** scroll-zoom & selection APIs ([Apple Developer][20])
110: * [ ] "Simulate Cycle" merges stages to temp protocols → feeds PK engine.
111: 
112: ---
113: 
114: ## Story 13 — AI Insights
115: 
116: *Contextual coaching.*
117: 
118: * [ ] `InsightsGenerator` – send `{profile, simulation}` to LLM; receive JSON {peaks, troughs, tips}.
119: * [ ] Add helper `BlendExplainer` for plain-English breakdown of multi-ester vials (e.g. "Sustanon 400 = 4 esters; expect early spike then 3-week tail"). 
120: * [ ] **Add `InsightsGenerator` service** – pass latest simulation & profile; receive JSON with:
121: 
122:   * Predicted peaks/troughs.
123:   * Adherence tips (e.g., "consider splitting weekly 200 mg TE into 2×100 mg").
124: * [ ] **Prototype with `openAI`** model O4 (research model and api)
125: 
126: 
127: 
128: ## Story 13 – AI Insights
129: 
130: *Optional on-device or server LLM summaries.*
131: 
132: * [ ] **Add `InsightsGenerator` service** – pass latest simulation & profile; receive JSON with:
133: 
134:   * Predicted peaks/troughs.
135:   * Adherence tips (e.g., "consider splitting weekly 200 mg TE into 2×100 mg").
136: * [ ] **Prototype with `openAI` or Core ML-powered model (if offline required).**
137: 
138: ---
139: 
140: ## Story 14 — UI/UX Polish & Animations
141: 
142: *Delightful & accessible.*
143: 
144: * [ ] Follow **Apple HIG "Charting Data"** for uncluttered axes & call-outs ([Apple Developer][21])
145: * [ ] Dashboard card shows *current level* + *days until next dose*; layout guided by NN/g pre-attentive dashboard rules ([Nielsen Norman Group][22])
146: * [ ] Add `.animation(.easeInOut, value:data)` to curve reveal.
147: * [ ] Integrate **Lottie** via SPM `airbnb/lottie-spm` 4.5 + ([GitHub][23])
148: * [ ] Provide haptics (`UIImpactFeedbackGenerator`) and system sounds on log-dose success.
149: * [ ] Define semantic color assets for light/dark compliance.
150: * [ ] **Add `InsightsGenerator` service** – pass latest simulation & profile; receive JSON with:
151: 
152:   * Predicted peaks/troughs.
153:   * Adherence tips (e.g., "consider splitting weekly 200 mg TE into 2×100 mg").
154: * [ ] **Prototype with `openAI` model O4.**
155: ---
156: 
157: 
158: ## Story 15 — Testing & Validation
159: 
160: | Test     | Target                                                                                                             | Pass criteria            |
161: | -------- | ------------------------------------------------------------------------------------------------------------------ | ------------------------ |
162: | **Unit** | 250 mg Test E single IM → C<sub>max</sub> ≈ 1540 ng/dL @ 72 h; 50 % peak by day 9 ([World Anti Doping Agency][24]) | Δ ≤ 10 %                 |
163: |          | 100 mg Tren A Q2D × 14 d steady-state \~6× baseline ([Wikipedia][10])                                              | Δ ≤ 10 %                 |
164: | **UI**   | Notification permission flow, drag-drop in cycle builder                                                           | No crash, state persists |
165: | **Perf** | Simulate 5-compound 20-week plan on iPhone 12                                                                      | < 50 ms average          |
166: 
167: 
168: 
169: ## Story 14 – UI/UX Polish & Animations
170: 
171: *Delightful, accessible, and on-brand.*
172: 
173: * [ ] **Adopt Swift Charts 2-D interactions** (scroll-zoom, selection marks).&#x20;
174: * [ ] **Animate curve reveal** – `.animation(.easeInOut(duration:1.2), value:dataStore.simulationData)`.
175: * [ ] **Add Lottie onboarding & success animations** (e.g., injection logged).
176: 
177:   * Import via SPM `airbnb/lottie-ios` ([github.com][1]).
178: * [ ] **Haptics & sounds** when user records an injection.
179: * [ ] **Dark-mode friendly color palette** using semantic `Color` assets.
180: 
181: 
182: ---
183: 
184: ## References
185: 
186: 1. Testosterone propionate half-life 0.8 d ([Wikipedia][1])
187: 2. Testosterone PP half-life 2.5 d ([Iron Daddy][2])
188: 3. Testosterone isocaproate info ([Cayman Chemical][3])
189: 4. Testosterone decanoate 7–14 d ([BloomTechz][4])
190: 5. TU depot half-life 18–24 d ([PubMed][5])
191: 6. Oral TU bioavailability 0.07, t½ 1.6 h ([Wikipedia][6])
192: 7. Nandrolone decanoate 6–12 d ([Wikipedia][7])
193: 8. Boldenone undecylenate \~123 h ([ScienceDirect][8])
194: 9. Trenbolone acetate 1-2 d ([ScienceDirect][9])
195: 10. Trenbolone hex/enanthate data ([Wikipedia][10])
196: 11. Stanozolol suspension 24 h ([Wikipedia][11])
197: 12. Drostanolone propionate 2 d; enanthate \~5 d ([Wikipedia][12])
198: 13. Metenolone enanthate 10.5 d ([Wikipedia][13])
199: 14. Trestolone acetate 40 min IV t½ ([PubMed][14])
200: 15. DHB overview (1-Testosterone) ([Wikipedia][15])
201: 16. Allometric scaling study (TE) ([PubMed][17])
202: 17. UF "Useful PK equations" sheet ([UF College of Pharmacy][16])
203: 18. Apple CoreData + CloudKit doc ([Apple Developer][18])
204: 19. Apple Charting-Data HIG ([Apple Developer][21])
205: 20. WWDC23 Swift Charts interactivity ([Apple Developer][20])
206: 21. UNUserNotificationCenter API page ([Apple Developer][19])
207: 22. Lottie-SPM install guide ([GitHub][23])
208: 23. NN/g dashboard pre-attentive article ([Nielsen Norman Group][22])
209: 24. WADA blood detection of testosterone esters ([World Anti Doping Agency][24])
210: 
211: ---
212: 
213: *Everything from models and math to UX, AI, and QA is now in one place—ready for your code assistant to execute.*
214: 
215: [1]: https://en.wikipedia.org/wiki/Testosterone_propionate?utm_source=chatgpt.com "Testosterone propionate - Wikipedia"
216: [2]: https://iron-daddy.to/product-category/injectable-steroids/testosterone-phenylpropionate/?utm_source=chatgpt.com "Testosterone Phenylpropionate Half Life - Iron-Daddy.to"
217: [3]: https://www.caymanchem.com/product/22547/testosterone-isocaproate?srsltid=AfmBOoqMzkbumL-PTe0EBkhjjakJVRLR66OsRIFjNbNDIX5YwYpMLPer&utm_source=chatgpt.com "Testosterone Isocaproate (CAS 15262-86-9) - Cayman Chemical"
218: [4]: https://www.bloomtechz.com/info/what-is-the-half-life-of-testosterone-decanoat-93380289.html?utm_source=chatgpt.com "What Is The Half Life Of Testosterone Decanoate? - BLOOM TECH"
219: [5]: https://pubmed.ncbi.nlm.nih.gov/9876028/?utm_source=chatgpt.com "A pharmacokinetic study of injectable testosterone undecanoate in ..."
220: [6]: https://en.wikipedia.org/wiki/Testosterone_undecanoate?utm_source=chatgpt.com "Testosterone undecanoate - Wikipedia"
221: [7]: https://en.wikipedia.org/wiki/Nandrolone_decanoate?utm_source=chatgpt.com "Nandrolone decanoate - Wikipedia"
222: [8]: https://www.sciencedirect.com/science/article/abs/pii/S1567576921005750?utm_source=chatgpt.com "Boldenone undecylenate disrupts the immune system and induces ..."
223: [9]: https://www.sciencedirect.com/science/article/abs/pii/S002228602030452X?utm_source=chatgpt.com "Structural studies of Trenbolone, Trenbolone Acetate ..."
224: [10]: https://en.wikipedia.org/wiki/Trenbolone?utm_source=chatgpt.com "Trenbolone"
225: [11]: https://en.wikipedia.org/wiki/Stanozolol?utm_source=chatgpt.com "Stanozolol - Wikipedia"
226: [12]: https://en.wikipedia.org/wiki/Drostanolone_propionate?utm_source=chatgpt.com "Drostanolone propionate - Wikipedia"
227: [13]: https://en.wikipedia.org/wiki/Metenolone_enanthate?utm_source=chatgpt.com "Metenolone enanthate - Wikipedia"
228: [14]: https://pubmed.ncbi.nlm.nih.gov/9283946/?utm_source=chatgpt.com "Pharmacokinetics of 7 alpha-methyl-19-nortestosterone in men and ..."
229: [15]: https://en.wikipedia.org/wiki/1-Testosterone?utm_source=chatgpt.com "1-Testosterone - Wikipedia"
230: [16]: https://pharmacy.ufl.edu/files/2013/01/5127-28-equations.pdf?utm_source=chatgpt.com "[PDF] Useful Pharmacokinetic Equations"
231: [17]: https://pubmed.ncbi.nlm.nih.gov/37180212/?utm_source=chatgpt.com "Allometric Scaling of Testosterone Enanthate Pharmacokinetics to ..."
232: [18]: https://developer.apple.com/documentation/coredata/setting-up-core-data-with-cloudkit "Setting Up Core Data with CloudKit | Apple Developer Documentation"
233: [19]: https://developer.apple.com/documentation/usernotifications/unusernotificationcenter/requestauthorization "Failed"
234: [20]: https://developer.apple.com/videos/play/wwdc2023/10037 "Explore pie charts and interactivity in Swift Charts - WWDC23 - Videos - Apple Developer"
235: [21]: https://developer.apple.com/design/human-interface-guidelines/charting-data "Charting data | Apple Developer Documentation"
236: [22]: https://www.nngroup.com/articles/dashboards-preattentive/?utm_source=chatgpt.com "Dashboards: Making Charts and Graphs Easier to Understand - NN/g"
237: [23]: https://github.com/airbnb/lottie-spm?utm_source=chatgpt.com "airbnb/lottie-spm: Swift Package Manager support for Lottie ... - GitHub"
238: [24]: https://www.wada-ama.org/en/resources/scientific-research/detection-testosterone-esters-blood-sample?utm_source=chatgpt.com "Detection of testosterone esters in blood sample - WADA"
239: 
240: 
241: [1]: https://github.com/airbnb/lottie-ios "airbnb/lottie-ios: An iOS library to natively render After Effects vector ..."

================
File: TestoSim/ViewModels/AppDataStore.swift
================
  1: import Foundation
  2: import SwiftUI
  3: @MainActor
  4: class AppDataStore: ObservableObject {
  5:     @Published var profile: UserProfile
  6:     @Published var simulationData: [DataPoint] = []
  7:     @Published var selectedProtocolID: UUID?
  8:     @Published var isPresentingProtocolForm = false
  9:     @Published var protocolToEdit: InjectionProtocol?
 10:     @Published var compoundLibrary = CompoundLibrary()
 11:     // Add PKModel instance
 12:     private let pkModel = PKModel(useTwoCompartmentModel: false)
 13:     let simulationDurationDays: Double = 90.0
 14:     var simulationEndDate: Date {
 15:         guard let selectedProtocolID = selectedProtocolID,
 16:               let selectedProtocol = profile.protocols.first(where: { $0.id == selectedProtocolID }) else {
 17:             return Date().addingTimeInterval(simulationDurationDays * 24 * 3600)
 18:         }
 19:         return selectedProtocol.startDate.addingTimeInterval(simulationDurationDays * 24 * 3600)
 20:     }
 21:     init() {
 22:         // Try to load profile from UserDefaults
 23:         if let savedData = UserDefaults.standard.data(forKey: "userProfileData"),
 24:            let decodedProfile = try? JSONDecoder().decode(UserProfile.self, from: savedData) {
 25:             self.profile = decodedProfile
 26:         } else {
 27:             // Create default profile with a sample protocol
 28:             self.profile = UserProfile()
 29:             let defaultProtocol = InjectionProtocol(
 30:                 name: "Default TRT",
 31:                 ester: .cypionate,
 32:                 doseMg: 100.0,
 33:                 frequencyDays: 7.0,
 34:                 startDate: Date()
 35:             )
 36:             self.profile.protocols.append(defaultProtocol)
 37:         }
 38:         // Set initial selected protocol
 39:         if !profile.protocols.isEmpty {
 40:             selectedProtocolID = profile.protocols[0].id
 41:         }
 42:         // Generate initial simulation data
 43:         recalcSimulation()
 44:     }
 45:     func saveProfile() {
 46:         if let encodedData = try? JSONEncoder().encode(profile) {
 47:             UserDefaults.standard.set(encodedData, forKey: "userProfileData")
 48:         }
 49:     }
 50:     func addProtocol(_ newProtocol: InjectionProtocol) {
 51:         profile.protocols.append(newProtocol)
 52:         selectedProtocolID = newProtocol.id
 53:         recalcSimulation()
 54:         saveProfile()
 55:     }
 56:     func updateProtocol(_ updatedProtocol: InjectionProtocol) {
 57:         if let index = profile.protocols.firstIndex(where: { $0.id == updatedProtocol.id }) {
 58:             profile.protocols[index] = updatedProtocol
 59:             if updatedProtocol.id == selectedProtocolID {
 60:                 recalcSimulation()
 61:             }
 62:             saveProfile()
 63:         }
 64:     }
 65:     func removeProtocol(at offsets: IndexSet) {
 66:         let deletedIDs = offsets.map { profile.protocols[$0].id }
 67:         profile.protocols.remove(atOffsets: offsets)
 68:         // Check if selected protocol was deleted
 69:         if let selectedID = selectedProtocolID, deletedIDs.contains(selectedID) {
 70:             selectedProtocolID = profile.protocols.first?.id
 71:             recalcSimulation()
 72:         }
 73:         saveProfile()
 74:     }
 75:     func selectProtocol(id: UUID) {
 76:         selectedProtocolID = id
 77:         recalcSimulation()
 78:     }
 79:     func recalcSimulation() {
 80:         guard let selectedProtocolID = selectedProtocolID,
 81:               let selectedProtocol = profile.protocols.first(where: { $0.id == selectedProtocolID }) else {
 82:             simulationData = []
 83:             return
 84:         }
 85:         simulationData = generateSimulationData(for: selectedProtocol)
 86:     }
 87:     func generateSimulationData(for injectionProtocol: InjectionProtocol) -> [DataPoint] {
 88:         let startDate = injectionProtocol.startDate
 89:         let endDate = startDate.addingTimeInterval(simulationDurationDays * 24 * 3600)
 90:         let stepInterval: TimeInterval = 6 * 3600 // 6-hour intervals
 91:         var dataPoints: [DataPoint] = []
 92:         var currentDate = startDate
 93:         while currentDate <= endDate {
 94:             let level = calculateLevel(at: currentDate, for: injectionProtocol, using: profile.calibrationFactor)
 95:             let dataPoint = DataPoint(time: currentDate, level: level)
 96:             dataPoints.append(dataPoint)
 97:             currentDate = currentDate.addingTimeInterval(stepInterval)
 98:         }
 99:         return dataPoints
100:     }
101:     func calculateLevel(at targetDate: Date, for injectionProtocol: InjectionProtocol, using calibrationFactor: Double) -> Double {
102:         // Get compound from library that matches the ester
103:         let compound = compoundFromEster(injectionProtocol.ester)
104:         guard let compound = compound else {
105:             // Fall back to old calculation if compound not found
106:             return calculateLevelLegacy(at: targetDate, for: injectionProtocol, using: calibrationFactor)
107:         }
108:         // Get all injection dates up to the target date
109:         let injectionDates = injectionProtocol.injectionDates(
110:             from: injectionProtocol.startDate.addingTimeInterval(-90 * 24 * 3600), // Include 90 days before to catch buildup
111:             upto: targetDate
112:         )
113:         // Use the new PKModel to calculate concentrations
114:         let compounds = [(compound: compound, dosePerInjectionMg: injectionProtocol.doseMg)]
115:         let concentrations = pkModel.protocolConcentrations(
116:             at: [targetDate],
117:             injectionDates: injectionDates,
118:             compounds: compounds,
119:             route: .intramuscular, // Default to IM for now
120:             weight: profile.weight ?? 70.0, // Use profile weight or default to 70kg
121:             calibrationFactor: calibrationFactor
122:         )
123:         return concentrations.first ?? 0.0
124:     }
125:     // Legacy calculation method for backward compatibility
126:     private func calculateLevelLegacy(at targetDate: Date, for injectionProtocol: InjectionProtocol, using calibrationFactor: Double) -> Double {
127:         let t_days = targetDate.timeIntervalSince(injectionProtocol.startDate) / (24 * 3600) // Time in days since start
128:         guard t_days >= 0 else { return 0.0 }
129:         guard injectionProtocol.ester.halfLifeDays > 0 else { return 0.0 } // Avoid division by zero if halfLife is 0
130:         let k = log(2) / injectionProtocol.ester.halfLifeDays // Natural log
131:         var totalLevel = 0.0
132:         var injIndex = 0
133:         while true {
134:             let injTime_days = Double(injIndex) * injectionProtocol.frequencyDays
135:             // Optimization: If frequency is 0 or negative, only consider the first injection
136:             if injectionProtocol.frequencyDays <= 0 && injIndex > 0 { break }
137:             if injTime_days > t_days { break } // Stop if injection time is after target time
138:             let timeDiff_days = t_days - injTime_days
139:             if timeDiff_days >= 0 { // Ensure we only calculate for times after injection
140:                 let contribution = injectionProtocol.doseMg * exp(-k * timeDiff_days)
141:                 totalLevel += contribution
142:             }
143:             // Check for infinite loop condition if frequency is 0
144:             if injectionProtocol.frequencyDays <= 0 { break }
145:             injIndex += 1
146:             // Safety break if index gets excessively large (e.g., > 10000) though unlikely with date limits
147:             if injIndex > 10000 { break }
148:         }
149:         return totalLevel * calibrationFactor
150:     }
151:     // Helper method to find compound that matches the TestosteroneEster
152:     private func compoundFromEster(_ ester: TestosteroneEster) -> Compound? {
153:         // Map from TestosteroneEster to Compound - looking up by name match
154:         let esterName = ester.name
155:         return compoundLibrary.compounds.first { 
156:             $0.classType == .testosterone && $0.ester?.lowercased() == esterName.lowercased()
157:         }
158:     }
159:     func predictedLevel(on date: Date, for injectionProtocol: InjectionProtocol) -> Double {
160:         return calculateLevel(at: date, for: injectionProtocol, using: profile.calibrationFactor)
161:     }
162:     func calibrateProtocol(_ protocolToCalibrate: InjectionProtocol) {
163:         // Find and calibrate based on the most recent blood sample
164:         guard let latestSample = protocolToCalibrate.bloodSamples.max(by: { $0.date < $1.date }) else {
165:             return
166:         }
167:         let modelPrediction = calculateLevel(at: latestSample.date, for: protocolToCalibrate, using: profile.calibrationFactor)
168:         guard modelPrediction > 0.01 else {
169:             print("Model prediction too low, cannot calibrate.")
170:             return
171:         }
172:         let adjustmentRatio = latestSample.value / modelPrediction
173:         profile.calibrationFactor *= adjustmentRatio
174:         recalcSimulation()
175:         saveProfile()
176:     }
177:     func calibrateProtocolWithBayesian(_ protocolToCalibrate: InjectionProtocol) {
178:         // Only proceed if protocol has blood samples and we can find matching compound
179:         guard !protocolToCalibrate.bloodSamples.isEmpty,
180:               let compound = compoundFromEster(protocolToCalibrate.ester) else {
181:             // Fall back to simple calibration if needed
182:             calibrateProtocol(protocolToCalibrate)
183:             return
184:         }
185:         // Convert blood samples to PKModel.SamplePoint format
186:         let samplePoints = protocolToCalibrate.bloodSamples.map { 
187:             PKModel.SamplePoint(timestamp: $0.date, labValue: $0.value)
188:         }
189:         // Get injection dates for this protocol
190:         let startDate = Calendar.current.date(
191:             byAdding: .day,
192:             value: -90, // Look back 90 days to catch buildup
193:             to: protocolToCalibrate.bloodSamples.map { $0.date }.min() ?? Date()
194:         ) ?? Date()
195:         let endDate = protocolToCalibrate.bloodSamples.map { $0.date }.max() ?? Date()
196:         let injectionDates = protocolToCalibrate.injectionDates(from: startDate, upto: endDate)
197:         // Perform Bayesian calibration
198:         if let calibrationResult = pkModel.bayesianCalibration(
199:             samples: samplePoints,
200:             injectionDates: injectionDates,
201:             compound: compound,
202:             dose: protocolToCalibrate.doseMg,
203:             route: .intramuscular, // Default to IM for now
204:             weight: profile.weight ?? 70.0
205:         ) {
206:             // For now, just use the calibration results to adjust the global calibration factor
207:             // In a more advanced implementation, we could store the adjusted ke and ka per-compound
208:             // or create a custom compound for this user
209:             // Update calibration factor based on average accuracy improvement
210:             let avgLabValue = samplePoints.reduce(0.0) { $0 + $1.labValue } / Double(samplePoints.count)
211:             let oldPredictions = samplePoints.map { point in
212:                 calculateLevel(at: point.timestamp, for: protocolToCalibrate, using: 1.0)
213:             }
214:             let avgOldPrediction = oldPredictions.reduce(0.0, +) / Double(oldPredictions.count)
215:             // Set calibration factor to make average prediction match average lab value
216:             if avgOldPrediction > 0 {
217:                 profile.calibrationFactor = avgLabValue / avgOldPrediction
218:             }
219:             // Print calibration results to console (would show in UI in full implementation)
220:             print("Bayesian Calibration Results:")
221:             print("Original half-life: \(compound.halfLifeDays) days")
222:             print("Calibrated half-life: \(calibrationResult.halfLifeDays) days")
223:             let percentFormatter = NumberFormatter()
224:             percentFormatter.maximumFractionDigits = 1
225:             let halfLifeChangeStr = percentFormatter.string(from: NSNumber(value: calibrationResult.halfLifeChangePercent)) ?? "\(calibrationResult.halfLifeChangePercent)"
226:             print("Half-life change: \(halfLifeChangeStr)%")
227:             let decimalFormatter = NumberFormatter()
228:             decimalFormatter.maximumFractionDigits = 2
229:             let correlationStr = decimalFormatter.string(from: NSNumber(value: calibrationResult.correlation)) ?? "\(calibrationResult.correlation)"
230:             let calFactorStr = decimalFormatter.string(from: NSNumber(value: profile.calibrationFactor)) ?? "\(profile.calibrationFactor)"
231:             print("Fit correlation: \(correlationStr)")
232:             print("Applied calibration factor: \(calFactorStr)")
233:             // Update simulation and save
234:             recalcSimulation()
235:             saveProfile()
236:         } else {
237:             // Fall back to simple calibration if Bayesian method fails
238:             calibrateProtocol(protocolToCalibrate)
239:         }
240:     }
241:     func formatValue(_ value: Double, unit: String) -> String {
242:         let formatter = NumberFormatter()
243:         formatter.numberStyle = .decimal
244:         if unit == "nmol/L" {
245:             formatter.maximumFractionDigits = 1
246:         } else { // ng/dL typically whole numbers
247:             formatter.maximumFractionDigits = 0
248:         }
249:         formatter.minimumFractionDigits = formatter.maximumFractionDigits // Ensure consistency
250:         return formatter.string(from: NSNumber(value: value)) ?? "\(value)"
251:     }
252: }



================================================================
End of Codebase
================================================================
