<repomix>This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where content has been formatted for parsing in xml style, security check has been disabled.<directory_structure>TestoSim/
  Assets.xcassets/
    AccentColor.colorset/
      Contents.json
    AppIcon.appiconset/
      Contents.json
    Contents.json
  Models/
    BloodworkModel.swift
    CDBloodSample+CoreDataClass.swift
    CDCompound+CoreDataClass.swift
    CDCycle+CoreDataClass.swift
    CDCycleStage+CoreDataClass.swift
    CDInjectionProtocol+CoreDataClass.swift
    CDUserProfile+CoreDataClass.swift
    CDVialBlend+CoreDataClass.swift
    CDVialComponent+CoreDataClass.swift
    Compound.swift
    CompoundLibrary.swift
    CoreDataExtensions.swift
    CycleModel.swift
    DataPoint.swift
    PKModel.swift
    ProfileModel.swift
    ProtocolModel.swift
    VialBlend.swift
  TestoSim.xcdatamodeld/
    TestoSim.xcdatamodel/
      contents
  ViewModels/
    AIInsightsGenerator.swift
    AppDataStore.swift
    CoreDataManager.swift
    NotificationManager.swift
    OpenAIService.swift
  Views/
    AddBloodworkView.swift
    AIInsightsView.swift
    CalibrationResultView.swift
    CompoundListView.swift
    CyclePlannerView.swift
    CycleStageFormView.swift
    InjectionHistoryView.swift
    NotificationSettingsView.swift
    ProfileView.swift
    ProtocolDetailView.swift
    ProtocolFormView.swift
    ProtocolListView.swift
    TestosteroneChart.swift
    VialBlendListView.swift
  Config-Sample.plist
  Config-Sample.xcconfig
  ContentView.swift
  TestoSim.entitlements
  TestoSimApp.swift
TestoSim.xcodeproj/
  project.xcworkspace/
    contents.xcworkspacedata
  project.pbxproj
TestoSimTests/
  TestoSimTests.swift
TestoSimUITests/
  TestoSimUITests.swift
  TestoSimUITestsLaunchTests.swift
.gitignore
add_files_to_target.sh
build-test.sh
buildServer.json
close-simulators.sh
copy-config.sh
launch-test.sh
README.md
repomix-output.txt</directory_structure><files>This section contains the contents of the repository&apos;s files.<file path="TestoSim/Assets.xcassets/AccentColor.colorset/Contents.json">{
  &quot;colors&quot; : [
    {
      &quot;idiom&quot; : &quot;universal&quot;
    }
  ],
  &quot;info&quot; : {
    &quot;author&quot; : &quot;xcode&quot;,
    &quot;version&quot; : 1
  }
}</file><file path="TestoSim/Assets.xcassets/AppIcon.appiconset/Contents.json">{
  &quot;images&quot; : [
    {
      &quot;idiom&quot; : &quot;universal&quot;,
      &quot;platform&quot; : &quot;ios&quot;,
      &quot;size&quot; : &quot;1024x1024&quot;
    },
    {
      &quot;appearances&quot; : [
        {
          &quot;appearance&quot; : &quot;luminosity&quot;,
          &quot;value&quot; : &quot;dark&quot;
        }
      ],
      &quot;idiom&quot; : &quot;universal&quot;,
      &quot;platform&quot; : &quot;ios&quot;,
      &quot;size&quot; : &quot;1024x1024&quot;
    },
    {
      &quot;appearances&quot; : [
        {
          &quot;appearance&quot; : &quot;luminosity&quot;,
          &quot;value&quot; : &quot;tinted&quot;
        }
      ],
      &quot;idiom&quot; : &quot;universal&quot;,
      &quot;platform&quot; : &quot;ios&quot;,
      &quot;size&quot; : &quot;1024x1024&quot;
    },
    {
      &quot;idiom&quot; : &quot;mac&quot;,
      &quot;scale&quot; : &quot;1x&quot;,
      &quot;size&quot; : &quot;16x16&quot;
    },
    {
      &quot;idiom&quot; : &quot;mac&quot;,
      &quot;scale&quot; : &quot;2x&quot;,
      &quot;size&quot; : &quot;16x16&quot;
    },
    {
      &quot;idiom&quot; : &quot;mac&quot;,
      &quot;scale&quot; : &quot;1x&quot;,
      &quot;size&quot; : &quot;32x32&quot;
    },
    {
      &quot;idiom&quot; : &quot;mac&quot;,
      &quot;scale&quot; : &quot;2x&quot;,
      &quot;size&quot; : &quot;32x32&quot;
    },
    {
      &quot;idiom&quot; : &quot;mac&quot;,
      &quot;scale&quot; : &quot;1x&quot;,
      &quot;size&quot; : &quot;128x128&quot;
    },
    {
      &quot;idiom&quot; : &quot;mac&quot;,
      &quot;scale&quot; : &quot;2x&quot;,
      &quot;size&quot; : &quot;128x128&quot;
    },
    {
      &quot;idiom&quot; : &quot;mac&quot;,
      &quot;scale&quot; : &quot;1x&quot;,
      &quot;size&quot; : &quot;256x256&quot;
    },
    {
      &quot;idiom&quot; : &quot;mac&quot;,
      &quot;scale&quot; : &quot;2x&quot;,
      &quot;size&quot; : &quot;256x256&quot;
    },
    {
      &quot;idiom&quot; : &quot;mac&quot;,
      &quot;scale&quot; : &quot;1x&quot;,
      &quot;size&quot; : &quot;512x512&quot;
    },
    {
      &quot;idiom&quot; : &quot;mac&quot;,
      &quot;scale&quot; : &quot;2x&quot;,
      &quot;size&quot; : &quot;512x512&quot;
    }
  ],
  &quot;info&quot; : {
    &quot;author&quot; : &quot;xcode&quot;,
    &quot;version&quot; : 1
  }
}</file><file path="TestoSim/Assets.xcassets/Contents.json">{
  &quot;info&quot; : {
    &quot;author&quot; : &quot;xcode&quot;,
    &quot;version&quot; : 1
  }
}</file><file path="TestoSim/Models/BloodworkModel.swift">import Foundation

struct BloodSample: Identifiable, Codable, Hashable {
    let id: UUID
    let date: Date
    let value: Double
    let unit: String
    
    init(id: UUID = UUID(), date: Date, value: Double, unit: String) {
        self.id = id
        self.date = date
        self.value = value
        self.unit = unit
    }
}</file><file path="TestoSim/Models/CDCycle+CoreDataClass.swift">import Foundation
import CoreData

@objc(CDCycle)
public class CDCycle: NSManagedObject {
    
}</file><file path="TestoSim/Models/CDCycleStage+CoreDataClass.swift">import Foundation
import CoreData

@objc(CDCycleStage)
public class CDCycleStage: NSManagedObject {
    
}</file><file path="TestoSim/Models/Compound.swift">import Foundation

struct Compound: Identifiable, Codable, Hashable {
    enum Class: String, Codable, CaseIterable {
        case testosterone, nandrolone, trenbolone,
             boldenone, drostanolone, stanozolol, metenolone,
             trestolone, dhb
        
        var displayName: String {
            switch self {
            case .testosterone: return &quot;Testosterone&quot;
            case .nandrolone: return &quot;Nandrolone&quot;
            case .trenbolone: return &quot;Trenbolone&quot;
            case .boldenone: return &quot;Boldenone&quot;
            case .drostanolone: return &quot;Drostanolone (Masteron)&quot;
            case .stanozolol: return &quot;Stanozolol (Winstrol)&quot;
            case .metenolone: return &quot;Metenolone (Primobolan)&quot;
            case .trestolone: return &quot;Trestolone (MENT)&quot;
            case .dhb: return &quot;1-Testosterone (DHB)&quot;
            }
        }
    }
    
    enum Route: String, Codable, CaseIterable {
        case intramuscular, subcutaneous, oral, transdermal
        
        var displayName: String {
            switch self {
            case .intramuscular: return &quot;Intramuscular (IM)&quot;
            case .subcutaneous: return &quot;Subcutaneous (SubQ)&quot;
            case .oral: return &quot;Oral&quot;
            case .transdermal: return &quot;Transdermal&quot;
            }
        }
    }
    
    let id: UUID
    var commonName: String
    var classType: Class
    var ester: String?          // nil for suspensions
    var halfLifeDays: Double
    var defaultBioavailability: [Route: Double]
    var defaultAbsorptionRateKa: [Route: Double] // d-¹ (per day)
    
    init(id: UUID = UUID(), 
         commonName: String, 
         classType: Class, 
         ester: String? = nil, 
         halfLifeDays: Double, 
         defaultBioavailability: [Route: Double], 
         defaultAbsorptionRateKa: [Route: Double]) {
        self.id = id
        self.commonName = commonName
        self.classType = classType
        self.ester = ester
        self.halfLifeDays = halfLifeDays
        self.defaultBioavailability = defaultBioavailability
        self.defaultAbsorptionRateKa = defaultAbsorptionRateKa
    }
    
    // Returns the full display name with class and ester, e.g. &quot;Testosterone Enanthate&quot;
    var fullDisplayName: String {
        if let ester = ester {
            return &quot;\(classType.displayName) \(ester)&quot;
        } else {
            return &quot;\(classType.displayName) Suspension&quot;
        }
    }
}</file><file path="TestoSim/Models/CompoundLibrary.swift">import Foundation

class CompoundLibrary: ObservableObject {
    @Published private(set) var compounds: [Compound] = []
    @Published private(set) var blends: [VialBlend] = []
    
    init() {
        populateCompounds()
        populateBlends()
    }
    
    // MARK: - Helper Methods
    
    func compound(withID id: UUID) -&gt; Compound? {
        return compounds.first { $0.id == id }
    }
    
    func blend(withID id: UUID) -&gt; VialBlend? {
        return blends.first { $0.id == id }
    }
    
    // MARK: - Filter Methods
    
    func compounds(ofClass classType: Compound.Class) -&gt; [Compound] {
        return compounds.filter { $0.classType == classType }
    }
    
    func compounds(forRoute route: Compound.Route) -&gt; [Compound] {
        return compounds.filter { $0.defaultBioavailability[route] != nil }
    }
    
    func compounds(withEsterName esterName: String) -&gt; [Compound] {
        return compounds.filter { $0.ester == esterName }
    }
    
    func compounds(withHalfLifeBetween min: Double, and max: Double) -&gt; [Compound] {
        return compounds.filter { $0.halfLifeDays &gt;= min &amp;&amp; $0.halfLifeDays &lt;= max }
    }
    
    func blends(containing compoundID: UUID) -&gt; [VialBlend] {
        return blends.filter { blend in
            blend.components.contains { $0.compoundID == compoundID }
        }
    }
    
    // MARK: - Populate Data
    
    private func populateCompounds() {
        // Default values for typical routes
        let defaultIMBioavailability: [Compound.Route: Double] = [.intramuscular: 1.0, .subcutaneous: 0.85]
        let defaultOralBioavailability: [Compound.Route: Double] = [.oral: 0.07] // Low for most oral testosterone
        
        // Testosterone compounds
        let testosteronePropionate = Compound(
            commonName: &quot;Testosterone Propionate&quot;,
            classType: .testosterone,
            ester: &quot;Propionate&quot;,
            halfLifeDays: 0.8, // Wikipedia
            defaultBioavailability: defaultIMBioavailability,
            defaultAbsorptionRateKa: [.intramuscular: 0.70, .subcutaneous: 0.50]
        )
        
        let testosteronePhenylpropionate = Compound(
            commonName: &quot;Testosterone Phenylpropionate&quot;,
            classType: .testosterone,
            ester: &quot;Phenylpropionate&quot;,
            halfLifeDays: 2.5, // Iron Daddy
            defaultBioavailability: defaultIMBioavailability,
            defaultAbsorptionRateKa: [.intramuscular: 0.50, .subcutaneous: 0.35]
        )
        
        let testosteroneIsocaproate = Compound(
            commonName: &quot;Testosterone Isocaproate&quot;,
            classType: .testosterone,
            ester: &quot;Isocaproate&quot;,
            halfLifeDays: 3.1, // Cayman Chemical
            defaultBioavailability: defaultIMBioavailability,
            defaultAbsorptionRateKa: [.intramuscular: 0.35, .subcutaneous: 0.25]
        )
        
        let testosteroneEnanthate = Compound(
            commonName: &quot;Testosterone Enanthate&quot;,
            classType: .testosterone,
            ester: &quot;Enanthate&quot;,
            halfLifeDays: 4.5, // From previous app data
            defaultBioavailability: defaultIMBioavailability,
            defaultAbsorptionRateKa: [.intramuscular: 0.30, .subcutaneous: 0.22]
        )
        
        let testosteroneCypionate = Compound(
            commonName: &quot;Testosterone Cypionate&quot;,
            classType: .testosterone,
            ester: &quot;Cypionate&quot;,
            halfLifeDays: 7.0, // From previous app data
            defaultBioavailability: defaultIMBioavailability,
            defaultAbsorptionRateKa: [.intramuscular: 0.25, .subcutaneous: 0.18]
        )
        
        let testosteroneDecanoate = Compound(
            commonName: &quot;Testosterone Decanoate&quot;,
            classType: .testosterone,
            ester: &quot;Decanoate&quot;,
            halfLifeDays: 10.0, // BloomTechz (7-14 day midpoint)
            defaultBioavailability: defaultIMBioavailability,
            defaultAbsorptionRateKa: [.intramuscular: 0.18, .subcutaneous: 0.14]
        )
        
        let testosteroneUndecanoateInjectable = Compound(
            commonName: &quot;Testosterone Undecanoate (Injectable)&quot;,
            classType: .testosterone,
            ester: &quot;Undecanoate&quot;,
            halfLifeDays: 21.0, // PubMed, Wikipedia (18-24 day midpoint)
            defaultBioavailability: defaultIMBioavailability,
            defaultAbsorptionRateKa: [.intramuscular: 0.15, .subcutaneous: 0.10]
        )
        
        let testosteroneUndecanoateOral = Compound(
            commonName: &quot;Testosterone Undecanoate (Oral)&quot;,
            classType: .testosterone,
            ester: &quot;Undecanoate&quot;,
            halfLifeDays: 0.067, // Wikipedia t½ 1.6h = 0.067d
            defaultBioavailability: defaultOralBioavailability,
            defaultAbsorptionRateKa: [.oral: 6.0] // Fast absorption orally
        )
        
        // Nandrolone
        let nandroloneDecanoate = Compound(
            commonName: &quot;Nandrolone Decanoate&quot;,
            classType: .nandrolone,
            ester: &quot;Decanoate&quot;,
            halfLifeDays: 9.0, // Wikipedia (6-12 day midpoint)
            defaultBioavailability: defaultIMBioavailability,
            defaultAbsorptionRateKa: [.intramuscular: 0.20, .subcutaneous: 0.15]
        )
        
        // Boldenone
        let boldenoneUndecylenate = Compound(
            commonName: &quot;Boldenone Undecylenate&quot;,
            classType: .boldenone,
            ester: &quot;Undecylenate&quot;,
            halfLifeDays: 5.125, // ScienceDirect ~123h = 5.125d
            defaultBioavailability: defaultIMBioavailability,
            defaultAbsorptionRateKa: [.intramuscular: 0.25, .subcutaneous: 0.18]
        )
        
        // Trenbolone
        let trenboloneAcetate = Compound(
            commonName: &quot;Trenbolone Acetate&quot;,
            classType: .trenbolone,
            ester: &quot;Acetate&quot;,
            halfLifeDays: 1.5, // ScienceDirect (1-2 day midpoint)
            defaultBioavailability: defaultIMBioavailability,
            defaultAbsorptionRateKa: [.intramuscular: 1.00, .subcutaneous: 0.70]
        )
        
        let trenboloneEnanthate = Compound(
            commonName: &quot;Trenbolone Enanthate&quot;,
            classType: .trenbolone,
            ester: &quot;Enanthate&quot;,
            halfLifeDays: 11.0, // Wikipedia
            defaultBioavailability: defaultIMBioavailability,
            defaultAbsorptionRateKa: [.intramuscular: 0.18, .subcutaneous: 0.14]
        )
        
        let trenboloneHexahydrobenzylcarbonate = Compound(
            commonName: &quot;Trenbolone Hexahydrobenzylcarbonate&quot;,
            classType: .trenbolone,
            ester: &quot;Hexahydrobenzylcarbonate&quot;,
            halfLifeDays: 8.0, // Wikipedia
            defaultBioavailability: defaultIMBioavailability,
            defaultAbsorptionRateKa: [.intramuscular: 0.20, .subcutaneous: 0.15]
        )
        
        // Stanozolol
        let stanozololSuspension = Compound(
            commonName: &quot;Stanozolol Suspension&quot;,
            classType: .stanozolol,
            ester: nil, // Suspension has no ester
            halfLifeDays: 1.0, // Wikipedia 24h
            defaultBioavailability: defaultIMBioavailability,
            defaultAbsorptionRateKa: [.intramuscular: 1.50, .subcutaneous: 1.00]
        )
        
        // Drostanolone (Masteron)
        let drostanolonePropionate = Compound(
            commonName: &quot;Drostanolone Propionate&quot;,
            classType: .drostanolone,
            ester: &quot;Propionate&quot;,
            halfLifeDays: 2.0, // Wikipedia
            defaultBioavailability: defaultIMBioavailability,
            defaultAbsorptionRateKa: [.intramuscular: 0.70, .subcutaneous: 0.50]
        )
        
        let drostanoloneEnanthate = Compound(
            commonName: &quot;Drostanolone Enanthate&quot;,
            classType: .drostanolone,
            ester: &quot;Enanthate&quot;,
            halfLifeDays: 5.0, // Wikipedia approx
            defaultBioavailability: defaultIMBioavailability,
            defaultAbsorptionRateKa: [.intramuscular: 0.30, .subcutaneous: 0.22]
        )
        
        // Metenolone (Primobolan)
        let metenoloneEnanthate = Compound(
            commonName: &quot;Metenolone Enanthate&quot;,
            classType: .metenolone,
            ester: &quot;Enanthate&quot;,
            halfLifeDays: 10.5, // Wikipedia
            defaultBioavailability: defaultIMBioavailability,
            defaultAbsorptionRateKa: [.intramuscular: 0.18, .subcutaneous: 0.15]
        )
        
        // Trestolone (MENT)
        let trestoloneAcetate = Compound(
            commonName: &quot;Trestolone Acetate&quot;,
            classType: .trestolone,
            ester: &quot;Acetate&quot;,
            halfLifeDays: 0.083, // PubMed 40min IV ~2h SC, conservatively using IV
            defaultBioavailability: defaultIMBioavailability,
            defaultAbsorptionRateKa: [.intramuscular: 2.00, .subcutaneous: 1.50]
        )
        
        // 1-Testosterone (DHB)
        let dhbCypionate = Compound(
            commonName: &quot;1-Testosterone Cypionate&quot;,
            classType: .dhb,
            ester: &quot;Cypionate&quot;,
            halfLifeDays: 8.0, // Wikipedia class analogue
            defaultBioavailability: defaultIMBioavailability,
            defaultAbsorptionRateKa: [.intramuscular: 0.22, .subcutaneous: 0.16]
        )
        
        // Add all compounds to the library
        compounds = [
            testosteronePropionate,
            testosteronePhenylpropionate,
            testosteroneIsocaproate,
            testosteroneEnanthate,
            testosteroneCypionate,
            testosteroneDecanoate,
            testosteroneUndecanoateInjectable,
            testosteroneUndecanoateOral,
            nandroloneDecanoate,
            boldenoneUndecylenate,
            trenboloneAcetate,
            trenboloneEnanthate,
            trenboloneHexahydrobenzylcarbonate,
            stanozololSuspension,
            drostanolonePropionate,
            drostanoloneEnanthate,
            metenoloneEnanthate,
            trestoloneAcetate,
            dhbCypionate
        ]
    }
    
    private func populateBlends() {
        // Helper to find compound ID by common name
        func findCompoundID(byName name: String) -&gt; UUID? {
            return compounds.first { $0.commonName == name }?.id
        }
        
        // Sustanon blends
        if let testP = findCompoundID(byName: &quot;Testosterone Propionate&quot;),
           let testPP = findCompoundID(byName: &quot;Testosterone Phenylpropionate&quot;),
           let testIso = findCompoundID(byName: &quot;Testosterone Isocaproate&quot;),
           let testDec = findCompoundID(byName: &quot;Testosterone Decanoate&quot;) {
            
            // Sustanon 250
            let sustanon250 = VialBlend(
                name: &quot;Sustanon 250&quot;,
                manufacturer: &quot;Organon&quot;,
                description: &quot;Mixed testosterone esters for TRT&quot;,
                components: [
                    VialBlend.Component(compoundID: testP, mgPerML: 30),
                    VialBlend.Component(compoundID: testPP, mgPerML: 60),
                    VialBlend.Component(compoundID: testIso, mgPerML: 60),
                    VialBlend.Component(compoundID: testDec, mgPerML: 100)
                ]
            )
            
            // Sustanon 350
            let sustanon350 = VialBlend(
                name: &quot;Sustanon 350&quot;,
                manufacturer: &quot;Generic&quot;,
                description: &quot;Higher concentration mixed testosterone esters&quot;,
                components: [
                    VialBlend.Component(compoundID: testP, mgPerML: 40),
                    VialBlend.Component(compoundID: testPP, mgPerML: 80),
                    VialBlend.Component(compoundID: testIso, mgPerML: 80),
                    VialBlend.Component(compoundID: testDec, mgPerML: 150)
                ]
            )
            
            // Sustanon 400
            let sustanon400 = VialBlend(
                name: &quot;Sustanon 400&quot;,
                manufacturer: &quot;Generic&quot;,
                description: &quot;Highest concentration mixed testosterone esters&quot;,
                components: [
                    VialBlend.Component(compoundID: testP, mgPerML: 50),
                    VialBlend.Component(compoundID: testPP, mgPerML: 100),
                    VialBlend.Component(compoundID: testIso, mgPerML: 100),
                    VialBlend.Component(compoundID: testDec, mgPerML: 150)
                ]
            )
            
            blends.append(contentsOf: [sustanon250, sustanon350, sustanon400])
        }
        
        // Add more commercial blends as needed - could add Winstrol Susp 50, Masteron P 100, etc.
        // as mentioned in the guide, but for brevity I&apos;ll focus on just Sustanon blends for now
        
        // The following would be added for a complete implementation:
        // - Winstrol Susp 50
        // - Masteron P 100 &amp; E 200
        // - Primobolan E 100
        // - Tren Susp 50, Tren A 100, Tren E 200, Tren Hex 76
        // - Tren Mix 150
        // - Cut-Stack 150 &amp; 250
        // - MENT Ac 50
        // - DHB Cyp 100
    }
}</file><file path="TestoSim/Models/CycleModel.swift">import Foundation

/// Represents a complete treatment cycle with multiple stages
struct Cycle: Identifiable, Codable {
    var id: UUID = UUID()
    var name: String
    var startDate: Date
    var totalWeeks: Int
    var notes: String?
    var stages: [CycleStage] = []
    
    /// Calculated end date based on start date and total weeks
    var endDate: Date {
        Calendar.current.date(byAdding: .day, value: totalWeeks * 7, to: startDate) ?? startDate
    }
    
    /// Converts this cycle to a set of temporary InjectionProtocols for simulation
    func generateTemporaryProtocols(compoundLibrary: CompoundLibrary) -&gt; [InjectionProtocol] {
        // Each stage will create one or more protocols
        return stages.flatMap { stage in
            stage.generateProtocols(cycleStartDate: startDate, compoundLibrary: compoundLibrary)
        }
    }
}

/// Represents a single stage in a cycle with specific compounds/blends and timing
struct CycleStage: Identifiable, Codable {
    var id: UUID = UUID()
    var name: String
    var startWeek: Int  // Week number in the cycle (0-based)
    var durationWeeks: Int
    var compounds: [CompoundStageItem] = []
    var blends: [BlendStageItem] = []
    
    /// Start date calculated from cycle start date and stage&apos;s start week
    func startDate(from cycleStartDate: Date) -&gt; Date {
        Calendar.current.date(byAdding: .day, value: startWeek * 7, to: cycleStartDate) ?? cycleStartDate
    }
    
    /// End date calculated from start date and duration
    func endDate(from cycleStartDate: Date) -&gt; Date {
        let start = startDate(from: cycleStartDate)
        return Calendar.current.date(byAdding: .day, value: durationWeeks * 7, to: start) ?? start
    }
    
    /// Generates temporary protocols for each compound and blend in this stage
    func generateProtocols(cycleStartDate: Date, compoundLibrary: CompoundLibrary) -&gt; [InjectionProtocol] {
        var protocols: [InjectionProtocol] = []
        
        // Add compound protocols
        for compoundItem in compounds {
            let name = &quot;\(self.name) - \(compoundItem.compoundName)&quot;
            let treatmentProtocol = InjectionProtocol(
                name: name,
                doseMg: compoundItem.doseMg,
                frequencyDays: compoundItem.frequencyDays,
                startDate: startDate(from: cycleStartDate),
                notes: &quot;Part of cycle: \(self.name)&quot;,
                compoundID: compoundItem.compoundID,
                selectedRoute: compoundItem.administrationRoute
            )
            protocols.append(treatmentProtocol)
        }
        
        // Add blend protocols
        for blendItem in blends {
            let name = &quot;\(self.name) - \(blendItem.blendName)&quot;
            let treatmentProtocol = InjectionProtocol(
                name: name,
                doseMg: blendItem.doseMg,
                frequencyDays: blendItem.frequencyDays,
                startDate: startDate(from: cycleStartDate),
                notes: &quot;Part of cycle: \(self.name)&quot;,
                blendID: blendItem.blendID,
                selectedRoute: blendItem.administrationRoute
            )
            protocols.append(treatmentProtocol)
        }
        
        return protocols
    }
}

/// Represents a single compound item within a cycle stage
struct CompoundStageItem: Identifiable, Codable {
    var id: UUID = UUID()
    var compoundID: UUID
    var compoundName: String
    var doseMg: Double
    var frequencyDays: Double
    var administrationRoute: String // Compound.Route.rawValue
}

/// Represents a single blend item within a cycle stage
struct BlendStageItem: Identifiable, Codable {
    var id: UUID = UUID()
    var blendID: UUID
    var blendName: String
    var doseMg: Double
    var frequencyDays: Double
    var administrationRoute: String // Compound.Route.rawValue
}</file><file path="TestoSim/Views/CompoundListView.swift">import SwiftUI

struct CompoundListView: View {
    @EnvironmentObject var dataStore: AppDataStore
    @Environment(\.dismiss) var dismiss
    
    @Binding var selectedCompoundID: UUID?
    
    @State private var searchText = &quot;&quot;
    @State private var filterClass: Compound.Class?
    @State private var filterRoute: Compound.Route?
    
    var filteredCompounds: [Compound] {
        let compounds = dataStore.compoundLibrary.compounds
        
        return compounds.filter { compound in
            // Apply search filter
            let matchesSearch = searchText.isEmpty || 
                compound.fullDisplayName.localizedCaseInsensitiveContains(searchText)
            
            // Apply class filter
            let matchesClass = filterClass == nil || compound.classType == filterClass
            
            // Apply route filter - compound must support the selected route
            let matchesRoute = filterRoute == nil || 
                (compound.defaultBioavailability[filterRoute!] ?? 0.0) &gt; 0
            
            return matchesSearch &amp;&amp; matchesClass &amp;&amp; matchesRoute
        }
    }
    
    var body: some View {
        NavigationView {
            VStack {
                // Search and filters
                SearchBar(text: $searchText, placeholder: &quot;Search compounds&quot;)
                
                // Class filter
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 10) {
                        ClassFilterButton(title: &quot;All&quot;, isSelected: filterClass == nil) {
                            filterClass = nil
                        }
                        
                        ForEach(Compound.Class.allCases, id: \.self) { classType in
                            ClassFilterButton(
                                title: classType.displayName,
                                isSelected: filterClass == classType
                            ) {
                                filterClass = classType
                            }
                        }
                    }
                    .padding(.horizontal)
                }
                
                // Route filter
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 10) {
                        RouteFilterButton(title: &quot;All Routes&quot;, isSelected: filterRoute == nil) {
                            filterRoute = nil
                        }
                        
                        ForEach(Compound.Route.allCases, id: \.self) { route in
                            RouteFilterButton(
                                title: route.displayName,
                                isSelected: filterRoute == route
                            ) {
                                filterRoute = route
                            }
                        }
                    }
                    .padding(.horizontal)
                }
                
                // Compound list
                List {
                    ForEach(filteredCompounds) { compound in
                        CompoundRow(compound: compound, isSelected: selectedCompoundID == compound.id)
                            .contentShape(Rectangle())
                            .onTapGesture {
                                selectedCompoundID = compound.id
                                dismiss()
                            }
                    }
                }
                .listStyle(PlainListStyle())
            }
            .navigationTitle(&quot;Select Compound&quot;)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button(&quot;Cancel&quot;) {
                        dismiss()
                    }
                }
            }
        }
    }
}

// MARK: - Supporting Views

struct SearchBar: View {
    @Binding var text: String
    var placeholder: String
    
    var body: some View {
        HStack {
            Image(systemName: &quot;magnifyingglass&quot;)
                .foregroundColor(.secondary)
            
            TextField(placeholder, text: $text)
                .disableAutocorrection(true)
            
            if !text.isEmpty {
                Button(action: {
                    text = &quot;&quot;
                }) {
                    Image(systemName: &quot;xmark.circle.fill&quot;)
                        .foregroundColor(.secondary)
                }
            }
        }
        .padding(8)
        .background(Color(.systemGray6))
        .cornerRadius(10)
        .padding(.horizontal)
    }
}

struct ClassFilterButton: View {
    var title: String
    var isSelected: Bool
    var action: () -&gt; Void
    
    var body: some View {
        Button(action: action) {
            Text(title)
                .padding(.vertical, 8)
                .padding(.horizontal, 16)
                .background(isSelected ? Color.blue : Color(.systemGray5))
                .foregroundColor(isSelected ? .white : .primary)
                .cornerRadius(20)
        }
    }
}

struct RouteFilterButton: View {
    var title: String
    var isSelected: Bool
    var action: () -&gt; Void
    
    var body: some View {
        Button(action: action) {
            Text(title)
                .padding(.vertical, 8)
                .padding(.horizontal, 16)
                .background(isSelected ? Color.green : Color(.systemGray5))
                .foregroundColor(isSelected ? .white : .primary)
                .cornerRadius(20)
        }
    }
}

struct CompoundRow: View {
    var compound: Compound
    var isSelected: Bool
    
    var body: some View {
        HStack {
            VStack(alignment: .leading) {
                Text(compound.fullDisplayName)
                    .font(.headline)
                
                Text(&quot;Half-life: \(String(format: &quot;%.1f&quot;, compound.halfLifeDays)) days&quot;)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                
                // Show supported routes
                let supportedRoutes = compound.defaultBioavailability.keys.map { $0.displayName }.joined(separator: &quot;, &quot;)
                Text(&quot;Routes: \(supportedRoutes)&quot;)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            Spacer()
            
            if isSelected {
                Image(systemName: &quot;checkmark&quot;)
                    .foregroundColor(.blue)
            }
        }
        .padding(.vertical, 4)
    }
}

#Preview {
    CompoundListView(selectedCompoundID: .constant(nil))
        .environmentObject(AppDataStore())
}</file><file path="TestoSim/Views/VialBlendListView.swift">import SwiftUI

struct VialBlendListView: View {
    @EnvironmentObject var dataStore: AppDataStore
    @Environment(\.dismiss) var dismiss
    
    @Binding var selectedBlendID: UUID?
    
    @State private var searchText = &quot;&quot;
    @State private var filterClass: Compound.Class?
    
    var filteredBlends: [VialBlend] {
        let blends = dataStore.compoundLibrary.blends
        
        return blends.filter { blend in
            // Apply search filter
            let matchesSearch = searchText.isEmpty || 
                blend.name.localizedCaseInsensitiveContains(searchText) ||
                (blend.manufacturer?.localizedCaseInsensitiveContains(searchText) ?? false)
            
            // Apply class filter (check if blend contains any compound of the selected class)
            let matchesClass: Bool
            if let filterClass = filterClass {
                matchesClass = blend.resolvedComponents(using: dataStore.compoundLibrary)
                    .contains { $0.compound.classType == filterClass }
            } else {
                matchesClass = true
            }
            
            return matchesSearch &amp;&amp; matchesClass
        }
    }
    
    var body: some View {
        NavigationView {
            VStack {
                // Search and filters
                SearchBar(text: $searchText, placeholder: &quot;Search blends&quot;)
                
                // Class filter
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 10) {
                        ClassFilterButton(title: &quot;All&quot;, isSelected: filterClass == nil) {
                            filterClass = nil
                        }
                        
                        ForEach(Compound.Class.allCases, id: \.self) { classType in
                            ClassFilterButton(
                                title: classType.displayName,
                                isSelected: filterClass == classType
                            ) {
                                filterClass = classType
                            }
                        }
                    }
                    .padding(.horizontal)
                }
                
                // Blend list
                List {
                    ForEach(filteredBlends) { blend in
                        BlendRow(
                            blend: blend, 
                            library: dataStore.compoundLibrary,
                            isSelected: selectedBlendID == blend.id
                        )
                        .contentShape(Rectangle())
                        .onTapGesture {
                            selectedBlendID = blend.id
                            dismiss()
                        }
                    }
                }
                .listStyle(PlainListStyle())
            }
            .navigationTitle(&quot;Select Blend&quot;)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button(&quot;Cancel&quot;) {
                        dismiss()
                    }
                }
            }
        }
    }
}

struct BlendRow: View {
    var blend: VialBlend
    var library: CompoundLibrary
    var isSelected: Bool
    
    var body: some View {
        HStack {
            VStack(alignment: .leading) {
                Text(blend.name)
                    .font(.headline)
                
                if let manufacturer = blend.manufacturer {
                    Text(manufacturer)
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
                
                Text(blend.compositionDescription(using: library))
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .lineLimit(2)
                
                Text(&quot;Total: \(String(format: &quot;%.0f&quot;, blend.totalConcentration)) mg/mL&quot;)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            Spacer()
            
            if isSelected {
                Image(systemName: &quot;checkmark&quot;)
                    .foregroundColor(.blue)
            }
        }
        .padding(.vertical, 4)
    }
}

#Preview {
    VialBlendListView(selectedBlendID: .constant(nil))
        .environmentObject(AppDataStore())
}</file><file path="TestoSim/Config-Sample.plist">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
&lt;plist version=&quot;1.0&quot;&gt;
&lt;dict&gt;
    &lt;key&gt;OPENAI_API_KEY&lt;/key&gt;
    &lt;string&gt;PLACEHOLDER_API_KEY&lt;/string&gt;
&lt;/dict&gt;
&lt;/plist&gt;</file><file path="TestoSim.xcodeproj/project.xcworkspace/contents.xcworkspacedata">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Workspace
   version = &quot;1.0&quot;&gt;
   &lt;FileRef
      location = &quot;self:&quot;&gt;
   &lt;/FileRef&gt;
&lt;/Workspace&gt;</file><file path="TestoSimTests/TestoSimTests.swift">//
//  TestoSimTests.swift
//  TestoSimTests
//
//  Created by Jesper Vang on 01/05/2025.
//

import Testing

struct TestoSimTests {

    @Test func example() async throws {
        // Write your test here and use APIs like `#expect(...)` to check expected conditions.
    }

}</file><file path="TestoSimUITests/TestoSimUITests.swift">//
//  TestoSimUITests.swift
//  TestoSimUITests
//
//  Created by Jesper Vang on 01/05/2025.
//

import XCTest

final class TestoSimUITests: XCTestCase {

    override func setUpWithError() throws {
        // Put setup code here. This method is called before the invocation of each test method in the class.

        // In UI tests it is usually best to stop immediately when a failure occurs.
        continueAfterFailure = false

        // In UI tests it’s important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.
    }

    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }

    @MainActor
    func testExample() throws {
        // UI tests must launch the application that they test.
        let app = XCUIApplication()
        app.launch()

        // Use XCTAssert and related functions to verify your tests produce the correct results.
    }

    @MainActor
    func testLaunchPerformance() throws {
        // This measures how long it takes to launch your application.
        measure(metrics: [XCTApplicationLaunchMetric()]) {
            XCUIApplication().launch()
        }
    }
}</file><file path="TestoSimUITests/TestoSimUITestsLaunchTests.swift">//
//  TestoSimUITestsLaunchTests.swift
//  TestoSimUITests
//
//  Created by Jesper Vang on 01/05/2025.
//

import XCTest

final class TestoSimUITestsLaunchTests: XCTestCase {

    override class var runsForEachTargetApplicationUIConfiguration: Bool {
        true
    }

    override func setUpWithError() throws {
        continueAfterFailure = false
    }

    @MainActor
    func testLaunch() throws {
        let app = XCUIApplication()
        app.launch()

        // Insert steps here to perform after app launch but before taking a screenshot,
        // such as logging into a test account or navigating somewhere in the app

        let attachment = XCTAttachment(screenshot: app.screenshot())
        attachment.name = &quot;Launch Screen&quot;
        attachment.lifetime = .keepAlways
        add(attachment)
    }
}</file><file path="add_files_to_target.sh">#!/bin/bash

# This script lists all Swift files in the project that need to be added to the target
# Run this script, then add these files to your target in Xcode

echo &quot;Swift files to add to target:&quot;
echo &quot;&quot;

# Find all Swift files in the TestoSim directory
find ./TestoSim -name &quot;*.swift&quot; | sort

echo &quot;&quot;
echo &quot;Instructions:&quot;
echo &quot;1. In Xcode, select all these files in the Project Navigator (left sidebar)&quot;
echo &quot;2. In the File Inspector (right sidebar, first tab), check the box for TestoSim target&quot;
echo &quot;3. Clean and build the project (Cmd+Shift+K, then Cmd+B)&quot;</file><file path="build-test.sh">#!/bin/bash
# TestoSim build script - avoids launching multiple simulators
# Usage: ./build-test.sh [clean]

set -o pipefail

# Default simulator device
DEVICE=&quot;iPhone 16,OS=18.4&quot;

# Check if xcbeautify is installed
if ! command -v xcbeautify &amp;&gt; /dev/null; then
    echo &quot;xcbeautify not found. Installing...&quot;
    brew install xcbeautify
fi

# Check if we need to clean
if [ &quot;$1&quot; == &quot;clean&quot; ]; then
    echo &quot;Cleaning build...&quot;
    xcodebuild -project TestoSim.xcodeproj -scheme TestoSim -destination &quot;platform=iOS Simulator,name=$DEVICE&quot; clean | xcbeautify
fi

# Build only, don&apos;t run
echo &quot;Building TestoSim...&quot;
xcodebuild -project TestoSim.xcodeproj -scheme TestoSim -destination &quot;platform=iOS Simulator,name=$DEVICE&quot; build | xcbeautify

# Check build status
if [ $? -eq 0 ]; then
    echo &quot;✅ Build succeeded. Use SweetPad to run in simulator.&quot;
    echo &quot;&quot;
    echo &quot;To run in SweetPad:&quot;
    echo &quot;1. Open VS Code with SweetPad extension&quot;
    echo &quot;2. Run task &apos;SweetPad: Build&apos; from command palette or context menu&quot;
    echo &quot;&quot;
    echo &quot;This avoids launching multiple simulators.&quot;
else
    echo &quot;❌ Build failed.&quot;
fi</file><file path="buildServer.json">{
	&quot;name&quot;: &quot;xcode build server&quot;,
	&quot;version&quot;: &quot;0.2&quot;,
	&quot;bspVersion&quot;: &quot;2.0&quot;,
	&quot;languages&quot;: [
		&quot;c&quot;,
		&quot;cpp&quot;,
		&quot;objective-c&quot;,
		&quot;objective-cpp&quot;,
		&quot;swift&quot;
	],
	&quot;argv&quot;: [
		&quot;/opt/homebrew/bin/xcode-build-server&quot;
	],
	&quot;workspace&quot;: &quot;/Users/jesper/Projects/Dev_projects/Xcode/TestoSim/TestoSim.xcodeproj/project.xcworkspace&quot;,
	&quot;build_root&quot;: &quot;/Users/jesper/Library/Developer/Xcode/DerivedData/TestoSim-amdpjdmzwgneoqgnxzlcnphserjo&quot;,
	&quot;scheme&quot;: &quot;TestoSim&quot;,
	&quot;kind&quot;: &quot;xcode&quot;
}</file><file path="close-simulators.sh">#!/bin/bash
# TestoSim simulator management - closes all running simulators
# Usage: ./close-simulators.sh

echo &quot;Checking for running simulators...&quot;
RUNNING_SIMS=$(xcrun simctl list devices | grep -i &quot;booted&quot; | wc -l)

if [ $RUNNING_SIMS -gt 0 ]; then
    echo &quot;Found $RUNNING_SIMS running simulator(s). Shutting down...&quot;
    xcrun simctl shutdown all
    echo &quot;All simulators are now closed.&quot;
else
    echo &quot;No running simulators found.&quot;
fi</file><file path="launch-test.sh">#!/bin/bash
# TestoSim test launcher - uses a single simulator instance
# Usage: ./launch-test.sh [device_name]
# Example: ./launch-test.sh &quot;iPhone 16&quot;

set -o pipefail

# Default device if not specified
DEFAULT_DEVICE=&quot;iPhone 16&quot;
DEVICE=&quot;${1:-$DEFAULT_DEVICE}&quot;

echo &quot;📱 Using device: $DEVICE&quot;

# Check for any running simulators first
RUNNING_SIMS=$(xcrun simctl list devices | grep -i &quot;booted&quot; | wc -l)
if [ $RUNNING_SIMS -gt 0 ]; then
    echo &quot;⚠️ Found running simulators. Shutting them down first...&quot;
    xcrun simctl shutdown all
    sleep 2
fi

# Boot the specific simulator
echo &quot;🚀 Booting simulator: $DEVICE&quot;
xcrun simctl boot &quot;$DEVICE&quot; 2&gt;/dev/null || echo &quot;ℹ️ Device may already be booted&quot;

# Build the app
echo &quot;🔨 Building TestoSim...&quot;
xcodebuild -project TestoSim.xcodeproj -scheme TestoSim -destination &quot;platform=iOS Simulator,name=$DEVICE&quot; build | xcbeautify

# Check if build succeeded
if [ $? -ne 0 ]; then
    echo &quot;❌ Build failed. Exiting.&quot;
    exit 1
fi

# Install and launch
echo &quot;📲 Installing and launching app...&quot;
APP_PATH=$(find ${HOME}/Library/Developer/Xcode/DerivedData/TestoSim-*/Build/Products/Debug-iphonesimulator -name &quot;TestoSim.app&quot; -type d | head -n 1)

if [ -z &quot;$APP_PATH&quot; ]; then
    echo &quot;❌ Could not find built app. Path may be different.&quot;
    exit 1
fi

xcrun simctl install &quot;$DEVICE&quot; &quot;$APP_PATH&quot;
xcrun simctl launch &quot;$DEVICE&quot; &quot;$(defaults read &quot;$APP_PATH/Info&quot; CFBundleIdentifier)&quot;

echo &quot;✅ App launched in a single simulator instance.&quot;
echo &quot;📝 To close all simulators when done, run: ./close-simulators.sh&quot;</file><file path="TestoSim/Models/CDBloodSample+CoreDataClass.swift">//
//  CDBloodSample+CoreDataClass.swift
//  TestoSim
//
//  Created by Jesper Vang on 02/05/2025.
//
//

import Foundation
import CoreData

@objc(CDBloodSample)
public class CDBloodSample: NSManagedObject {

}</file><file path="TestoSim/Models/CDCompound+CoreDataClass.swift">//
//  CDCompound+CoreDataClass.swift
//  TestoSim
//
//  Created by Jesper Vang on 02/05/2025.
//
//

import Foundation
import CoreData

@objc(CDCompound)
public class CDCompound: NSManagedObject {

}</file><file path="TestoSim/Models/CDInjectionProtocol+CoreDataClass.swift">//
//  CDInjectionProtocol+CoreDataClass.swift
//  TestoSim
//
//  Created by Jesper Vang on 02/05/2025.
//
//

import Foundation
import CoreData

@objc(CDInjectionProtocol)
public class CDInjectionProtocol: NSManagedObject {

}</file><file path="TestoSim/Models/CDUserProfile+CoreDataClass.swift">//
//  CDUserProfile+CoreDataClass.swift
//  TestoSim
//
//  Created by Jesper Vang on 02/05/2025.
//
//

import Foundation
import CoreData

@objc(CDUserProfile)
public class CDUserProfile: NSManagedObject {

}</file><file path="TestoSim/Models/CDVialBlend+CoreDataClass.swift">//
//  CDVialBlend+CoreDataClass.swift
//  TestoSim
//
//  Created by Jesper Vang on 02/05/2025.
//
//

import Foundation
import CoreData

@objc(CDVialBlend)
public class CDVialBlend: NSManagedObject {

}</file><file path="TestoSim/Models/CDVialComponent+CoreDataClass.swift">//
//  CDVialComponent+CoreDataClass.swift
//  TestoSim
//
//  Created by Jesper Vang on 02/05/2025.
//
//

import Foundation
import CoreData

@objc(CDVialComponent)
public class CDVialComponent: NSManagedObject {

}</file><file path="TestoSim/Models/DataPoint.swift">import Foundation
 
struct DataPoint: Identifiable {
    let id = UUID()
    let time: Date
    let level: Double
}</file><file path="TestoSim/Models/VialBlend.swift">import Foundation

struct VialBlend: Identifiable, Codable, Hashable {
    struct Component: Codable, Hashable {
        let compoundID: UUID
        let mgPerML: Double
        
        init(compoundID: UUID, mgPerML: Double) {
            self.compoundID = compoundID
            self.mgPerML = mgPerML
        }
    }
    
    let id: UUID
    var name: String
    var manufacturer: String?
    var description: String?
    var components: [Component]
    
    init(id: UUID = UUID(), 
         name: String, 
         manufacturer: String? = nil, 
         description: String? = nil, 
         components: [Component]) {
        self.id = id
        self.name = name
        self.manufacturer = manufacturer
        self.description = description
        self.components = components
    }
    
    // Total concentration in mg/mL
    var totalConcentration: Double {
        components.reduce(0) { $0 + $1.mgPerML }
    }
    
    // Returns components with their actual compounds (requires CompoundLibrary lookup)
    func resolvedComponents(using library: CompoundLibrary) -&gt; [(compound: Compound, mgPerML: Double)] {
        return components.compactMap { component in
            guard let compound = library.compound(withID: component.compoundID) else {
                return nil
            }
            return (compound: compound, mgPerML: component.mgPerML)
        }
    }
    
    // Creates a descriptive string representing the blend contents
    func compositionDescription(using library: CompoundLibrary) -&gt; String {
        let resolved = resolvedComponents(using: library)
        if resolved.isEmpty {
            return &quot;Unknown composition&quot;
        }
        
        // Completely rewritten to avoid any string interpolation complexity
        let descriptions = resolved.map { component -&gt; String in
            let name = component.compound.fullDisplayName
            let dosage = Int(component.mgPerML)
            return name + &quot; &quot; + String(dosage) + &quot;mg/mL&quot;
        }
        
        return descriptions.joined(separator: &quot;, &quot;)
    }
}</file><file path="TestoSim/ViewModels/NotificationManager.swift">import Foundation
import UserNotifications
import SwiftUI

class NotificationManager: NSObject, UNUserNotificationCenterDelegate {
    static let shared = NotificationManager()
    
    enum LeadTime: String, CaseIterable, Identifiable {
        case oneHour = &quot;1 hour&quot;
        case sixHours = &quot;6 hours&quot;
        case twelveHours = &quot;12 hours&quot;
        
        var id: String { self.rawValue }
        
        var timeInterval: TimeInterval {
            switch self {
            case .oneHour: return 3600
            case .sixHours: return 21600
            case .twelveHours: return 43200
            }
        }
    }
    
    enum AdherenceStatus: String, Codable {
        case onTime, late, missed
    }
    
    struct InjectionRecord: Codable, Identifiable {
        let id: UUID
        let protocolID: UUID
        let scheduledDate: Date
        let acknowledgedDate: Date?
        let status: AdherenceStatus
        let doseMg: Double
        let compoundOrBlendName: String
        
        var isAcknowledged: Bool {
            return acknowledgedDate != nil
        }
    }
    
    // User preferences
    var notificationsEnabled: Bool {
        get { UserDefaults.standard.bool(forKey: &quot;notificationsEnabled&quot;) }
        set { UserDefaults.standard.set(newValue, forKey: &quot;notificationsEnabled&quot;) }
    }
    
    var soundEnabled: Bool {
        get { UserDefaults.standard.bool(forKey: &quot;notificationSoundEnabled&quot;) }
        set { UserDefaults.standard.set(newValue, forKey: &quot;notificationSoundEnabled&quot;) }
    }
    
    var selectedLeadTime: LeadTime {
        get {
            if let storedValue = UserDefaults.standard.string(forKey: &quot;notificationLeadTime&quot;),
               let leadTime = LeadTime(rawValue: storedValue) {
                return leadTime
            }
            return .oneHour
        }
        set {
            UserDefaults.standard.set(newValue.rawValue, forKey: &quot;notificationLeadTime&quot;)
        }
    }
    
    // Adherence tracking
    private var injectionRecords: [InjectionRecord] = []
    
    override init() {
        super.init()
        
        // Set delegate for handling notifications when app is in foreground
        UNUserNotificationCenter.current().delegate = self
        
        // Load adherence records
        loadInjectionRecords()
    }
    
    // MARK: - Notification Permissions
    
    func requestNotificationPermission() async -&gt; Bool {
        do {
            let options: UNAuthorizationOptions = [.alert, .sound, .badge]
            return try await UNUserNotificationCenter.current().requestAuthorization(options: options)
        } catch {
            print(&quot;Error requesting notification permission: \(error)&quot;)
            return false
        }
    }
    
    // MARK: - Scheduling Notifications
    
    func scheduleNotifications(for protocol: InjectionProtocol, using compoundLibrary: CompoundLibrary) {
        guard notificationsEnabled else { return }
        
        // Cancel existing notifications for this protocol
        cancelNotifications(for: `protocol`.id)
        
        // Calculate next injection dates from today onwards
        let today = Date()
        let simulationEndDate = today.addingTimeInterval(365 * 24 * 3600) // Schedule for up to a year
        let injectionDates = `protocol`.injectionDates(from: today, upto: simulationEndDate)
        
        // Get compound or blend name for the notification
        let itemName: String
        if let compoundID = `protocol`.compoundID, 
           let compound = compoundLibrary.compound(withID: compoundID) {
            itemName = compound.commonName
        } else if let blendID = `protocol`.blendID,
                  let blend = compoundLibrary.blend(withID: blendID) {
            itemName = blend.name
        } else {
            itemName = &quot;medication&quot;
        }
        
        // Schedule notifications for each upcoming injection
        for injectionDate in injectionDates {
            // Calculate notification time based on lead time preference
            let notificationDate = injectionDate.addingTimeInterval(-selectedLeadTime.timeInterval)
            
            // Only schedule if the notification date is in the future
            if notificationDate &gt; today {
                scheduleInjectionNotification(
                    for: `protocol`.id,
                    protocolName: `protocol`.name,
                    compoundName: itemName,
                    doseMg: `protocol`.doseMg,
                    injectionDate: injectionDate,
                    notificationDate: notificationDate
                )
                
                // Also track this upcoming injection in our records
                let newRecord = InjectionRecord(
                    id: UUID(),
                    protocolID: `protocol`.id,
                    scheduledDate: injectionDate,
                    acknowledgedDate: nil,
                    status: .onTime, // Default status will be updated later
                    doseMg: `protocol`.doseMg,
                    compoundOrBlendName: itemName
                )
                
                // Only add if we don&apos;t already have a record for this date
                if !injectionRecords.contains(where: { 
                    $0.protocolID == newRecord.protocolID &amp;&amp; 
                    Calendar.current.isDate($0.scheduledDate, inSameDayAs: newRecord.scheduledDate)
                }) {
                    injectionRecords.append(newRecord)
                }
            }
        }
        
        // Save the updated records
        saveInjectionRecords()
    }
    
    private func scheduleInjectionNotification(for protocolID: UUID, protocolName: String, compoundName: String, doseMg: Double, injectionDate: Date, notificationDate: Date) {
        // Create a unique identifier for this notification
        let identifier = &quot;injection-\(protocolID.uuidString)-\(injectionDate.timeIntervalSince1970)&quot;
        
        // Create the notification content
        let content = UNMutableNotificationContent()
        content.title = &quot;Injection Reminder&quot;
        content.body = &quot;Time for your \(doseMg)mg \(compoundName) injection (\(protocolName))&quot;
        content.sound = soundEnabled ? UNNotificationSound.default : nil
        content.userInfo = [
            &quot;protocolID&quot;: protocolID.uuidString,
            &quot;injectionDate&quot;: injectionDate.timeIntervalSince1970,
            &quot;type&quot;: &quot;injection-reminder&quot;
        ]
        
        // Create date components for a precise date
        let dateComponents = Calendar.current.dateComponents(
            [.year, .month, .day, .hour, .minute, .second],
            from: notificationDate
        )
        
        // Create the trigger
        let trigger = UNCalendarNotificationTrigger(dateMatching: dateComponents, repeats: false)
        
        // Create the request
        let request = UNNotificationRequest(identifier: identifier, content: content, trigger: trigger)
        
        // Add it to the notification center
        UNUserNotificationCenter.current().add(request) { error in
            if let error = error {
                print(&quot;Error scheduling notification: \(error)&quot;)
            }
        }
    }
    
    func cancelNotifications(for protocolID: UUID) {
        // Get all pending notification requests
        UNUserNotificationCenter.current().getPendingNotificationRequests { requests in
            // Find all requests for this protocol
            let identifiers = requests
                .filter { $0.content.userInfo[&quot;protocolID&quot;] as? String == protocolID.uuidString }
                .map { $0.identifier }
            
            // Remove these notifications
            UNUserNotificationCenter.current().removePendingNotificationRequests(withIdentifiers: identifiers)
        }
    }
    
    func cancelAllNotifications() {
        UNUserNotificationCenter.current().removeAllPendingNotificationRequests()
    }
    
    // MARK: - Notification Delegate Methods
    
    func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -&gt; Void) {
        // Display notification even when app is in foreground
        completionHandler([.banner, .sound, .badge])
    }
    
    func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) {
        // Handle the user&apos;s response to the notification
        let userInfo = response.notification.request.content.userInfo
        
        if userInfo[&quot;type&quot;] as? String == &quot;injection-reminder&quot;,
           let protocolIDString = userInfo[&quot;protocolID&quot;] as? String,
           let protocolID = UUID(uuidString: protocolIDString),
           let injectionTimeInterval = userInfo[&quot;injectionDate&quot;] as? TimeInterval {
            
            let injectionDate = Date(timeIntervalSince1970: injectionTimeInterval)
            acknowledgeInjection(protocolID: protocolID, injectionDate: injectionDate)
        }
        
        completionHandler()
    }
    
    // MARK: - Adherence Tracking
    
    func acknowledgeInjection(protocolID: UUID, injectionDate: Date) {
        let now = Date()
        
        // Find the record for this injection
        if let index = injectionRecords.firstIndex(where: { 
            $0.protocolID == protocolID &amp;&amp; 
            Calendar.current.isDate($0.scheduledDate, inSameDayAs: injectionDate)
        }) {
            // Update the record
            let record = injectionRecords[index]
            
            // Determine adherence status
            let hoursBetween = injectionDate.distance(to: now) / 3600
            
            var status: AdherenceStatus
            if hoursBetween &lt; 24 {
                status = .onTime
            } else if hoursBetween &lt; 48 {
                status = .late
            } else {
                status = .missed
            }
            
            // Create new record with updated status
            let updatedRecord = InjectionRecord(
                id: record.id,
                protocolID: record.protocolID,
                scheduledDate: record.scheduledDate,
                acknowledgedDate: now,
                status: status,
                doseMg: record.doseMg,
                compoundOrBlendName: record.compoundOrBlendName
            )
            
            // Update the record
            injectionRecords[index] = updatedRecord
            saveInjectionRecords()
        }
    }
    
    // MARK: - Analytics
    
    func adherenceStats() -&gt; (total: Int, onTime: Int, late: Int, missed: Int) {
        let acknowledged = injectionRecords.filter { $0.isAcknowledged }
        
        let onTime = acknowledged.filter { $0.status == .onTime }.count
        let late = acknowledged.filter { $0.status == .late }.count
        let missed = acknowledged.filter { $0.status == .missed }.count
        
        return (total: acknowledged.count, onTime: onTime, late: late, missed: missed)
    }
    
    func adherencePercentage() -&gt; Double {
        let stats = adherenceStats()
        guard stats.total &gt; 0 else { return 0 }
        
        return Double(stats.onTime) / Double(stats.total) * 100.0
    }
    
    // MARK: - Persistence
    
    private func saveInjectionRecords() {
        if let encodedData = try? JSONEncoder().encode(injectionRecords) {
            UserDefaults.standard.set(encodedData, forKey: &quot;injectionRecords&quot;)
        }
    }
    
    private func loadInjectionRecords() {
        if let savedData = UserDefaults.standard.data(forKey: &quot;injectionRecords&quot;),
           let decodedRecords = try? JSONDecoder().decode([InjectionRecord].self, from: savedData) {
            self.injectionRecords = decodedRecords
        }
    }
    
    func injectionHistory(for protocolID: UUID? = nil) -&gt; [InjectionRecord] {
        if let protocolID = protocolID {
            return injectionRecords.filter { $0.protocolID == protocolID }
        } else {
            return injectionRecords
        }
    }
    
    // Cleanup old records older than 6 months
    func cleanupOldRecords() {
        let sixMonthsAgo = Calendar.current.date(byAdding: .month, value: -6, to: Date())!
        injectionRecords = injectionRecords.filter { $0.scheduledDate &gt; sixMonthsAgo }
        saveInjectionRecords()
    }
}</file><file path="TestoSim/Views/InjectionHistoryView.swift">import SwiftUI

struct InjectionHistoryView: View {
    @EnvironmentObject var dataStore: AppDataStore
    @State private var filterBy: UUID? = nil
    
    var body: some View {
        NavigationView {
            VStack {
                InjectionAdherenceStatsView()
                    .padding()
                    .background(Color(.systemBackground))
                    .cornerRadius(10)
                    .shadow(radius: 1)
                    .padding(.horizontal)
                
                protocolFilterPicker
                
                List {
                    if historyRecords.isEmpty {
                        Text(&quot;No injection records found&quot;)
                            .foregroundColor(.secondary)
                            .italic()
                            .frame(maxWidth: .infinity, alignment: .center)
                            .listRowBackground(Color.clear)
                    } else {
                        ForEach(historyRecords) { record in
                            InjectionRecordRow(record: record)
                        }
                    }
                }
                .listStyle(InsetGroupedListStyle())
            }
            .navigationTitle(&quot;Injection History&quot;)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(&quot;Clear Old&quot;) {
                        dataStore.cleanupOldRecords()
                    }
                }
            }
        }
    }
    
    private var protocolFilterPicker: some View {
        Picker(&quot;Filter by Protocol&quot;, selection: $filterBy) {
            Text(&quot;All Protocols&quot;).tag(nil as UUID?)
            
            ForEach(dataStore.profile.protocols) { treatmentProtocol in
                Text(treatmentProtocol.name).tag(treatmentProtocol.id as UUID?)
            }
        }
        .pickerStyle(MenuPickerStyle())
        .padding(.horizontal)
    }
    
    private var historyRecords: [NotificationManager.InjectionRecord] {
        dataStore.injectionHistory(for: filterBy)
            .sorted(by: { $0.scheduledDate &gt; $1.scheduledDate })
    }
}

struct InjectionRecordRow: View {
    let record: NotificationManager.InjectionRecord
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Text(&quot;\(record.compoundOrBlendName) \(record.doseMg.isFinite ? Int(record.doseMg) : 0)mg&quot;)
                    .font(.headline)
                
                Spacer()
                
                statusBadge
            }
            
            HStack {
                Label {
                    Text(record.scheduledDate, style: .date)
                        .font(.subheadline)
                } icon: {
                    Image(systemName: &quot;calendar&quot;)
                        .foregroundColor(.secondary)
                }
                
                Spacer()
                
                Label {
                    Text(record.scheduledDate, style: .time)
                        .font(.subheadline)
                } icon: {
                    Image(systemName: &quot;clock&quot;)
                        .foregroundColor(.secondary)
                }
            }
            
            if let acknowledgedDate = record.acknowledgedDate {
                Text(&quot;Taken: \(acknowledgedDate, style: .date) at \(acknowledgedDate, style: .time)&quot;)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                    .padding(.top, 2)
            }
        }
        .padding(.vertical, 4)
    }
    
    private var statusBadge: some View {
        HStack(spacing: 4) {
            Circle()
                .fill(statusColor)
                .frame(width: 8, height: 8)
            
            Text(statusText)
                .font(.caption)
                .foregroundColor(statusColor)
        }
        .padding(.horizontal, 8)
        .padding(.vertical, 4)
        .background(statusColor.opacity(0.1))
        .cornerRadius(12)
    }
    
    private var statusColor: Color {
        switch record.status {
        case .onTime:
            return .green
        case .late:
            return .orange
        case .missed:
            return .red
        }
    }
    
    private var statusText: String {
        switch record.status {
        case .onTime:
            return &quot;On Time&quot;
        case .late:
            return &quot;Late&quot;
        case .missed:
            return &quot;Missed&quot;
        }
    }
}

struct InjectionAdherenceStatsView: View {
    @EnvironmentObject var dataStore: AppDataStore
    
    private var allRecords: [NotificationManager.InjectionRecord] {
        dataStore.injectionHistory()
    }
    
    private var onTimeCount: Int {
        allRecords.filter { $0.status == .onTime }.count
    }
    
    private var lateCount: Int {
        allRecords.filter { $0.status == .late }.count
    }
    
    private var missedCount: Int {
        allRecords.filter { $0.status == .missed }.count
    }
    
    private var adherencePercentage: Double {
        if allRecords.isEmpty {
            return 0
        }
        return Double(onTimeCount + lateCount) / Double(allRecords.count) * 100
    }
    
    var body: some View {
        VStack {
            Text(&quot;Adherence Rate: \(adherencePercentage.isFinite ? Int(adherencePercentage) : 0)%&quot;)
                .font(.headline)
                .padding(.bottom, 4)
            
            HStack(spacing: 20) {
                StatItem(label: &quot;On Time&quot;, value: onTimeCount, color: .green)
                StatItem(label: &quot;Late&quot;, value: lateCount, color: .orange)
                StatItem(label: &quot;Missed&quot;, value: missedCount, color: .red)
            }
        }
    }
}

struct StatItem: View {
    let label: String
    let value: Int
    let color: Color
    
    var body: some View {
        VStack {
            Text(&quot;\(value)&quot;)
                .font(.title2)
                .fontWeight(.bold)
                .foregroundColor(color)
            
            Text(label)
                .font(.caption)
                .foregroundColor(.secondary)
        }
    }
}

struct InjectionHistoryView_Previews: PreviewProvider {
    static var previews: some View {
        InjectionHistoryView()
            .environmentObject(AppDataStore())
    }
}</file><file path="TestoSim/Views/NotificationSettingsView.swift">import SwiftUI

struct NotificationSettingsView: View {
    @EnvironmentObject var dataStore: AppDataStore
    @Environment(\.dismiss) private var dismiss
    
    // Local state for notification settings
    @State private var notificationsEnabled: Bool
    @State private var soundEnabled: Bool
    @State private var selectedLeadTime: NotificationManager.LeadTime
    
    // Initialize state from the notification manager
    init() {
        let notificationManager = NotificationManager.shared
        _notificationsEnabled = State(initialValue: notificationManager.notificationsEnabled)
        _soundEnabled = State(initialValue: notificationManager.soundEnabled)
        _selectedLeadTime = State(initialValue: notificationManager.selectedLeadTime)
    }
    
    var body: some View {
        NavigationView {
            Form {
                Section(header: Text(&quot;Notifications&quot;)) {
                    Toggle(&quot;Enable Injection Reminders&quot;, isOn: $notificationsEnabled)
                        .onChange(of: notificationsEnabled) { oldValue, newValue in
                            dataStore.toggleNotifications(enabled: newValue)
                        }
                    
                    if notificationsEnabled {
                        Toggle(&quot;Play Sound&quot;, isOn: $soundEnabled)
                            .onChange(of: soundEnabled) { oldValue, newValue in
                                dataStore.setNotificationSound(enabled: newValue)
                            }
                        
                        Picker(&quot;Remind Me&quot;, selection: $selectedLeadTime) {
                            ForEach(NotificationManager.LeadTime.allCases) { leadTime in
                                Text(&quot;Before \(leadTime.rawValue)&quot;)
                                    .tag(leadTime)
                            }
                        }
                        .onChange(of: selectedLeadTime) { oldValue, newValue in
                            dataStore.setNotificationLeadTime(newValue)
                        }
                    }
                }
                
                Section(header: Text(&quot;Adherence Statistics&quot;)) {
                    NotificationAdherenceStatsView()
                }
                
                Section(header: Text(&quot;About Notifications&quot;), footer: Text(&quot;Notifications help you stay on schedule with your injections. You&apos;ll receive reminders before each scheduled injection based on your preferences.&quot;)) {
                    // This section is just for information
                    Label(&quot;Notifications help improve adherence&quot;, systemImage: &quot;bell.badge&quot;)
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
            }
            .navigationTitle(&quot;Notification Settings&quot;)
            .navigationBarItems(trailing: Button(&quot;Done&quot;) {
                dismiss()
            })
        }
    }
}

struct NotificationAdherenceStatsView: View {
    @EnvironmentObject var dataStore: AppDataStore
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            let stats = dataStore.adherenceStats()
            let adherencePercent = dataStore.adherencePercentage()
            
            HStack {
                Text(&quot;Adherence Rate:&quot;)
                    .fontWeight(.medium)
                Spacer()
                Text(String(format: &quot;%.1f%%&quot;, adherencePercent))
                    .fontWeight(.bold)
                    .foregroundColor(adherenceColor(for: adherencePercent))
            }
            
            if stats.total &gt; 0 {
                Divider()
                
                HStack {
                    Text(&quot;On Time:&quot;)
                    Spacer()
                    Text(&quot;\(stats.onTime) of \(stats.total)&quot;)
                        .foregroundColor(.green)
                }
                
                HStack {
                    Text(&quot;Late:&quot;)
                    Spacer()
                    Text(&quot;\(stats.late) of \(stats.total)&quot;)
                        .foregroundColor(.orange)
                }
                
                HStack {
                    Text(&quot;Missed:&quot;)
                    Spacer()
                    Text(&quot;\(stats.missed) of \(stats.total)&quot;)
                        .foregroundColor(.red)
                }
            } else {
                Text(&quot;No injections recorded yet&quot;)
                    .foregroundColor(.secondary)
                    .italic()
            }
        }
    }
    
    private func adherenceColor(for percent: Double) -&gt; Color {
        if percent &gt;= 90 {
            return .green
        } else if percent &gt;= 75 {
            return .orange
        } else {
            return .red
        }
    }
}

#Preview {
    NotificationSettingsView()
        .environmentObject(AppDataStore())
}</file><file path="TestoSim/Config-Sample.xcconfig">// Configuration settings file format documentation can be found at:
// https://help.apple.com/xcode/#/dev745c5c974

// OpenAI API Key (replace with your actual API key)
OPENAI_API_KEY = _YOUR_OPENAI_API_KEY_HERE_</file><file path="TestoSim.xcodeproj/project.pbxproj">// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 77;
	objects = {

/* Begin PBXContainerItemProxy section */
		243FDC412DC4C75F002945A1 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 243FDC2B2DC4C75E002945A1 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 243FDC322DC4C75E002945A1;
			remoteInfo = TestoSim;
		};
		243FDC4B2DC4C75F002945A1 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 243FDC2B2DC4C75E002945A1 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 243FDC322DC4C75E002945A1;
			remoteInfo = TestoSim;
		};
/* End PBXContainerItemProxy section */

/* Begin PBXFileReference section */
		243FDC332DC4C75E002945A1 /* TestoSim.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = TestoSim.app; sourceTree = BUILT_PRODUCTS_DIR; };
		243FDC402DC4C75F002945A1 /* TestoSimTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = TestoSimTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
		243FDC4A2DC4C75F002945A1 /* TestoSimUITests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = TestoSimUITests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
/* End PBXFileReference section */

/* Begin PBXFileSystemSynchronizedRootGroup section */
		243FDC352DC4C75E002945A1 /* TestoSim */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			path = TestoSim;
			sourceTree = &quot;&lt;group&gt;&quot;;
		};
		243FDC432DC4C75F002945A1 /* TestoSimTests */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			path = TestoSimTests;
			sourceTree = &quot;&lt;group&gt;&quot;;
		};
		243FDC4D2DC4C75F002945A1 /* TestoSimUITests */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			path = TestoSimUITests;
			sourceTree = &quot;&lt;group&gt;&quot;;
		};
/* End PBXFileSystemSynchronizedRootGroup section */

/* Begin PBXFrameworksBuildPhase section */
		243FDC302DC4C75E002945A1 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		243FDC3D2DC4C75F002945A1 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		243FDC472DC4C75F002945A1 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		243FDC2A2DC4C75E002945A1 = {
			isa = PBXGroup;
			children = (
				243FDC352DC4C75E002945A1 /* TestoSim */,
				243FDC432DC4C75F002945A1 /* TestoSimTests */,
				243FDC4D2DC4C75F002945A1 /* TestoSimUITests */,
				243FDC342DC4C75E002945A1 /* Products */,
			);
			sourceTree = &quot;&lt;group&gt;&quot;;
		};
		243FDC342DC4C75E002945A1 /* Products */ = {
			isa = PBXGroup;
			children = (
				243FDC332DC4C75E002945A1 /* TestoSim.app */,
				243FDC402DC4C75F002945A1 /* TestoSimTests.xctest */,
				243FDC4A2DC4C75F002945A1 /* TestoSimUITests.xctest */,
			);
			name = Products;
			sourceTree = &quot;&lt;group&gt;&quot;;
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		243FDC322DC4C75E002945A1 /* TestoSim */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 243FDC542DC4C75F002945A1 /* Build configuration list for PBXNativeTarget &quot;TestoSim&quot; */;
			buildPhases = (
				243FDC2F2DC4C75E002945A1 /* Sources */,
				243FDC302DC4C75E002945A1 /* Frameworks */,
				243FDC312DC4C75E002945A1 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			fileSystemSynchronizedGroups = (
				243FDC352DC4C75E002945A1 /* TestoSim */,
			);
			name = TestoSim;
			packageProductDependencies = (
			);
			productName = TestoSim;
			productReference = 243FDC332DC4C75E002945A1 /* TestoSim.app */;
			productType = &quot;com.apple.product-type.application&quot;;
		};
		243FDC3F2DC4C75F002945A1 /* TestoSimTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 243FDC572DC4C75F002945A1 /* Build configuration list for PBXNativeTarget &quot;TestoSimTests&quot; */;
			buildPhases = (
				243FDC3C2DC4C75F002945A1 /* Sources */,
				243FDC3D2DC4C75F002945A1 /* Frameworks */,
				243FDC3E2DC4C75F002945A1 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				243FDC422DC4C75F002945A1 /* PBXTargetDependency */,
			);
			fileSystemSynchronizedGroups = (
				243FDC432DC4C75F002945A1 /* TestoSimTests */,
			);
			name = TestoSimTests;
			packageProductDependencies = (
			);
			productName = TestoSimTests;
			productReference = 243FDC402DC4C75F002945A1 /* TestoSimTests.xctest */;
			productType = &quot;com.apple.product-type.bundle.unit-test&quot;;
		};
		243FDC492DC4C75F002945A1 /* TestoSimUITests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 243FDC5A2DC4C75F002945A1 /* Build configuration list for PBXNativeTarget &quot;TestoSimUITests&quot; */;
			buildPhases = (
				243FDC462DC4C75F002945A1 /* Sources */,
				243FDC472DC4C75F002945A1 /* Frameworks */,
				243FDC482DC4C75F002945A1 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				243FDC4C2DC4C75F002945A1 /* PBXTargetDependency */,
			);
			fileSystemSynchronizedGroups = (
				243FDC4D2DC4C75F002945A1 /* TestoSimUITests */,
			);
			name = TestoSimUITests;
			packageProductDependencies = (
			);
			productName = TestoSimUITests;
			productReference = 243FDC4A2DC4C75F002945A1 /* TestoSimUITests.xctest */;
			productType = &quot;com.apple.product-type.bundle.ui-testing&quot;;
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		243FDC2B2DC4C75E002945A1 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = 1;
				LastSwiftUpdateCheck = 1630;
				LastUpgradeCheck = 1630;
				TargetAttributes = {
					243FDC322DC4C75E002945A1 = {
						CreatedOnToolsVersion = 16.3;
					};
					243FDC3F2DC4C75F002945A1 = {
						CreatedOnToolsVersion = 16.3;
						TestTargetID = 243FDC322DC4C75E002945A1;
					};
					243FDC492DC4C75F002945A1 = {
						CreatedOnToolsVersion = 16.3;
						TestTargetID = 243FDC322DC4C75E002945A1;
					};
				};
			};
			buildConfigurationList = 243FDC2E2DC4C75E002945A1 /* Build configuration list for PBXProject &quot;TestoSim&quot; */;
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 243FDC2A2DC4C75E002945A1;
			minimizedProjectReferenceProxies = 1;
			preferredProjectObjectVersion = 77;
			productRefGroup = 243FDC342DC4C75E002945A1 /* Products */;
			projectDirPath = &quot;&quot;;
			projectRoot = &quot;&quot;;
			targets = (
				243FDC322DC4C75E002945A1 /* TestoSim */,
				243FDC3F2DC4C75F002945A1 /* TestoSimTests */,
				243FDC492DC4C75F002945A1 /* TestoSimUITests */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		243FDC312DC4C75E002945A1 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		243FDC3E2DC4C75F002945A1 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		243FDC482DC4C75F002945A1 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		243FDC2F2DC4C75E002945A1 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		243FDC3C2DC4C75F002945A1 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		243FDC462DC4C75F002945A1 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		243FDC422DC4C75F002945A1 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 243FDC322DC4C75E002945A1 /* TestoSim */;
			targetProxy = 243FDC412DC4C75F002945A1 /* PBXContainerItemProxy */;
		};
		243FDC4C2DC4C75F002945A1 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 243FDC322DC4C75E002945A1 /* TestoSim */;
			targetProxy = 243FDC4B2DC4C75F002945A1 /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin XCBuildConfiguration section */
		243FDC522DC4C75F002945A1 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = &quot;gnu++20&quot;;
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				DEVELOPMENT_TEAM = LF5UPMD2CC;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					&quot;DEBUG=1&quot;,
					&quot;$(inherited)&quot;,
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 18.4;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
				MTL_FAST_MATH = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = &quot;DEBUG $(inherited)&quot;;
				SWIFT_OPTIMIZATION_LEVEL = &quot;-Onone&quot;;
			};
			name = Debug;
		};
		243FDC532DC4C75F002945A1 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = &quot;gnu++20&quot;;
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = &quot;dwarf-with-dsym&quot;;
				DEVELOPMENT_TEAM = LF5UPMD2CC;
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 18.4;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = NO;
				MTL_FAST_MATH = YES;
				SDKROOT = iphoneos;
				SWIFT_COMPILATION_MODE = wholemodule;
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		243FDC552DC4C75F002945A1 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = LF5UPMD2CC;
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = &quot;UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight&quot;;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = &quot;UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight&quot;;
				LD_RUNPATH_SEARCH_PATHS = (
					&quot;$(inherited)&quot;,
					&quot;@executable_path/Frameworks&quot;,
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = flight505.TestoSim;
				PRODUCT_NAME = &quot;$(TARGET_NAME)&quot;;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = &quot;1,2&quot;;
			};
			name = Debug;
		};
		243FDC562DC4C75F002945A1 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = LF5UPMD2CC;
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = &quot;UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight&quot;;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = &quot;UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight&quot;;
				LD_RUNPATH_SEARCH_PATHS = (
					&quot;$(inherited)&quot;,
					&quot;@executable_path/Frameworks&quot;,
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = flight505.TestoSim;
				PRODUCT_NAME = &quot;$(TARGET_NAME)&quot;;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = &quot;1,2&quot;;
			};
			name = Release;
		};
		243FDC582DC4C75F002945A1 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = &quot;$(TEST_HOST)&quot;;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = LF5UPMD2CC;
				GENERATE_INFOPLIST_FILE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 18.4;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = flight505.TestoSimTests;
				PRODUCT_NAME = &quot;$(TARGET_NAME)&quot;;
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = &quot;1,2&quot;;
				TEST_HOST = &quot;$(BUILT_PRODUCTS_DIR)/TestoSim.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/TestoSim&quot;;
			};
			name = Debug;
		};
		243FDC592DC4C75F002945A1 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = &quot;$(TEST_HOST)&quot;;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = LF5UPMD2CC;
				GENERATE_INFOPLIST_FILE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 18.4;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = flight505.TestoSimTests;
				PRODUCT_NAME = &quot;$(TARGET_NAME)&quot;;
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = &quot;1,2&quot;;
				TEST_HOST = &quot;$(BUILT_PRODUCTS_DIR)/TestoSim.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/TestoSim&quot;;
			};
			name = Release;
		};
		243FDC5B2DC4C75F002945A1 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = LF5UPMD2CC;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = flight505.TestoSimUITests;
				PRODUCT_NAME = &quot;$(TARGET_NAME)&quot;;
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = &quot;1,2&quot;;
				TEST_TARGET_NAME = TestoSim;
			};
			name = Debug;
		};
		243FDC5C2DC4C75F002945A1 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = LF5UPMD2CC;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = flight505.TestoSimUITests;
				PRODUCT_NAME = &quot;$(TARGET_NAME)&quot;;
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = &quot;1,2&quot;;
				TEST_TARGET_NAME = TestoSim;
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		243FDC2E2DC4C75E002945A1 /* Build configuration list for PBXProject &quot;TestoSim&quot; */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				243FDC522DC4C75F002945A1 /* Debug */,
				243FDC532DC4C75F002945A1 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		243FDC542DC4C75F002945A1 /* Build configuration list for PBXNativeTarget &quot;TestoSim&quot; */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				243FDC552DC4C75F002945A1 /* Debug */,
				243FDC562DC4C75F002945A1 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		243FDC572DC4C75F002945A1 /* Build configuration list for PBXNativeTarget &quot;TestoSimTests&quot; */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				243FDC582DC4C75F002945A1 /* Debug */,
				243FDC592DC4C75F002945A1 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		243FDC5A2DC4C75F002945A1 /* Build configuration list for PBXNativeTarget &quot;TestoSimUITests&quot; */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				243FDC5B2DC4C75F002945A1 /* Debug */,
				243FDC5C2DC4C75F002945A1 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 243FDC2B2DC4C75E002945A1 /* Project object */;
}</file><file path="TestoSim/TestoSim.xcdatamodeld/TestoSim.xcdatamodel/contents">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;model type=&quot;com.apple.IDECoreDataModeler.DataModel&quot; documentVersion=&quot;1.0&quot; lastSavedToolsVersion=&quot;23788&quot; systemVersion=&quot;24E263&quot; minimumToolsVersion=&quot;Automatic&quot; sourceLanguage=&quot;Swift&quot; userDefinedModelVersionIdentifier=&quot;&quot;&gt;
    &lt;entity name=&quot;CDBloodSample&quot; representedClassName=&quot;CDBloodSample&quot; syncable=&quot;YES&quot; codeGenerationType=&quot;category&quot;&gt;
        &lt;attribute name=&quot;date&quot; optional=&quot;YES&quot; attributeType=&quot;Date&quot; usesScalarValueType=&quot;NO&quot;/&gt;
        &lt;attribute name=&quot;id&quot; optional=&quot;YES&quot; attributeType=&quot;UUID&quot; usesScalarValueType=&quot;NO&quot;/&gt;
        &lt;attribute name=&quot;unit&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
        &lt;attribute name=&quot;value&quot; optional=&quot;YES&quot; attributeType=&quot;Double&quot; defaultValueString=&quot;0.0&quot; usesScalarValueType=&quot;YES&quot;/&gt;
        &lt;relationship name=&quot;injectionProtocol&quot; optional=&quot;YES&quot; maxCount=&quot;1&quot; deletionRule=&quot;Nullify&quot; destinationEntity=&quot;CDInjectionProtocol&quot; inverseName=&quot;bloodSamples&quot; inverseEntity=&quot;CDInjectionProtocol&quot;/&gt;
        &lt;fetchedProperty name=&quot;fetchedProperty&quot; optional=&quot;YES&quot;&gt;
            &lt;fetchRequest name=&quot;fetchedPropertyFetchRequest&quot; entity=&quot;CDBloodSample&quot;/&gt;
        &lt;/fetchedProperty&gt;
    &lt;/entity&gt;
    &lt;entity name=&quot;CDCompound&quot; representedClassName=&quot;CDCompound&quot; syncable=&quot;YES&quot; codeGenerationType=&quot;category&quot;&gt;
        &lt;attribute name=&quot;classType&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
        &lt;attribute name=&quot;commonName&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
        &lt;attribute name=&quot;ester&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
        &lt;attribute name=&quot;halfLifeDays&quot; optional=&quot;YES&quot; attributeType=&quot;Double&quot; defaultValueString=&quot;0.0&quot; usesScalarValueType=&quot;YES&quot;/&gt;
        &lt;attribute name=&quot;id&quot; optional=&quot;YES&quot; attributeType=&quot;UUID&quot; usesScalarValueType=&quot;NO&quot;/&gt;
        &lt;attribute name=&quot;routeBioavailabilityData&quot; optional=&quot;YES&quot; attributeType=&quot;Binary&quot;/&gt;
        &lt;attribute name=&quot;routeKaData&quot; optional=&quot;YES&quot; attributeType=&quot;Binary&quot;/&gt;
        &lt;relationship name=&quot;components&quot; optional=&quot;YES&quot; toMany=&quot;YES&quot; deletionRule=&quot;Nullify&quot; destinationEntity=&quot;CDVialComponent&quot; inverseName=&quot;compound&quot; inverseEntity=&quot;CDVialComponent&quot;/&gt;
        &lt;relationship name=&quot;protocols&quot; optional=&quot;YES&quot; toMany=&quot;YES&quot; deletionRule=&quot;Nullify&quot; destinationEntity=&quot;CDInjectionProtocol&quot; inverseName=&quot;ester&quot; inverseEntity=&quot;CDInjectionProtocol&quot;/&gt;
    &lt;/entity&gt;
    &lt;entity name=&quot;CDCycle&quot; representedClassName=&quot;CDCycle&quot; syncable=&quot;YES&quot; codeGenerationType=&quot;category&quot;&gt;
        &lt;attribute name=&quot;id&quot; optional=&quot;YES&quot; attributeType=&quot;UUID&quot; usesScalarValueType=&quot;NO&quot;/&gt;
        &lt;attribute name=&quot;name&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
        &lt;attribute name=&quot;notes&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
        &lt;attribute name=&quot;startDate&quot; optional=&quot;YES&quot; attributeType=&quot;Date&quot; usesScalarValueType=&quot;NO&quot;/&gt;
        &lt;attribute name=&quot;totalWeeks&quot; optional=&quot;YES&quot; attributeType=&quot;Integer 32&quot; defaultValueString=&quot;0&quot; usesScalarValueType=&quot;YES&quot;/&gt;
        &lt;relationship name=&quot;stages&quot; optional=&quot;YES&quot; toMany=&quot;YES&quot; deletionRule=&quot;Cascade&quot; destinationEntity=&quot;CDCycleStage&quot; inverseName=&quot;cycle&quot; inverseEntity=&quot;CDCycleStage&quot;/&gt;
        &lt;relationship name=&quot;userProfile&quot; optional=&quot;YES&quot; maxCount=&quot;1&quot; deletionRule=&quot;Nullify&quot; destinationEntity=&quot;CDUserProfile&quot; inverseName=&quot;cycles&quot; inverseEntity=&quot;CDUserProfile&quot;/&gt;
    &lt;/entity&gt;
    &lt;entity name=&quot;CDCycleStage&quot; representedClassName=&quot;CDCycleStage&quot; syncable=&quot;YES&quot; codeGenerationType=&quot;category&quot;&gt;
        &lt;attribute name=&quot;blendsData&quot; optional=&quot;YES&quot; attributeType=&quot;Binary&quot;/&gt;
        &lt;attribute name=&quot;compoundsData&quot; optional=&quot;YES&quot; attributeType=&quot;Binary&quot;/&gt;
        &lt;attribute name=&quot;durationWeeks&quot; optional=&quot;YES&quot; attributeType=&quot;Integer 32&quot; defaultValueString=&quot;0&quot; usesScalarValueType=&quot;YES&quot;/&gt;
        &lt;attribute name=&quot;id&quot; optional=&quot;YES&quot; attributeType=&quot;UUID&quot; usesScalarValueType=&quot;NO&quot;/&gt;
        &lt;attribute name=&quot;name&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
        &lt;attribute name=&quot;startWeek&quot; optional=&quot;YES&quot; attributeType=&quot;Integer 32&quot; defaultValueString=&quot;0&quot; usesScalarValueType=&quot;YES&quot;/&gt;
        &lt;relationship name=&quot;cycle&quot; optional=&quot;YES&quot; maxCount=&quot;1&quot; deletionRule=&quot;Nullify&quot; destinationEntity=&quot;CDCycle&quot; inverseName=&quot;stages&quot; inverseEntity=&quot;CDCycle&quot;/&gt;
    &lt;/entity&gt;
    &lt;entity name=&quot;CDInjectionProtocol&quot; representedClassName=&quot;CDInjectionProtocol&quot; syncable=&quot;YES&quot; codeGenerationType=&quot;category&quot;&gt;
        &lt;attribute name=&quot;doseMg&quot; optional=&quot;YES&quot; attributeType=&quot;Double&quot; defaultValueString=&quot;0.0&quot; usesScalarValueType=&quot;YES&quot;/&gt;
        &lt;attribute name=&quot;frequencyDays&quot; optional=&quot;YES&quot; attributeType=&quot;Double&quot; defaultValueString=&quot;0.0&quot; usesScalarValueType=&quot;YES&quot;/&gt;
        &lt;attribute name=&quot;id&quot; optional=&quot;YES&quot; attributeType=&quot;UUID&quot; usesScalarValueType=&quot;NO&quot;/&gt;
        &lt;attribute name=&quot;name&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
        &lt;attribute name=&quot;notes&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
        &lt;attribute name=&quot;startDate&quot; optional=&quot;YES&quot; attributeType=&quot;Date&quot; usesScalarValueType=&quot;NO&quot;/&gt;
        &lt;relationship name=&quot;bloodSamples&quot; optional=&quot;YES&quot; toMany=&quot;YES&quot; deletionRule=&quot;Cascade&quot; destinationEntity=&quot;CDBloodSample&quot; inverseName=&quot;injectionProtocol&quot; inverseEntity=&quot;CDBloodSample&quot;/&gt;
        &lt;relationship name=&quot;ester&quot; optional=&quot;YES&quot; maxCount=&quot;1&quot; deletionRule=&quot;Nullify&quot; destinationEntity=&quot;CDCompound&quot; inverseName=&quot;protocols&quot; inverseEntity=&quot;CDCompound&quot;/&gt;
        &lt;relationship name=&quot;profile&quot; optional=&quot;YES&quot; maxCount=&quot;1&quot; deletionRule=&quot;Nullify&quot; destinationEntity=&quot;CDUserProfile&quot; inverseName=&quot;protocols&quot; inverseEntity=&quot;CDUserProfile&quot;/&gt;
    &lt;/entity&gt;
    &lt;entity name=&quot;CDUserProfile&quot; representedClassName=&quot;CDUserProfile&quot; syncable=&quot;YES&quot; codeGenerationType=&quot;category&quot;&gt;
        &lt;attribute name=&quot;biologicalSex&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
        &lt;attribute name=&quot;calibrationFactor&quot; optional=&quot;YES&quot; attributeType=&quot;Double&quot; defaultValueString=&quot;1.0&quot; usesScalarValueType=&quot;YES&quot;/&gt;
        &lt;attribute name=&quot;dateOfBirth&quot; optional=&quot;YES&quot; attributeType=&quot;Date&quot; usesScalarValueType=&quot;NO&quot;/&gt;
        &lt;attribute name=&quot;heightCm&quot; optional=&quot;YES&quot; attributeType=&quot;Double&quot; defaultValueString=&quot;0.0&quot; usesScalarValueType=&quot;YES&quot;/&gt;
        &lt;attribute name=&quot;id&quot; optional=&quot;YES&quot; attributeType=&quot;UUID&quot; usesScalarValueType=&quot;NO&quot;/&gt;
        &lt;attribute name=&quot;name&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
        &lt;attribute name=&quot;unit&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
        &lt;attribute name=&quot;usesICloudSync&quot; optional=&quot;YES&quot; attributeType=&quot;Boolean&quot; defaultValueString=&quot;NO&quot; usesScalarValueType=&quot;YES&quot;/&gt;
        &lt;attribute name=&quot;useTwoCompartmentModel&quot; optional=&quot;YES&quot; attributeType=&quot;Boolean&quot; defaultValueString=&quot;NO&quot; usesScalarValueType=&quot;YES&quot;/&gt;
        &lt;attribute name=&quot;weight&quot; optional=&quot;YES&quot; attributeType=&quot;Double&quot; defaultValueString=&quot;0.0&quot; usesScalarValueType=&quot;YES&quot;/&gt;
        &lt;relationship name=&quot;cycles&quot; optional=&quot;YES&quot; toMany=&quot;YES&quot; deletionRule=&quot;Cascade&quot; destinationEntity=&quot;CDCycle&quot; inverseName=&quot;userProfile&quot; inverseEntity=&quot;CDCycle&quot;/&gt;
        &lt;relationship name=&quot;protocols&quot; optional=&quot;YES&quot; toMany=&quot;YES&quot; deletionRule=&quot;Cascade&quot; destinationEntity=&quot;CDInjectionProtocol&quot; inverseName=&quot;profile&quot; inverseEntity=&quot;CDInjectionProtocol&quot;/&gt;
    &lt;/entity&gt;
    &lt;entity name=&quot;CDVialBlend&quot; representedClassName=&quot;CDVialBlend&quot; syncable=&quot;YES&quot; codeGenerationType=&quot;category&quot;&gt;
        &lt;attribute name=&quot;blendDescription&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
        &lt;attribute name=&quot;id&quot; optional=&quot;YES&quot; attributeType=&quot;UUID&quot; usesScalarValueType=&quot;NO&quot;/&gt;
        &lt;attribute name=&quot;manufacturer&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
        &lt;attribute name=&quot;name&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
        &lt;relationship name=&quot;components&quot; optional=&quot;YES&quot; toMany=&quot;YES&quot; deletionRule=&quot;Cascade&quot; destinationEntity=&quot;CDVialComponent&quot; inverseName=&quot;vialBlend&quot; inverseEntity=&quot;CDVialComponent&quot;/&gt;
    &lt;/entity&gt;
    &lt;entity name=&quot;CDVialComponent&quot; representedClassName=&quot;CDVialComponent&quot; syncable=&quot;YES&quot; codeGenerationType=&quot;category&quot;&gt;
        &lt;attribute name=&quot;mgPerML&quot; optional=&quot;YES&quot; attributeType=&quot;Double&quot; defaultValueString=&quot;0.0&quot; usesScalarValueType=&quot;YES&quot;/&gt;
        &lt;relationship name=&quot;compound&quot; optional=&quot;YES&quot; maxCount=&quot;1&quot; deletionRule=&quot;Nullify&quot; destinationEntity=&quot;CDCompound&quot; inverseName=&quot;components&quot; inverseEntity=&quot;CDCompound&quot;/&gt;
        &lt;relationship name=&quot;vialBlend&quot; optional=&quot;YES&quot; maxCount=&quot;1&quot; deletionRule=&quot;Nullify&quot; destinationEntity=&quot;CDVialBlend&quot; inverseName=&quot;components&quot; inverseEntity=&quot;CDVialBlend&quot;/&gt;
    &lt;/entity&gt;
&lt;/model&gt;</file><file path="TestoSim/ViewModels/CoreDataManager.swift">import Foundation
import CoreData
import CloudKit

class CoreDataManager {
    static let shared = CoreDataManager()
    
    // MARK: - Core Data stack
    
    lazy var persistentContainer: NSPersistentContainer = {
        // Set up the CloudKit container
        let cloudKitContainerID = &quot;iCloud.flight505.TestoSim&quot;
        
        // Check if iCloud sync is enabled via UserDefaults
        let usesICloudSync = UserDefaults.standard.bool(forKey: &quot;usesICloudSync&quot;)
        
        // Use NSPersistentCloudKitContainer if iCloud sync is enabled, otherwise use regular NSPersistentContainer
        let container: NSPersistentContainer
        
        if usesICloudSync {
            container = NSPersistentCloudKitContainer(name: &quot;TestoSim&quot;)
            print(&quot;Using CloudKit-enabled persistent container&quot;)
            
            // Configure CloudKit integration
            if let cloudStoreDescription = container.persistentStoreDescriptions.first {
                // Enable CloudKit
                cloudStoreDescription.cloudKitContainerOptions = NSPersistentCloudKitContainerOptions(containerIdentifier: cloudKitContainerID)
                
                // Enable history tracking (required for CloudKit sync)
                cloudStoreDescription.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)
                cloudStoreDescription.setOption(true as NSNumber, forKey: NSPersistentStoreRemoteChangeNotificationPostOptionKey)
            }
        } else {
            container = NSPersistentContainer(name: &quot;TestoSim&quot;)
            print(&quot;Using standard persistent container (CloudKit disabled)&quot;)
        }
        
        // Initialize the Core Data stack
        container.loadPersistentStores(completionHandler: { (storeDescription, error) in
            if let error = error as NSError? {
                // Replace this implementation with code to handle the error appropriately.
                print(&quot;Unresolved error loading persistent stores: \(error), \(error.userInfo)&quot;)
                
                // Log CloudKit specific issues if present
                if let cloudError = error.userInfo[NSUnderlyingErrorKey] as? NSError,
                   cloudError.domain == CKErrorDomain {
                    print(&quot;CloudKit error: \(cloudError.localizedDescription)&quot;)
                }
            } else {
                print(&quot;Successfully loaded persistent store: \(storeDescription)&quot;)
                
                // Initialize CloudKit schema if CloudKit is enabled
                if let cloudKitOptions = storeDescription.cloudKitContainerOptions,
                   let cloudKitContainer = container as? NSPersistentCloudKitContainer {
                    do {
                        try cloudKitContainer.initializeCloudKitSchema(options: [.printSchema])
                        print(&quot;CloudKit schema initialized successfully&quot;)
                    } catch {
                        print(&quot;Error initializing CloudKit schema: \(error)&quot;)
                    }
                }
            }
        })
        
        // Enable automatic merging of changes from the parent context
        container.viewContext.automaticallyMergesChangesFromParent = true
        container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
        
        return container
    }()
    
    // MARK: - Core Data operations
    
    func saveContext() {
        let context = persistentContainer.viewContext
        if context.hasChanges {
            do {
                try context.save()
                print(&quot;Context saved successfully&quot;)
            } catch {
                let nserror = error as NSError
                print(&quot;Unresolved error saving context: \(nserror), \(nserror.userInfo)&quot;)
            }
        }
    }
    
    // MARK: - Background task
    
    func performBackgroundTask(_ block: @escaping (NSManagedObjectContext) -&gt; Void) {
        persistentContainer.performBackgroundTask(block)
    }
    
    // MARK: - iCloud Sync Control
    
    func enableCloudSync(_ enable: Bool) {
        let currentSetting = UserDefaults.standard.bool(forKey: &quot;usesICloudSync&quot;)
        
        // Only update if the setting has changed
        if currentSetting != enable {
            UserDefaults.standard.set(enable, forKey: &quot;usesICloudSync&quot;)
            
            // Notify the user that a restart is required
            let notification = Notification(name: Notification.Name(&quot;CloudKitSyncSettingChanged&quot;), 
                                           object: nil, 
                                           userInfo: [&quot;enabled&quot;: enable])
            NotificationCenter.default.post(notification)
            
            print(&quot;CloudKit sync \(enable ? &quot;enabled&quot; : &quot;disabled&quot;) - app restart required for changes to take effect&quot;)
        }
    }
    
    func isCloudSyncEnabled() -&gt; Bool {
        return UserDefaults.standard.bool(forKey: &quot;usesICloudSync&quot;)
    }
    
    // MARK: - Migration
    
    func migrateUserProfileFromJSON() {
        // Check if we&apos;ve already migrated
        if UserDefaults.standard.bool(forKey: &quot;migrated&quot;) {
            return
        }
        
        // Get the profile data from UserDefaults
        guard let profileData = UserDefaults.standard.data(forKey: &quot;userProfileData&quot;) else {
            // No data to migrate
            UserDefaults.standard.set(true, forKey: &quot;migrated&quot;)
            return
        }
        
        let decoder = JSONDecoder()
        
        do {
            // Decode the JSON data into our model struct
            let profile = try decoder.decode(UserProfile.self, from: profileData)
            
            // Create Core Data versions of the entities
            let context = persistentContainer.viewContext
            
            // Create CDUserProfile
            let cdProfile = CDUserProfile(context: context)
            cdProfile.id = profile.id
            cdProfile.name = profile.name
            cdProfile.unit = profile.unit
            cdProfile.calibrationFactor = profile.calibrationFactor
            cdProfile.dateOfBirth = profile.dateOfBirth
            cdProfile.heightCm = profile.heightCm ?? 0
            cdProfile.weight = profile.weight ?? 0
            cdProfile.biologicalSex = profile.biologicalSex.rawValue
            cdProfile.usesICloudSync = profile.usesICloudSync
            
            // Create CDInjectionProtocol entries
            for p in profile.protocols {
                let cdProtocol = CDInjectionProtocol(context: context)
                cdProtocol.id = p.id
                cdProtocol.name = p.name
                cdProtocol.doseMg = p.doseMg
                cdProtocol.frequencyDays = p.frequencyDays
                cdProtocol.startDate = p.startDate
                cdProtocol.notes = p.notes
                
                // TODO: The Core Data model needs to be updated to include these properties:
                // - compoundID (UUID)
                // - blendID (UUID)
                // - selectedRoute (String)
                // Once added, uncomment the following lines:
                /*
                cdProtocol.compoundID = p.compoundID
                cdProtocol.blendID = p.blendID
                cdProtocol.selectedRoute = p.selectedRoute
                */
                
                // For now, store this information in the notes field
                var extendedInfo = &quot;&quot;
                if let compoundID = p.compoundID {
                    extendedInfo += &quot;CompoundID: \(compoundID.uuidString)\n&quot;
                }
                if let blendID = p.blendID {
                    extendedInfo += &quot;BlendID: \(blendID.uuidString)\n&quot;
                }
                if let route = p.selectedRoute {
                    extendedInfo += &quot;Route: \(route)\n&quot;
                }
                
                if !extendedInfo.isEmpty {
                    if cdProtocol.notes != nil {
                        cdProtocol.notes = cdProtocol.notes! + &quot;\n\n---EXTENDED_DATA---\n&quot; + extendedInfo
                    } else {
                        cdProtocol.notes = &quot;---EXTENDED_DATA---\n&quot; + extendedInfo
                    }
                }
                
                // Create blood samples
                for sample in p.bloodSamples {
                    let cdSample = CDBloodSample(context: context)
                    cdSample.id = sample.id
                    cdSample.date = sample.date
                    cdSample.value = sample.value
                    cdSample.unit = sample.unit
                    
                    cdProtocol.addToBloodSamples(cdSample)
                }
                
                cdProfile.addToProtocols(cdProtocol)
            }
            
            // Save to Core Data
            try context.save()
            
            // Mark as migrated
            UserDefaults.standard.set(true, forKey: &quot;migrated&quot;)
            print(&quot;Successfully migrated user profile from JSON to Core Data&quot;)
            
        } catch {
            print(&quot;Error migrating from JSON: \(error)&quot;)
        }
    }
}</file><file path="TestoSim/Views/AIInsightsView.swift">import SwiftUI

/// View for displaying AI-generated insights
struct AIInsightsView: View {
    @EnvironmentObject var dataStore: AppDataStore
    @StateObject private var insightsGenerator = AIInsightsGenerator()
    @ObservedObject private var openAIService = OpenAIService.shared
    
    var protocolID: UUID?
    var cycleID: UUID?
    
    @State private var isLoading = false
    @State private var expandedPoints: Set&lt;String&gt; = []
    @State private var showSettings = false
    @State private var errorMessage: String?
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 16) {
                // Test API key indicator
                if openAIService.isUsingTestKey {
                    testKeyIndicator
                }
                
                // API key warning if no key is set
                if !OpenAIService.shared.hasAPIKey() {
                    noApiKeyView
                }
                
                // Error message if present
                if let message = errorMessage {
                    errorView(message)
                }
                
                if isLoading {
                    loadingView
                } else if let insights = insightsGenerator.latestInsights {
                    insightsContent(insights)
                } else {
                    noInsightsView
                }
            }
            .padding()
        }
        .navigationTitle(&quot;AI Insights&quot;)
        .toolbar {
            ToolbarItem(placement: .primaryAction) {
                Button {
                    generateInsights(forceRefresh: true)
                } label: {
                    Label(&quot;Refresh&quot;, systemImage: &quot;arrow.clockwise&quot;)
                }
                .disabled(isLoading)
            }
            
            ToolbarItem(placement: .topBarTrailing) {
                Button {
                    showSettings = true
                } label: {
                    Label(&quot;Settings&quot;, systemImage: &quot;gear&quot;)
                }
            }
        }
        .onAppear {
            generateInsights()
            // Set up error handling monitoring
            updateErrorMessage()
        }
        .sheet(isPresented: $showSettings) {
            AISettingsView(insightsGenerator: insightsGenerator)
        }
        // Use a task to monitor error state changes instead of onChange
        .task {
            for await _ in insightsGenerator.$error.values {
                updateErrorMessage()
            }
        }
    }
    
    // MARK: - Private Views
    
    private var testKeyIndicator: some View {
        HStack {
            Image(systemName: &quot;checkmark.seal.fill&quot;)
                .foregroundColor(.green)
            Text(&quot;Using Test API Key&quot;)
                .font(.caption)
                .foregroundColor(.green)
            Spacer()
        }
        .padding(.horizontal, 10)
        .padding(.vertical, 5)
        .background(Color.green.opacity(0.1))
        .cornerRadius(5)
    }
    
    private var noApiKeyView: some View {
        VStack(alignment: .leading, spacing: 10) {
            HStack {
                Image(systemName: &quot;key.slash&quot;)
                    .foregroundColor(.yellow)
                Text(&quot;OpenAI API Key Required&quot;)
                    .font(.headline)
                    .foregroundColor(.yellow)
            }
            
            Text(&quot;To use AI-powered insights, you need to set up your OpenAI API key in settings.&quot;)
                .font(.subheadline)
            
            Button(&quot;Set API Key&quot;) {
                showSettings = true
            }
            .buttonStyle(.borderedProminent)
            .padding(.top, 4)
        }
        .padding()
        .background(Color.yellow.opacity(0.1))
        .cornerRadius(10)
    }
    
    private func errorView(_ message: String) -&gt; some View {
        VStack(alignment: .leading, spacing: 10) {
            HStack {
                Image(systemName: &quot;exclamationmark.triangle&quot;)
                    .foregroundColor(.red)
                Text(&quot;Error&quot;)
                    .font(.headline)
                    .foregroundColor(.red)
            }
            
            Text(message)
                .font(.subheadline)
            
            Button(&quot;Try Again&quot;) {
                errorMessage = nil
                generateInsights(forceRefresh: true)
            }
            .buttonStyle(.borderedProminent)
            .padding(.top, 4)
        }
        .padding()
        .background(Color.red.opacity(0.1))
        .cornerRadius(10)
    }
    
    private var loadingView: some View {
        VStack(spacing: 20) {
            ProgressView()
                .scaleEffect(1.5)
            
            Text(&quot;Analyzing data and generating insights...&quot;)
                .font(.headline)
            
            Text(&quot;This may take a moment&quot;)
                .foregroundColor(.secondary)
        }
        .frame(maxWidth: .infinity, minHeight: 300)
    }
    
    private var noInsightsView: some View {
        VStack(spacing: 20) {
            Image(systemName: &quot;lightbulb&quot;)
                .font(.system(size: 40))
                .foregroundColor(.orange)
            
            if dataStore.selectedProtocolID == nil &amp;&amp; dataStore.selectedCycleID == nil {
                Text(&quot;No protocol or cycle selected&quot;)
                    .font(.headline)
                
                Text(&quot;Select a protocol or cycle from the Protocols or Cycles tab to generate insights.&quot;)
                    .multilineTextAlignment(.center)
                    .foregroundColor(.secondary)
            } else {
                Text(&quot;No insights available&quot;)
                    .font(.headline)
                
                Text(&quot;Tap the refresh button to generate insights based on your current protocol or cycle data.&quot;)
                    .multilineTextAlignment(.center)
                    .foregroundColor(.secondary)
            }
            
            Button(&quot;Generate Insights&quot;) {
                generateInsights(forceRefresh: true)
            }
            .buttonStyle(.borderedProminent)
            .padding(.top)
        }
        .frame(maxWidth: .infinity, minHeight: 300)
        .padding()
    }
    
    private func insightsContent(_ insights: Insights) -&gt; some View {
        VStack(alignment: .leading, spacing: 16) {
            // Title
            Text(insights.title)
                .font(.title)
                .fontWeight(.bold)
            
            // Summary
            Text(insights.summary)
                .font(.headline)
                .padding(.bottom, 8)
            
            // Disclaimer
            Text(&quot;Note: These insights are generated by AI and should not replace medical advice.&quot;)
                .font(.caption)
                .foregroundColor(.secondary)
                .padding(.bottom, 8)
            
            // Blend explanation if available
            if let blendExplanation = insights.blendExplanation {
                blendExplanationView(blendExplanation)
            }
            
            // Key points
            if !insights.keyPoints.isEmpty {
                Text(&quot;Key Points&quot;)
                    .font(.title2)
                    .fontWeight(.bold)
                    .padding(.top, 8)
                
                ForEach(insights.keyPoints, id: \.title) { point in
                    keyPointView(point)
                }
            }
        }
    }
    
    private func blendExplanationView(_ explanation: String) -&gt; some View {
        VStack(alignment: .leading, spacing: 10) {
            Text(&quot;Blend Analysis&quot;)
                .font(.title2)
                .fontWeight(.bold)
            
            Text(explanation)
                .font(.body)
                .lineSpacing(4)
        }
        .padding()
        .background(Color.blue.opacity(0.1))
        .cornerRadius(10)
    }
    
    private func keyPointView(_ point: KeyPoint) -&gt; some View {
        let pointId = point.title
        let isExpanded = expandedPoints.contains(pointId)
        
        return VStack(alignment: .leading, spacing: 8) {
            // Header row with icon, title, and expand/collapse button
            HStack {
                iconForKeyPoint(point.type)
                    .font(.headline)
                    .foregroundColor(colorForKeyPoint(point.type))
                    .frame(width: 24, height: 24)
                
                Text(point.title)
                    .font(.headline)
                    .foregroundColor(colorForKeyPoint(point.type))
                
                Spacer()
                
                Button {
                    withAnimation {
                        if isExpanded {
                            expandedPoints.remove(pointId)
                        } else {
                            expandedPoints.insert(pointId)
                        }
                    }
                } label: {
                    Image(systemName: isExpanded ? &quot;chevron.up&quot; : &quot;chevron.down&quot;)
                        .foregroundColor(.secondary)
                }
            }
            
            // Description (visible when expanded)
            if isExpanded {
                Text(point.description)
                    .font(.body)
                    .foregroundColor(.primary)
                    .padding(.leading, 32)
                    .padding(.top, 4)
            }
        }
        .padding()
        .background(backgroundForKeyPoint(point.type).opacity(0.1))
        .cornerRadius(10)
        .contentShape(Rectangle()) // Make the entire row tappable
        .onTapGesture {
            withAnimation {
                if isExpanded {
                    expandedPoints.remove(pointId)
                } else {
                    expandedPoints.insert(pointId)
                }
            }
        }
    }
    
    // MARK: - Helper Methods
    
    private func generateInsights(forceRefresh: Bool = false) {
        self.isLoading = true
        
        if let protocolID = protocolID, let treatmentProtocol = dataStore.profile.protocols.first(where: { $0.id == protocolID }) {
            // Generate insights for a specific protocol
            insightsGenerator.generateInsights(
                for: treatmentProtocol,
                profile: dataStore.profile,
                simulationData: dataStore.simulationData,
                compoundLibrary: dataStore.compoundLibrary,
                forceRefresh: forceRefresh
            )
        } else if let cycleID = cycleID, let cycle = dataStore.cycles.first(where: { $0.id == cycleID }) {
            // Generate insights for a specific cycle
            insightsGenerator.generateCycleInsights(
                for: cycle,
                profile: dataStore.profile,
                simulationData: dataStore.cycleSimulationData,
                compoundLibrary: dataStore.compoundLibrary,
                forceRefresh: forceRefresh
            )
        } else if let selectedProtocolID = dataStore.selectedProtocolID,
                  let selectedProtocol = dataStore.profile.protocols.first(where: { $0.id == selectedProtocolID }) {
            // Use the selected protocol as fallback
            insightsGenerator.generateInsights(
                for: selectedProtocol,
                profile: dataStore.profile,
                simulationData: dataStore.simulationData,
                compoundLibrary: dataStore.compoundLibrary,
                forceRefresh: forceRefresh
            )
        } else if let selectedCycleID = dataStore.selectedCycleID,
                  let selectedCycle = dataStore.cycles.first(where: { $0.id == selectedCycleID }) {
            // Use the selected cycle as fallback
            insightsGenerator.generateCycleInsights(
                for: selectedCycle,
                profile: dataStore.profile,
                simulationData: dataStore.cycleSimulationData,
                compoundLibrary: dataStore.compoundLibrary,
                forceRefresh: forceRefresh
            )
        } else {
            // If no protocol or cycle is found, show no insights available
            self.isLoading = false
            return
        }
        
        // Update loading state based on the generator&apos;s state
        DispatchQueue.main.async {
            self.isLoading = self.insightsGenerator.isLoading
        }
    }
    
    private func iconForKeyPoint(_ type: KeyPoint.KeyPointType) -&gt; some View {
        switch type {
        case .information:
            return Image(systemName: &quot;info.circle.fill&quot;)
        case .positive:
            return Image(systemName: &quot;checkmark.circle.fill&quot;)
        case .warning:
            return Image(systemName: &quot;exclamationmark.triangle.fill&quot;)
        case .suggestion:
            return Image(systemName: &quot;lightbulb.fill&quot;)
        }
    }
    
    private func colorForKeyPoint(_ type: KeyPoint.KeyPointType) -&gt; Color {
        switch type {
        case .information:
            return .blue
        case .positive:
            return .green
        case .warning:
            return .orange
        case .suggestion:
            return .purple
        }
    }
    
    private func backgroundForKeyPoint(_ type: KeyPoint.KeyPointType) -&gt; Color {
        switch type {
        case .information:
            return .blue
        case .positive:
            return .green
        case .warning:
            return .orange
        case .suggestion:
            return .purple
        }
    }
    
    private func updateErrorMessage() {
        if let error = insightsGenerator.error {
            errorMessage = error.localizedDescription
        } else {
            errorMessage = nil
        }
    }
}

// MARK: - AISettingsView

/// View for managing AI settings, including API key
struct AISettingsView: View {
    @Environment(\.dismiss) private var dismiss
    @State private var apiKey: String = UserDefaults.standard.string(forKey: &quot;openai_api_key&quot;) ?? &quot;&quot;
    @State private var showingSuccessMessage = false
    @State private var useTestKey: Bool = UserDefaults.standard.bool(forKey: &quot;use_test_api_key&quot;)
    @EnvironmentObject var dataStore: AppDataStore
    
    // Reference to the shared insights generator
    private let insightsGenerator: AIInsightsGenerator
    
    init(insightsGenerator: AIInsightsGenerator = AIInsightsGenerator()) {
        self.insightsGenerator = insightsGenerator
    }
    
    var body: some View {
        NavigationStack {
            Form {
                Section(header: Text(&quot;API Key Options&quot;)) {
                    Toggle(&quot;Use Free Test API Key&quot;, isOn: $useTestKey)
                        .onChange(of: useTestKey) { oldValue, newValue in
                            OpenAIService.shared.toggleTestApiKey(newValue)
                            insightsGenerator.refreshAfterAPIKeyChange()
                        }
                    
                    if useTestKey {
                        Text(&quot;Using the free test API key with a $20 spending limit for all test users.&quot;)
                            .font(.caption)
                            .foregroundColor(.green)
                    } else {
                        Text(&quot;Using your personal API key.&quot;)
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                
                if !useTestKey {
                    Section(header: Text(&quot;Personal OpenAI API Key&quot;)) {
                        SecureField(&quot;Enter API Key&quot;, text: $apiKey)
                            .autocorrectionDisabled()
                            .textInputAutocapitalization(.never)
                        
                        Text(&quot;Your API key is stored securely in your device&apos;s UserDefaults and is never shared.&quot;)
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                    
                    Section {
                        Button(&quot;Save API Key&quot;) {
                            OpenAIService.shared.saveAPIKey(apiKey)
                            insightsGenerator.refreshAfterAPIKeyChange()
                            showingSuccessMessage = true
                        }
                        .disabled(apiKey.isEmpty)
                        
                        if !apiKey.isEmpty {
                            Button(&quot;Clear API Key&quot;) {
                                apiKey = &quot;&quot;
                                OpenAIService.shared.clearAPIKey()
                                insightsGenerator.refreshAfterAPIKeyChange()
                                showingSuccessMessage = true
                            }
                            .foregroundColor(.red)
                        }
                    }
                }
                
                Section(header: Text(&quot;About AI Insights&quot;)) {
                    VStack(alignment: .leading, spacing: 8) {
                        Text(&quot;How it works&quot;)
                            .font(.headline)
                        
                        Text(&quot;The AI Insights feature uses OpenAI&apos;s API to analyze your hormone protocols and cycles. It provides personalized feedback, optimization suggestions, and educational content based on your specific therapy details.&quot;)
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                    .padding(.vertical, 8)
                    
                    VStack(alignment: .leading, spacing: 8) {
                        Text(&quot;Privacy&quot;)
                            .font(.headline)
                        
                        Text(&quot;Only anonymized therapy data is sent to OpenAI for analysis. No personally identifiable information is shared. All API calls are made directly from your device.&quot;)
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                    .padding(.vertical, 8)
                    
                    VStack(alignment: .leading, spacing: 8) {
                        Text(&quot;Test API Key&quot;)
                            .font(.headline)
                        
                        Text(&quot;A free test API key is provided for evaluation purposes with a $20 spending limit across all users. For continued use after testing, we recommend using your own API key.&quot;)
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                    .padding(.vertical, 8)
                }
            }
            .navigationTitle(&quot;AI Settings&quot;)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .confirmationAction) {
                    Button(&quot;Done&quot;) {
                        dismiss()
                    }
                }
            }
            .alert(&quot;Settings Saved&quot;, isPresented: $showingSuccessMessage) {
                Button(&quot;OK&quot;) { }
            } message: {
                Text(apiKey.isEmpty ? 
                     &quot;API key has been cleared. The app will use mock data for insights.&quot; : 
                     &quot;API key has been saved. The app will now use OpenAI for generating insights.&quot;)
            }
        }
    }
}

#Preview {
    NavigationStack {
        AIInsightsView()
            .environmentObject(AppDataStore())
    }
}</file><file path="TestoSim/Views/CalibrationResultView.swift">import SwiftUI
import Charts

struct CalibrationResultView: View {
    @EnvironmentObject var dataStore: AppDataStore
    
    // Sample calibration data (in a real app, this would come from the model)
    let calibrationResults: CalibrationResults
    
    struct CalibrationResults {
        let halfLifeDays: Double
        let absorptionRateFactor: Double
        let calibrationFactor: Double
        let treatmentProtocol: InjectionProtocol
        let compound: Compound
        let bloodSamples: [BloodSample]
        let originalPredictions: [DataPoint]
        let calibratedPredictions: [DataPoint]
        let rmseImprovement: Double  // Root Mean Square Error improvement percentage
    }
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 20) {
                // Header
                VStack(alignment: .leading, spacing: 8) {
                    Text(&quot;Calibration Complete&quot;)
                        .font(.title)
                        .fontWeight(.bold)
                    
                    Text(&quot;Protocol: \(calibrationResults.treatmentProtocol.name)&quot;)
                        .font(.headline)
                    
                    Text(&quot;Compound: \(calibrationResults.compound.fullDisplayName)&quot;)
                        .font(.subheadline)
                }
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding()
                .background(Color.blue.opacity(0.1))
                .cornerRadius(12)
                
                // Chart
                chartSection
                
                // Parameters
                parametersSection
                
                // Blood Samples
                bloodSamplesSection
                
                // Improvement metrics
                improvementSection
            }
            .padding()
        }
    }
    
    var chartSection: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(&quot;Calibration Results&quot;)
                .font(.headline)
            
            Text(&quot;The chart shows the original and calibrated testosterone predictions alongside your blood samples.&quot;)
                .font(.caption)
                .foregroundColor(.secondary)
            
            Chart {
                // Original prediction line
                ForEach(calibrationResults.originalPredictions) { point in
                    LineMark(
                        x: .value(&quot;Date&quot;, point.time),
                        y: .value(&quot;Level&quot;, point.level)
                    )
                    .foregroundStyle(.orange)
                    .lineStyle(StrokeStyle(lineWidth: 2, dash: [5, 3]))
                }
                
                // Calibrated prediction line
                ForEach(calibrationResults.calibratedPredictions) { point in
                    LineMark(
                        x: .value(&quot;Date&quot;, point.time),
                        y: .value(&quot;Level&quot;, point.level)
                    )
                    .foregroundStyle(.blue)
                    .lineStyle(StrokeStyle(lineWidth: 2))
                }
                
                // Blood samples as points
                ForEach(calibrationResults.bloodSamples) { sample in
                    PointMark(
                        x: .value(&quot;Date&quot;, sample.date),
                        y: .value(&quot;Level&quot;, sample.value)
                    )
                    .foregroundStyle(.red)
                    .symbolSize(100)
                }
            }
            .frame(height: 250)
            
            // Legend
            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Circle()
                        .fill(Color.red)
                        .frame(width: 8, height: 8)
                    Text(&quot;Blood Samples&quot;)
                        .font(.caption)
                }
                
                HStack {
                    Rectangle()
                        .fill(Color.orange)
                        .frame(width: 15, height: 2)
                    Text(&quot;Original Prediction&quot;)
                        .font(.caption)
                }
                
                HStack {
                    Rectangle()
                        .fill(Color.blue)
                        .frame(width: 15, height: 2)
                    Text(&quot;Calibrated Prediction&quot;)
                        .font(.caption)
                }
            }
            .frame(maxWidth: .infinity, alignment: .leading)
            .padding(.vertical, 4)
        }
        .padding()
        .background(Color.gray.opacity(0.1))
        .cornerRadius(12)
    }
    
    var parametersSection: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(&quot;Calibrated Parameters&quot;)
                .font(.headline)
            
            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text(&quot;Half-life:&quot;)
                        .fontWeight(.semibold)
                    Spacer()
                    Text(&quot;\(calibrationResults.halfLifeDays, specifier: &quot;%.1f&quot;) days&quot;)
                }
                
                HStack {
                    Text(&quot;Absorption rate:&quot;)
                        .fontWeight(.semibold)
                    Spacer()
                    Text(&quot;\(calibrationResults.absorptionRateFactor, specifier: &quot;%.2f&quot;)x&quot;)
                }
                
                HStack {
                    Text(&quot;Calibration factor:&quot;)
                        .fontWeight(.semibold)
                    Spacer()
                    Text(&quot;\(calibrationResults.calibrationFactor, specifier: &quot;%.2f&quot;)x&quot;)
                }
                
                Divider()
                
                HStack {
                    Text(&quot;Based on:&quot;)
                        .fontWeight(.semibold)
                    Spacer()
                    Text(&quot;\(calibrationResults.bloodSamples.count) blood samples&quot;)
                }
            }
        }
        .padding()
        .background(Color.gray.opacity(0.1))
        .cornerRadius(12)
    }
    
    var bloodSamplesSection: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(&quot;Blood Samples Used&quot;)
                .font(.headline)
            
            ForEach(calibrationResults.bloodSamples) { sample in
                HStack {
                    VStack(alignment: .leading) {
                        Text(formatDate(sample.date))
                            .font(.subheadline)
                    }
                    
                    Spacer()
                    
                    Text(&quot;\(sample.value, specifier: &quot;%.1f&quot;) \(dataStore.profile.unit)&quot;)
                        .fontWeight(.semibold)
                }
                .padding(.vertical, 4)
                
                if sample.id != calibrationResults.bloodSamples.last?.id {
                    Divider()
                }
            }
        }
        .padding()
        .background(Color.gray.opacity(0.1))
        .cornerRadius(12)
    }
    
    // Helper function to format dates
    private func formatDate(_ date: Date) -&gt; String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .short
        return formatter.string(from: date)
    }
    
    var improvementSection: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(&quot;Calibration Quality&quot;)
                .font(.headline)
            
            HStack {
                VStack(alignment: .leading) {
                    Text(&quot;Prediction Improvement:&quot;)
                        .fontWeight(.semibold)
                    Text(&quot;The calibrated model is \(calibrationResults.rmseImprovement, specifier: &quot;%.1f&quot;)% more accurate&quot;)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                
                Spacer()
                
                // Simple quality indicator
                ZStack {
                    Circle()
                        .stroke(Color.gray.opacity(0.3), lineWidth: 6)
                        .frame(width: 50, height: 50)
                    
                    Circle()
                        .trim(from: 0, to: min(1.0, calibrationResults.rmseImprovement / 100))
                        .stroke(
                            calibrationResults.rmseImprovement &gt; 50 ? Color.green :
                                calibrationResults.rmseImprovement &gt; 25 ? Color.yellow : Color.red,
                            lineWidth: 6
                        )
                        .frame(width: 50, height: 50)
                        .rotationEffect(.degrees(-90))
                    
                    Text(&quot;\(calibrationResults.rmseImprovement.isFinite ? Int(calibrationResults.rmseImprovement) : 0)%&quot;)
                        .font(.system(size: 12, weight: .bold))
                }
            }
        }
        .padding()
        .background(Color.gray.opacity(0.1))
        .cornerRadius(12)
    }
}

// Preview
struct CalibrationResultView_Previews: PreviewProvider {
    static var previews: some View {
        // Create sample data for preview
        let appDataStore = AppDataStore()
        
        // Create a sample compound
        let compound = Compound(
            id: UUID(),
            commonName: &quot;Testosterone Cypionate&quot;,
            classType: .testosterone,
            ester: &quot;cypionate&quot;,
            halfLifeDays: 8.0,
            defaultBioavailability: [.intramuscular: 1.0],
            defaultAbsorptionRateKa: [.intramuscular: 0.7]
        )
        
        // Create a sample protocol
        let testProtocol = InjectionProtocol(
            name: &quot;Test Protocol&quot;,
            doseMg: 100,
            frequencyDays: 7,
            startDate: Date().addingTimeInterval(-60*60*24*30) // 30 days ago
        )
        
        // Add compoundID to the protocol
        var updatedProtocol = testProtocol
        updatedProtocol.compoundID = compound.id
        
        // Create sample blood samples
        let bloodSamples: [BloodSample] = [
            BloodSample(date: Date().addingTimeInterval(-60*60*24*20), value: 650, unit: &quot;ng/dL&quot;),
            BloodSample(date: Date().addingTimeInterval(-60*60*24*10), value: 750, unit: &quot;ng/dL&quot;),
            BloodSample(date: Date().addingTimeInterval(-60*60*24*2), value: 550, unit: &quot;ng/dL&quot;),
        ]
        
        // Create sample prediction points
        let originalPredictions: [DataPoint] = (0...30).map { i in
            let date = Date().addingTimeInterval(-60*60*24*Double(30-i))
            let baseValue = 500.0 + 200 * sin(Double(i) / 7.0 * .pi)
            return DataPoint(time: date, level: baseValue)
        }
        
        let calibratedPredictions: [DataPoint] = (0...30).map { i in
            let date = Date().addingTimeInterval(-60*60*24*Double(30-i))
            let baseValue = 600.0 + 150 * sin(Double(i) / 7.0 * .pi)
            return DataPoint(time: date, level: baseValue)
        }
        
        // Create sample calibration results
        let sampleResults = CalibrationResultView.CalibrationResults(
            halfLifeDays: 7.5,
            absorptionRateFactor: 1.2,
            calibrationFactor: 0.95,
            treatmentProtocol: updatedProtocol,
            compound: compound,
            bloodSamples: bloodSamples,
            originalPredictions: originalPredictions,
            calibratedPredictions: calibratedPredictions,
            rmseImprovement: 62.5
        )
        
        return CalibrationResultView(calibrationResults: sampleResults)
            .environmentObject(appDataStore)
    }
}</file><file path="TestoSim/Views/CyclePlannerView.swift">import SwiftUI
import Charts

struct CyclePlannerView: View {
    @EnvironmentObject var dataStore: AppDataStore
    @State private var isPresentingNewCycleForm = false
    @State private var isPresentingStageForm = false
    @State private var selectedCycle: Cycle?
    @State private var selectedStageID: UUID?
    @State private var zoomLevel: Double = 1.0
    @State private var weekViewWidth: CGFloat = 70
    
    var body: some View {
        VStack {
            if dataStore.cycles.isEmpty {
                emptyCyclesView
            } else {
                cycleListView
            }
        }
        .navigationTitle(&quot;Cycle Planner&quot;)
        .toolbar {
            ToolbarItem(placement: .primaryAction) {
                Button(action: {
                    isPresentingNewCycleForm = true
                }) {
                    Label(&quot;Add Cycle&quot;, systemImage: &quot;plus&quot;)
                }
            }
        }
        .sheet(isPresented: $isPresentingNewCycleForm) {
            CycleFormView(isPresented: $isPresentingNewCycleForm)
        }
        .sheet(item: $selectedCycle) { cycle in
            CycleDetailView(cycle: cycle)
        }
    }
    
    private var emptyCyclesView: some View {
        VStack(spacing: 16) {
            Image(systemName: &quot;calendar.badge.plus&quot;)
                .font(.system(size: 60))
                .foregroundColor(.secondary)
            
            Text(&quot;No Cycles Yet&quot;)
                .font(.title2)
                .bold()
            
            Text(&quot;Create your first cycle to plan and visualize multi-compound treatments.&quot;)
                .font(.body)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
                .foregroundColor(.secondary)
            
            Button(action: {
                isPresentingNewCycleForm = true
            }) {
                Text(&quot;Create Cycle&quot;)
                    .font(.headline)
                    .padding()
                    .background(Color.accentColor)
                    .foregroundColor(.white)
                    .cornerRadius(10)
            }
            .padding()
        }
        .padding()
    }
    
    private var cycleListView: some View {
        List {
            cycleListSection
            
            simulationResultsSection
        }
    }
    
    private var cycleListSection: some View {
        Section(header: Text(&quot;My Cycles&quot;)) {
            cycleRows
        }
    }
    
    private var cycleRows: some View {
        ForEach(dataStore.cycles) { cycle in
            cycleRow(for: cycle)
        }
        .onDelete(perform: handleDelete)
    }
    
    private func cycleRow(for cycle: Cycle) -&gt; some View {
        CycleRowView(cycle: cycle)
            .contentShape(Rectangle())
            .onTapGesture {
                dataStore.selectedCycleID = cycle.id
                if dataStore.isCycleSimulationActive == false {
                    dataStore.simulateCycle(id: cycle.id)
                }
                selectedCycle = cycle
            }
            .background(
                RoundedRectangle(cornerRadius: 8)
                    .fill(dataStore.selectedCycleID == cycle.id ? Color.accentColor.opacity(0.1) : Color.clear)
            )
    }
    
    private func handleDelete(at indexSet: IndexSet) {
        for index in indexSet {
            if index &lt; dataStore.cycles.count {
                dataStore.deleteCycle(with: dataStore.cycles[index].id)
            }
        }
    }
    
    private var simulationResultsSection: some View {
        Group {
            if dataStore.isCycleSimulationActive, !dataStore.cycleSimulationData.isEmpty {
                Section(header: Text(&quot;Simulation Results&quot;)) {
                    VStack(alignment: .leading) {
                        Text(&quot;Combined Concentration Curve&quot;)
                            .font(.headline)
                            .padding(.bottom, 5)
                        
                        CycleChartView(simulationData: dataStore.cycleSimulationData)
                            .frame(height: 200)
                    }
                    .padding(.vertical)
                }
            }
        }
    }
}

struct CycleRowView: View {
    let cycle: Cycle
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(cycle.name)
                .font(.headline)
            
            HStack {
                Text(&quot;Start: \(formatDate(cycle.startDate))&quot;)
                Spacer()
                Text(&quot;\(cycle.totalWeeks) weeks&quot;)
            }
            .font(.subheadline)
            .foregroundColor(.secondary)
            
            Text(&quot;\(cycle.stages.count) stages&quot;)
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .padding(.vertical, 4)
    }
    
    private func formatDate(_ date: Date) -&gt; String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .none
        return formatter.string(from: date)
    }
}

struct CycleChartView: View {
    let simulationData: [DataPoint]
    
    var body: some View {
        Chart {
            ForEach(simulationData, id: \.time) { dataPoint in
                LineMark(
                    x: .value(&quot;Date&quot;, dataPoint.time),
                    y: .value(&quot;Level&quot;, dataPoint.level)
                )
                .interpolationMethod(.catmullRom)
                .foregroundStyle(Color.blue.gradient)
            }
        }
        .chartXAxis {
            AxisMarks(values: .stride(by: .day, count: 7)) { _ in
                AxisGridLine()
                AxisTick()
                AxisValueLabel(format: .dateTime.day().month())
            }
        }
        .chartYAxis {
            AxisMarks(position: .leading)
        }
    }
}

// Placeholder for Cycle Form View - to be implemented
struct CycleFormView: View {
    @EnvironmentObject var dataStore: AppDataStore
    @Binding var isPresented: Bool
    @State private var cycleName: String = &quot;&quot;
    @State private var startDate: Date = Date()
    @State private var totalWeeks: Int = 12
    @State private var notes: String = &quot;&quot;
    
    var body: some View {
        NavigationView {
            Form {
                Section(header: Text(&quot;Cycle Details&quot;)) {
                    TextField(&quot;Cycle Name&quot;, text: $cycleName)
                    
                    DatePicker(&quot;Start Date&quot;, selection: $startDate, displayedComponents: .date)
                    
                    Stepper(&quot;Duration: \(totalWeeks) weeks&quot;, value: $totalWeeks, in: 1...52)
                    
                    VStack(alignment: .leading) {
                        Text(&quot;Notes&quot;)
                        TextEditor(text: $notes)
                            .frame(minHeight: 100)
                    }
                }
            }
            .navigationTitle(&quot;New Cycle&quot;)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button(&quot;Cancel&quot;) {
                        isPresented = false
                    }
                }
                
                ToolbarItem(placement: .confirmationAction) {
                    Button(&quot;Save&quot;) {
                        saveCycle()
                        isPresented = false
                    }
                    .disabled(cycleName.isEmpty)
                }
            }
        }
    }
    
    private func saveCycle() {
        let newCycle = Cycle(
            name: cycleName,
            startDate: startDate,
            totalWeeks: totalWeeks,
            notes: notes.isEmpty ? nil : notes
        )
        
        dataStore.saveCycle(newCycle)
    }
}

// Placeholder for Cycle Detail View - to be implemented
struct CycleDetailView: View {
    let cycle: Cycle
    @EnvironmentObject var dataStore: AppDataStore
    @State private var isPresentingEditForm = false
    @State private var isPresentingStageForm = false
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: 16) {
                    // Cycle information
                    VStack(alignment: .leading, spacing: 8) {
                        Text(cycle.name)
                            .font(.title)
                            .bold()
                        
                        HStack {
                            Text(&quot;Start: \(formatDate(cycle.startDate))&quot;)
                            Spacer()
                            Text(&quot;End: \(formatDate(cycle.endDate))&quot;)
                        }
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                        
                        if let notes = cycle.notes, !notes.isEmpty {
                            Text(notes)
                                .font(.body)
                                .padding(.top, 4)
                        }
                    }
                    .padding()
                    .background(
                        RoundedRectangle(cornerRadius: 12)
                            .fill(Color(.secondarySystemBackground))
                    )
                    .padding(.horizontal)
                    
                    // Stages Timeline
                    if cycle.stages.isEmpty {
                        emptyStagesView
                    } else {
                        stagesTimelineView
                    }
                    
                    // Simulation Results
                    if dataStore.isCycleSimulationActive, !dataStore.cycleSimulationData.isEmpty {
                        VStack(alignment: .leading, spacing: 8) {
                            Text(&quot;Simulation Results&quot;)
                                .font(.headline)
                                .padding(.bottom, 5)
                            
                            CycleChartView(simulationData: dataStore.cycleSimulationData)
                                .frame(height: 200)
                        }
                        .padding()
                        .background(
                            RoundedRectangle(cornerRadius: 12)
                                .fill(Color(.secondarySystemBackground))
                        )
                        .padding(.horizontal)
                    }
                    
                    Spacer()
                }
                .padding(.vertical)
            }
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .primaryAction) {
                    Button(action: {
                        isPresentingEditForm = true
                    }) {
                        Text(&quot;Edit&quot;)
                    }
                }
                
                ToolbarItem(placement: .primaryAction) {
                    Button(action: {
                        isPresentingStageForm = true
                    }) {
                        Label(&quot;Add Stage&quot;, systemImage: &quot;plus&quot;)
                    }
                }
            }
            .sheet(isPresented: $isPresentingStageForm) {
                CycleStageFormView(isPresented: $isPresentingStageForm, cycle: cycle)
                    .environmentObject(dataStore)
            }
            .sheet(isPresented: $isPresentingEditForm) {
                // TODO: Add edit cycle form here
                Text(&quot;Edit Cycle&quot;)
            }
        }
    }
    
    private var emptyStagesView: some View {
        VStack(spacing: 16) {
            Image(systemName: &quot;calendar.badge.plus&quot;)
                .font(.system(size: 40))
                .foregroundColor(.secondary)
            
            Text(&quot;No Stages Yet&quot;)
                .font(.headline)
            
            Text(&quot;Add stages to build your cycle timeline&quot;)
                .font(.subheadline)
                .multilineTextAlignment(.center)
                .foregroundColor(.secondary)
            
            Button(action: {
                isPresentingStageForm = true
            }) {
                Text(&quot;Add Stage&quot;)
                    .font(.headline)
                    .padding()
                    .background(Color.accentColor)
                    .foregroundColor(.white)
                    .cornerRadius(10)
            }
        }
        .padding()
        .frame(maxWidth: .infinity)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(.secondarySystemBackground))
        )
        .padding(.horizontal)
    }
    
    private var stagesTimelineView: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(&quot;Timeline&quot;)
                .font(.headline)
                .padding(.bottom, 5)
            
            // Timeline visualization will go here
            Text(&quot;Timeline visualization placeholder&quot;)
                .frame(height: 100)
                .frame(maxWidth: .infinity)
                .background(Color.gray.opacity(0.1))
                .cornerRadius(8)
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(.secondarySystemBackground))
        )
        .padding(.horizontal)
    }
    
    private func formatDate(_ date: Date) -&gt; String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .none
        return formatter.string(from: date)
    }
}

struct CyclePlannerView_Previews: PreviewProvider {
    static var previews: some View {
        CyclePlannerView()
            .environmentObject(AppDataStore())
    }
}</file><file path="TestoSim/Views/CycleStageFormView.swift">import SwiftUI

struct CycleStageFormView: View {
    @EnvironmentObject var dataStore: AppDataStore
    @Binding var isPresented: Bool
    
    var cycle: Cycle
    var stageToEdit: CycleStage?
    
    @State private var stageName: String = &quot;&quot;
    @State private var startWeek: Int = 0
    @State private var durationWeeks: Int = 4
    @State private var isPresentingCompoundPicker = false
    @State private var isPresentingBlendPicker = false
    
    // Stage items
    @State private var compounds: [CompoundStageItem] = []
    @State private var blends: [BlendStageItem] = []
    
    // Temporary item being configured
    @State private var tempCompound: Compound?
    @State private var tempBlend: VialBlend?
    @State private var tempDoseMg: Double = 0
    @State private var tempFrequencyDays: Double = 0
    @State private var tempRoute: Compound.Route = .intramuscular
    @State private var isAddingItem = false
    @State private var itemType: ItemType = .compound
    
    enum ItemType {
        case compound, blend
    }
    
    var body: some View {
        NavigationView {
            Form {
                Section(header: Text(&quot;Stage Details&quot;)) {
                    TextField(&quot;Stage Name&quot;, text: $stageName)
                    
                    HStack {
                        Text(&quot;Start Week&quot;)
                        Spacer()
                        Picker(&quot;Start Week&quot;, selection: $startWeek) {
                            ForEach(Array(0..&lt;cycle.totalWeeks), id: \.self) { week in
                                Text(&quot;Week \(week + 1)&quot;).tag(week)
                            }
                        }
                        .pickerStyle(MenuPickerStyle())
                    }
                    
                    Stepper(&quot;Duration: \(durationWeeks) weeks&quot;, value: $durationWeeks, in: 1...max(1, cycle.totalWeeks - startWeek))
                }
                
                Section(header: stageItemsHeader) {
                    if compounds.isEmpty &amp;&amp; blends.isEmpty {
                        Text(&quot;No compounds or blends added&quot;)
                            .foregroundColor(.secondary)
                            .italic()
                    } else {
                        ForEach(compounds) { item in
                            CompoundItemRow(item: item)
                                .contextMenu {
                                    Button(role: .destructive) {
                                        withAnimation {
                                            compounds.removeAll { $0.id == item.id }
                                        }
                                    } label: {
                                        Label(&quot;Delete&quot;, systemImage: &quot;trash&quot;)
                                    }
                                }
                        }
                        
                        ForEach(blends) { item in
                            BlendItemRow(item: item)
                                .contextMenu {
                                    Button(role: .destructive) {
                                        withAnimation {
                                            blends.removeAll { $0.id == item.id }
                                        }
                                    } label: {
                                        Label(&quot;Delete&quot;, systemImage: &quot;trash&quot;)
                                    }
                                }
                        }
                    }
                }
            }
            .navigationTitle(stageToEdit == nil ? &quot;New Stage&quot; : &quot;Edit Stage&quot;)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button(&quot;Cancel&quot;) {
                        isPresented = false
                    }
                }
                
                ToolbarItem(placement: .confirmationAction) {
                    Button(&quot;Save&quot;) {
                        saveStage()
                        isPresented = false
                    }
                    .disabled(stageName.isEmpty || (compounds.isEmpty &amp;&amp; blends.isEmpty))
                }
            }
            .sheet(isPresented: $isPresentingCompoundPicker) {
                CompoundPickerView(selectedCompound: $tempCompound, onCompoundSelected: configureCompound)
            }
            .sheet(isPresented: $isPresentingBlendPicker) {
                BlendPickerView(selectedBlend: $tempBlend, onBlendSelected: configureBlend)
            }
            .sheet(isPresented: $isAddingItem) {
                if itemType == .compound, let compound = tempCompound {
                    ItemConfigurationView(
                        title: &quot;Configure \(compound.fullDisplayName)&quot;,
                        doseMg: $tempDoseMg,
                        frequencyDays: $tempFrequencyDays,
                        route: $tempRoute,
                        onSave: {
                            addCompoundItem()
                            isAddingItem = false
                        },
                        onCancel: {
                            isAddingItem = false
                        }
                    )
                } else if itemType == .blend, let blend = tempBlend {
                    ItemConfigurationView(
                        title: &quot;Configure \(blend.name)&quot;,
                        doseMg: $tempDoseMg,
                        frequencyDays: $tempFrequencyDays,
                        route: $tempRoute,
                        onSave: {
                            addBlendItem()
                            isAddingItem = false
                        },
                        onCancel: {
                            isAddingItem = false
                        }
                    )
                }
            }
            .onAppear {
                initializeForm()
            }
        }
    }
    
    private var stageItemsHeader: some View {
        HStack {
            Text(&quot;Compounds &amp; Blends&quot;)
            
            Spacer()
            
            Menu {
                Button(action: {
                    itemType = .compound
                    isPresentingCompoundPicker = true
                }) {
                    Label(&quot;Add Compound&quot;, systemImage: &quot;pill&quot;)
                }
                
                Button(action: {
                    itemType = .blend
                    isPresentingBlendPicker = true
                }) {
                    Label(&quot;Add Blend&quot;, systemImage: &quot;cross.vial&quot;)
                }
            } label: {
                Image(systemName: &quot;plus&quot;)
            }
        }
    }
    
    private func initializeForm() {
        if let stage = stageToEdit {
            stageName = stage.name
            startWeek = stage.startWeek
            durationWeeks = stage.durationWeeks
            compounds = stage.compounds
            blends = stage.blends
        } else {
            // Find the first available week after any existing stages
            if !cycle.stages.isEmpty {
                let lastStage = cycle.stages.max(by: { $0.startWeek + $0.durationWeeks &lt; $1.startWeek + $1.durationWeeks })
                if let lastStage = lastStage {
                    startWeek = min(lastStage.startWeek + lastStage.durationWeeks, cycle.totalWeeks - 1)
                }
            }
            
            // Default stage name if creating new
            stageName = &quot;Stage \(cycle.stages.count + 1)&quot;
        }
    }
    
    private func saveStage() {
        // Create a new stage or update existing
        var updatedStage: CycleStage
        if let existingStage = stageToEdit {
            // Update existing stage
            updatedStage = existingStage
            updatedStage.name = stageName
            updatedStage.startWeek = startWeek
            updatedStage.durationWeeks = durationWeeks
            updatedStage.compounds = compounds
            updatedStage.blends = blends
            
            // Find and replace in cycle
            var updatedCycle = cycle
            if let index = updatedCycle.stages.firstIndex(where: { $0.id == existingStage.id }) {
                updatedCycle.stages[index] = updatedStage
            }
            
            // Save cycle
            dataStore.saveCycle(updatedCycle)
        } else {
            // Create new stage
            updatedStage = CycleStage(
                name: stageName,
                startWeek: startWeek,
                durationWeeks: durationWeeks,
                compounds: compounds,
                blends: blends
            )
            
            // Add to cycle
            var updatedCycle = cycle
            updatedCycle.stages.append(updatedStage)
            
            // Save cycle
            dataStore.saveCycle(updatedCycle)
        }
    }
    
    private func configureCompound(_ compound: Compound) {
        tempCompound = compound
        
        // Set default values
        if let route = Compound.Route(rawValue: Compound.Route.intramuscular.rawValue) {
            tempRoute = route
        }
        
        // Set default dosage based on compound class
        switch compound.classType {
        case .testosterone:
            tempDoseMg = 100
            tempFrequencyDays = 3.5
        case .trenbolone:
            tempDoseMg = 50
            tempFrequencyDays = 2
        default:
            tempDoseMg = 50
            tempFrequencyDays = 3.5
        }
        
        isPresentingCompoundPicker = false
        isAddingItem = true
    }
    
    private func configureBlend(_ blend: VialBlend) {
        tempBlend = blend
        
        // Set default values
        if let route = Compound.Route(rawValue: Compound.Route.intramuscular.rawValue) {
            tempRoute = route
        }
        
        // Set default values based on blend concentration
        tempDoseMg = 1.0 // Default to 1mL (will be shown as volume)
        tempFrequencyDays = 3.5 // Default to twice weekly
        
        isPresentingBlendPicker = false
        isAddingItem = true
    }
    
    private func addCompoundItem() {
        guard let compound = tempCompound else { return }
        
        let newItem = CompoundStageItem(
            compoundID: compound.id,
            compoundName: compound.fullDisplayName,
            doseMg: tempDoseMg,
            frequencyDays: tempFrequencyDays,
            administrationRoute: tempRoute.rawValue
        )
        
        compounds.append(newItem)
    }
    
    private func addBlendItem() {
        guard let blend = tempBlend else { return }
        
        let newItem = BlendStageItem(
            blendID: blend.id,
            blendName: blend.name,
            doseMg: tempDoseMg,
            frequencyDays: tempFrequencyDays,
            administrationRoute: tempRoute.rawValue
        )
        
        blends.append(newItem)
    }
}

struct CompoundItemRow: View {
    let item: CompoundStageItem
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(item.compoundName)
                .font(.headline)
            
            HStack {
                Text(&quot;\(item.doseMg.isFinite ? Int(item.doseMg) : 0)mg&quot;)
                Spacer()
                Text(&quot;Every \(formatFrequency(item.frequencyDays))&quot;)
            }
            .font(.subheadline)
            .foregroundColor(.secondary)
            
            Text(&quot;Route: \(item.administrationRoute)&quot;)
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .padding(.vertical, 4)
    }
    
    private func formatFrequency(_ days: Double) -&gt; String {
        if days == 1 {
            return &quot;day&quot;
        } else if days == 7 {
            return &quot;week&quot;
        } else if days == 3.5 {
            return &quot;3.5 days&quot;
        } else {
            return &quot;\(days) days&quot;
        }
    }
}

struct BlendItemRow: View {
    let item: BlendStageItem
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(item.blendName)
                .font(.headline)
            
            HStack {
                Text(&quot;\(item.doseMg.isFinite ? Int(item.doseMg) : 0)mg&quot;)
                Spacer()
                Text(&quot;Every \(formatFrequency(item.frequencyDays))&quot;)
            }
            .font(.subheadline)
            .foregroundColor(.secondary)
            
            Text(&quot;Route: \(item.administrationRoute)&quot;)
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .padding(.vertical, 4)
    }
    
    private func formatFrequency(_ days: Double) -&gt; String {
        if days == 1 {
            return &quot;day&quot;
        } else if days == 7 {
            return &quot;week&quot;
        } else if days == 3.5 {
            return &quot;3.5 days&quot;
        } else {
            return &quot;\(days) days&quot;
        }
    }
}

struct ItemConfigurationView: View {
    let title: String
    @Binding var doseMg: Double
    @Binding var frequencyDays: Double
    @Binding var route: Compound.Route
    let onSave: () -&gt; Void
    let onCancel: () -&gt; Void
    
    var body: some View {
        NavigationView {
            Form {
                Section(header: Text(&quot;Dosage&quot;)) {
                    Stepper(value: $doseMg, in: 10...500, step: 10) {
                        Text(&quot;Dose: \(doseMg.isFinite ? Int(doseMg) : 0)mg&quot;)
                    }
                }
                
                Section(header: Text(&quot;Frequency&quot;)) {
                    Picker(&quot;Frequency&quot;, selection: $frequencyDays) {
                        Text(&quot;Daily&quot;).tag(1.0)
                        Text(&quot;Every other day&quot;).tag(2.0)
                        Text(&quot;Twice weekly&quot;).tag(3.5)
                        Text(&quot;Weekly&quot;).tag(7.0)
                        Text(&quot;Every 2 weeks&quot;).tag(14.0)
                    }
                    .pickerStyle(InlinePickerStyle())
                }
                
                Section(header: Text(&quot;Route&quot;)) {
                    Picker(&quot;Administration Route&quot;, selection: $route) {
                        Text(&quot;Intramuscular&quot;).tag(Compound.Route.intramuscular)
                        Text(&quot;Subcutaneous&quot;).tag(Compound.Route.subcutaneous)
                        Text(&quot;Oral&quot;).tag(Compound.Route.oral)
                        Text(&quot;Transdermal&quot;).tag(Compound.Route.transdermal)
                    }
                    .pickerStyle(InlinePickerStyle())
                }
            }
            .navigationTitle(title)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button(&quot;Cancel&quot;, action: onCancel)
                }
                
                ToolbarItem(placement: .confirmationAction) {
                    Button(&quot;Save&quot;, action: onSave)
                }
            }
        }
    }
}

// Compound Picker View (simplified version)
struct CompoundPickerView: View {
    @EnvironmentObject var dataStore: AppDataStore
    @Binding var selectedCompound: Compound?
    let onCompoundSelected: (Compound) -&gt; Void
    
    var body: some View {
        NavigationView {
            List {
                ForEach(dataStore.compoundLibrary.compounds) { compound in
                    Button(action: {
                        selectedCompound = compound
                        onCompoundSelected(compound)
                    }) {
                        HStack {
                            Text(compound.fullDisplayName)
                            Spacer()
                            if selectedCompound?.id == compound.id {
                                Image(systemName: &quot;checkmark&quot;)
                                    .foregroundColor(.accentColor)
                            }
                        }
                    }
                    .buttonStyle(PlainButtonStyle())
                }
            }
            .navigationTitle(&quot;Select Compound&quot;)
        }
    }
}

// Blend Picker View (simplified version)
struct BlendPickerView: View {
    @EnvironmentObject var dataStore: AppDataStore
    @Binding var selectedBlend: VialBlend?
    let onBlendSelected: (VialBlend) -&gt; Void
    
    var body: some View {
        NavigationView {
            List {
                ForEach(dataStore.compoundLibrary.blends) { blend in
                    Button(action: {
                        selectedBlend = blend
                        onBlendSelected(blend)
                    }) {
                        HStack {
                            VStack(alignment: .leading) {
                                Text(blend.name)
                                    .font(.headline)
                                Text(blend.compositionDescription(using: dataStore.compoundLibrary))
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            Spacer()
                            if selectedBlend?.id == blend.id {
                                Image(systemName: &quot;checkmark&quot;)
                                    .foregroundColor(.accentColor)
                            }
                        }
                    }
                    .buttonStyle(PlainButtonStyle())
                }
            }
            .navigationTitle(&quot;Select Blend&quot;)
        }
    }
}</file><file path="TestoSim/ContentView.swift">//
//  ContentView.swift
//  TestoSim
//
//  Created by Jesper Vang on 01/05/2025.
//

import SwiftUI

struct ContentView: View {
    @EnvironmentObject var dataStore: AppDataStore
    
    var body: some View {
        TabView {
            NavigationStack {
                ProtocolListView()
            }
            .tabItem {
                Label(&quot;Protocols&quot;, systemImage: &quot;list.bullet&quot;)
            }
            
            NavigationStack {
                CyclePlannerView()
            }
            .tabItem {
                Label(&quot;Cycles&quot;, systemImage: &quot;calendar&quot;)
            }
            
            NavigationStack {
                AIInsightsView()
            }
            .tabItem {
                Label(&quot;Insights&quot;, systemImage: &quot;lightbulb&quot;)
            }
            
            NavigationStack {
                ProfileView()
            }
            .tabItem {
                Label(&quot;Profile&quot;, systemImage: &quot;person&quot;)
            }
        }
    }
}

#Preview {
    ContentView()
        .environmentObject(AppDataStore())
}</file><file path="TestoSim/TestoSim.entitlements">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
&lt;plist version=&quot;1.0&quot;&gt;
&lt;dict&gt;
    &lt;key&gt;com.apple.security.app-sandbox&lt;/key&gt;
    &lt;true/&gt;
    &lt;key&gt;com.apple.security.files.user-selected.read-only&lt;/key&gt;
    &lt;true/&gt;
    &lt;key&gt;com.apple.developer.icloud-container-identifiers&lt;/key&gt;
    &lt;array&gt;
        &lt;string&gt;iCloud.flight505.TestoSim&lt;/string&gt;
    &lt;/array&gt;
    &lt;key&gt;com.apple.developer.icloud-services&lt;/key&gt;
    &lt;array&gt;
        &lt;string&gt;CloudKit&lt;/string&gt;
    &lt;/array&gt;
&lt;/dict&gt;
&lt;/plist&gt;</file><file path="copy-config.sh">#!/bin/bash

# Copy xcconfig file if needed
CONFIG_XCCONFIG_PATH=&quot;$SRCROOT/TestoSim/Config.xcconfig&quot;
SAMPLE_XCCONFIG_PATH=&quot;$SRCROOT/TestoSim/Config-Sample.xcconfig&quot;

if [ -f &quot;$CONFIG_XCCONFIG_PATH&quot; ]; then
  echo &quot;$CONFIG_XCCONFIG_PATH exists.&quot;
else
  echo &quot;$CONFIG_XCCONFIG_PATH does not exist, copying sample&quot;
  cp -v &quot;${SAMPLE_XCCONFIG_PATH}&quot; &quot;${CONFIG_XCCONFIG_PATH}&quot;
fi

# Copy plist file if needed
CONFIG_PLIST_PATH=&quot;$SRCROOT/TestoSim/Config.plist&quot;
SAMPLE_PLIST_PATH=&quot;$SRCROOT/TestoSim/Config-Sample.plist&quot;

if [ -f &quot;$CONFIG_PLIST_PATH&quot; ]; then
  echo &quot;$CONFIG_PLIST_PATH exists.&quot;
else
  echo &quot;$CONFIG_PLIST_PATH does not exist, copying sample&quot;
  cp -v &quot;${SAMPLE_PLIST_PATH}&quot; &quot;${CONFIG_PLIST_PATH}&quot;
fi</file><file path="TestoSim/Models/ProfileModel.swift">import Foundation

struct UserProfile: Codable {
    var id: UUID = UUID()
    var name: String = &quot;My Profile&quot;
    var unit: String = &quot;ng/dL&quot; // Default unit
    var calibrationFactor: Double = 1.0 // Default calibration
    var protocols: [InjectionProtocol] = []
    
    // New parameters for Story 9 and 10
    var dateOfBirth: Date?
    var heightCm: Double?
    var weight: Double? = 70.0 // Default weight in kg
    
    enum BiologicalSex: String, Codable, CaseIterable {
        case male, female
    }
    var biologicalSex: BiologicalSex = .male
    
    var usesICloudSync: Bool = false
    
    // PK Model settings - always use the more accurate two-compartment model
    var useTwoCompartmentModel: Bool = true
    
    // Computed property for body surface area (DuBois formula)
    var bodySurfaceArea: Double? {
        guard let weight = weight, let heightCm = heightCm else {
            return nil
        }
        // DuBois formula: BSA (m²) = 0.007184 × height(cm)^0.725 × weight(kg)^0.425
        return 0.007184 * pow(heightCm, 0.725) * pow(weight, 0.425)
    }
    
    // Computed property for age
    var age: Int? {
        guard let dob = dateOfBirth else {
            return nil
        }
        let calendar = Calendar.current
        let ageComponents = calendar.dateComponents([.year], from: dob, to: Date())
        return ageComponents.year
    }
}</file><file path="TestoSim/Models/ProtocolModel.swift">import Foundation

struct InjectionProtocol: Identifiable, Codable {
    var id: UUID = UUID()
    var name: String
    var doseMg: Double
    var frequencyDays: Double
    var startDate: Date
    var notes: String?
    var bloodSamples: [BloodSample] = []
    
    // Properties for compound/blend support
    var compoundID: UUID?
    var blendID: UUID?
    var selectedRoute: String? // Stores Compound.Route.rawValue
    
    // Computed property to determine protocol type
    var protocolType: ProtocolType {
        if compoundID != nil {
            return .compound
        } else if blendID != nil {
            return .blend
        } else {
            // This should not happen in new protocols
            return .compound // Default to compound
        }
    }
    
    // MARK: - Injection dates calculation
    
    func injectionDates(from simulationStartDate: Date, upto endDate: Date) -&gt; [Date] {
        var dates: [Date] = []
        var current = startDate
        var injectionIndex = 0
        
        // Check for zero/negative frequency to avoid infinite loop
        guard frequencyDays &gt; 0 else {
            // For zero/negative frequency, just include the start date if it&apos;s in range
            if startDate &lt;= endDate &amp;&amp; startDate &gt;= simulationStartDate {
                dates.append(startDate)
            }
            return dates
        }
        
        // Calculate how many injections would have occurred before the simulation start
        // by determining the injection index offset
        if simulationStartDate &gt; startDate {
            let daysSinceStart = simulationStartDate.timeIntervalSince(startDate) / (24 * 3600)
            injectionIndex = Int(floor(daysSinceStart / frequencyDays))
            // Set current to the first injection that&apos;s on or after simulationStartDate
            current = startDate.addingTimeInterval(Double(injectionIndex) * frequencyDays * 24 * 3600)
        }
        
        // Now add all injections from current date up to endDate
        while current &lt;= endDate {
            dates.append(current)
            
            injectionIndex += 1
            current = startDate.addingTimeInterval(Double(injectionIndex) * frequencyDays * 24 * 3600)
            
            // Safety break to prevent infinite loops
            if injectionIndex &gt; 10000 { 
                print(&quot;Safety break in injection dates calculation&quot;)
                break 
            }
        }
        
        return dates
    }
}

// MARK: - Protocol type enum

enum ProtocolType: String, Codable {
    case compound    // Using single Compound
    case blend       // Using VialBlend
}</file><file path="TestoSim/ViewModels/AIInsightsGenerator.swift">import Foundation
import SwiftUI

/// Generates AI-powered insights for user&apos;s protocols and cycles
class AIInsightsGenerator: ObservableObject {
    // MARK: - Published Properties
    
    /// Whether an insight request is currently in progress
    @Published var isLoading = false
    
    /// Latest generated insights
    @Published var latestInsights: Insights?
    
    /// Any error that occurred during the last insight generation
    @Published var error: Error?
    
    // MARK: - Private Properties
    
    /// API Service for OpenAI
    private let openAIService = OpenAIService.shared
    
    /// Cache to store generated insights for each protocol
    private var insightsCache: [UUID: Insights] = [:]
    
    // MARK: - Initialization
    
    init() {
        // Initialization doesn&apos;t require anything specific
    }
    
    // MARK: - Public Methods
    
    /// Generate insights for a specific protocol
    /// - Parameters:
    ///   - protocol: The protocol to analyze
    ///   - profile: User profile data
    ///   - simulationData: Simulation data points
    ///   - compoundLibrary: Reference to compound library
    ///   - forceRefresh: Whether to force a refresh instead of using cached insights
    func generateInsights(
        for treatmentProtocol: InjectionProtocol,
        profile: UserProfile,
        simulationData: [DataPoint],
        compoundLibrary: CompoundLibrary,
        forceRefresh: Bool = false
    ) {
        // Check cache first unless refresh is forced
        if !forceRefresh, let cachedInsights = insightsCache[treatmentProtocol.id] {
            self.latestInsights = cachedInsights
            return
        }
        
        isLoading = true
        error = nil
        
        // Check if OpenAI API key is available
        if openAIService.hasAPIKey() {
            // Use OpenAI service for real insights
            openAIService.generateProtocolInsights(
                treatmentProtocol: treatmentProtocol,
                profile: profile,
                simulationData: simulationData,
                compoundLibrary: compoundLibrary
            ) { [weak self] result in
                DispatchQueue.main.async {
                    guard let self = self else { return }
                    
                    self.isLoading = false
                    
                    switch result {
                    case .success(let insights):
                        // Cache the insights
                        self.insightsCache[treatmentProtocol.id] = insights
                        self.latestInsights = insights
                        
                    case .failure(let error):
                        self.error = error
                        // Fall back to mock insights if API call fails
                        self.generateMockInsights(for: treatmentProtocol, profile: profile, simulationData: simulationData, compoundLibrary: compoundLibrary)
                    }
                }
            }
        } else {
            // Use mock implementation when API key is not available
            generateMockInsights(for: treatmentProtocol, profile: profile, simulationData: simulationData, compoundLibrary: compoundLibrary)
        }
    }
    
    /// Generate insights for a cycle
    /// - Parameters:
    ///   - cycle: The cycle to analyze
    ///   - profile: User profile data
    ///   - simulationData: Cycle simulation data points
    ///   - compoundLibrary: Reference to compound library
    ///   - forceRefresh: Whether to force a refresh instead of using cached insights
    func generateCycleInsights(
        for cycle: Cycle,
        profile: UserProfile,
        simulationData: [DataPoint],
        compoundLibrary: CompoundLibrary,
        forceRefresh: Bool = false
    ) {
        // Check cache first unless refresh is forced
        if !forceRefresh, let cachedInsights = insightsCache[cycle.id] {
            self.latestInsights = cachedInsights
            return
        }
        
        isLoading = true
        error = nil
        
        // Check if OpenAI API key is available
        if openAIService.hasAPIKey() {
            // Use OpenAI service for real insights
            openAIService.generateCycleInsights(
                cycle: cycle,
                profile: profile,
                simulationData: simulationData,
                compoundLibrary: compoundLibrary
            ) { [weak self] result in
                DispatchQueue.main.async {
                    guard let self = self else { return }
                    
                    self.isLoading = false
                    
                    switch result {
                    case .success(let insights):
                        // Cache the insights
                        self.insightsCache[cycle.id] = insights
                        self.latestInsights = insights
                        
                    case .failure(let error):
                        self.error = error
                        // Fall back to mock insights if API call fails
                        self.generateMockCycleInsights(for: cycle, profile: profile, simulationData: simulationData, compoundLibrary: compoundLibrary)
                    }
                }
            }
        } else {
            // Use mock implementation when API key is not available
            generateMockCycleInsights(for: cycle, profile: profile, simulationData: simulationData, compoundLibrary: compoundLibrary)
        }
    }
    
    /// Clear all cached insights
    func clearCache() {
        insightsCache.removeAll()
        latestInsights = nil
    }
    
    /// Refreshes insights after API key change
    func refreshAfterAPIKeyChange() {
        // Clear the cache to force a refresh on next request
        clearCache()
        
        // Reset any error state
        error = nil
        
        // Clear the latest insights to prompt a new request
        latestInsights = nil
    }
    
    // MARK: - Private Methods
    
    /// Mock implementation for generating insights
    private func generateMockInsights(
        for treatmentProtocol: InjectionProtocol,
        profile: UserProfile,
        simulationData: [DataPoint],
        compoundLibrary: CompoundLibrary
    ) {
        // Simulate network delay
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) { [weak self] in
            guard let self = self else { return }
            
            // Create mock insights based on protocol type
            let insights = self.createMockInsightsForProtocol(treatmentProtocol, profile: profile, simulationData: simulationData, compoundLibrary: compoundLibrary)
            
            // Cache the insights
            self.insightsCache[treatmentProtocol.id] = insights
            
            // Update published properties
            self.latestInsights = insights
            self.isLoading = false
        }
    }
    
    /// Mock implementation for generating cycle insights
    private func generateMockCycleInsights(
        for cycle: Cycle,
        profile: UserProfile,
        simulationData: [DataPoint],
        compoundLibrary: CompoundLibrary
    ) {
        // Simulate network delay
        DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) { [weak self] in
            guard let self = self else { return }
            
            // Create mock insights for the cycle
            let insights = self.createMockInsightsForCycle(cycle, profile: profile, simulationData: simulationData, compoundLibrary: compoundLibrary)
            
            // Cache the insights
            self.insightsCache[cycle.id] = insights
            
            // Update published properties
            self.latestInsights = insights
            self.isLoading = false
        }
    }
    
    /// Creates mock insights for a protocol
    private func createMockInsightsForProtocol(
        _ treatmentProtocol: InjectionProtocol,
        profile: UserProfile,
        simulationData: [DataPoint],
        compoundLibrary: CompoundLibrary
    ) -&gt; Insights {
        // Extract protocol details
        let protocolType = treatmentProtocol.protocolType
        let protocolName = treatmentProtocol.name
        var compoundOrBlendName = &quot;Unknown&quot;
        
        // Determine the compound or blend name
        if protocolType == .compound, let compoundID = treatmentProtocol.compoundID,
           let compound = compoundLibrary.compounds.first(where: { $0.id == compoundID }) {
            compoundOrBlendName = compound.commonName
            if let ester = compound.ester {
                compoundOrBlendName += &quot; \(ester)&quot;
            }
        } else if protocolType == .blend, let blendID = treatmentProtocol.blendID,
                  let blend = compoundLibrary.blends.first(where: { $0.id == blendID }) {
            compoundOrBlendName = blend.name
        }
        
        // Get simulation statistics
        let maxLevel = simulationData.map { $0.level }.max() ?? 0
        let minLevel = simulationData.map { $0.level }.min() ?? 0
        let avgLevel = simulationData.map { $0.level }.reduce(0, +) / Double(max(1, simulationData.count))
        let fluctuation = maxLevel &gt; 0 ? (maxLevel - minLevel) / maxLevel * 100 : 0
        
        // Generate insights based on protocol characteristics
        var insights = Insights(
            title: &quot;Insights for \(protocolName)&quot;,
            summary: &quot;Analysis of your \(compoundOrBlendName) protocol.&quot;,
            keyPoints: []
        )
        
        // Add blend explanation if it&apos;s a blend
        if protocolType == .blend {
            insights.blendExplanation = createMockBlendExplanation(treatmentProtocol, compoundLibrary: compoundLibrary)
        }
        
        // Add key points based on protocol characteristics
        
        // 1. Frequency point
        if treatmentProtocol.frequencyDays &gt;= 7 {
            insights.keyPoints.append(
                KeyPoint(
                    title: &quot;Consider splitting your dose&quot;,
                    description: &quot;Your current injection frequency of every \(treatmentProtocol.frequencyDays) days leads to significant hormone fluctuations. Consider splitting your total dose into smaller, more frequent injections to achieve more stable hormone levels.&quot;,
                    type: .suggestion
                )
            )
        } else if treatmentProtocol.frequencyDays &lt;= 2 {
            insights.keyPoints.append(
                KeyPoint(
                    title: &quot;Good injection frequency&quot;,
                    description: &quot;Your frequent injection schedule of every \(treatmentProtocol.frequencyDays) days helps maintain stable hormone levels with minimal fluctuations.&quot;,
                    type: .positive
                )
            )
        }
        
        // 2. Fluctuation point
        if fluctuation &gt; 40 {
            insights.keyPoints.append(
                KeyPoint(
                    title: &quot;High level fluctuation&quot;,
                    description: &quot;Your current protocol results in approximately \(fluctuation.isFinite ? Int(fluctuation) : 0)% fluctuation between peak and trough levels, which may lead to inconsistent symptoms and effects.&quot;,
                    type: .warning
                )
            )
        } else if fluctuation &lt; 20 {
            insights.keyPoints.append(
                KeyPoint(
                    title: &quot;Stable hormone levels&quot;,
                    description: &quot;Your protocol achieves excellent stability with only \(fluctuation.isFinite ? Int(fluctuation) : 0)% fluctuation between peak and trough levels.&quot;,
                    type: .positive
                )
            )
        }
        
        // 3. Overall level point
        let targetMin = 400.0 // Example target minimum
        let targetMax = 1000.0 // Example target maximum
        if avgLevel &lt; targetMin {
            insights.keyPoints.append(
                KeyPoint(
                    title: &quot;Levels below typical target range&quot;,
                    description: &quot;Your average level of \(avgLevel.isFinite ? Int(avgLevel) : 0) ng/dL is below the typical target range of \(targetMin.isFinite ? Int(targetMin) : 0)-\(targetMax.isFinite ? Int(targetMax) : 0) ng/dL. Consider discussing a dosage adjustment with your healthcare provider.&quot;,
                    type: .warning
                )
            )
        } else if avgLevel &gt; targetMax {
            insights.keyPoints.append(
                KeyPoint(
                    title: &quot;Levels above typical target range&quot;,
                    description: &quot;Your average level of \(avgLevel.isFinite ? Int(avgLevel) : 0) ng/dL is above the typical target range of \(targetMin.isFinite ? Int(targetMin) : 0)-\(targetMax.isFinite ? Int(targetMax) : 0) ng/dL. Consider discussing potential side effects and benefits with your healthcare provider.&quot;,
                    type: .warning
                )
            )
        } else {
            insights.keyPoints.append(
                KeyPoint(
                    title: &quot;Levels within typical target range&quot;,
                    description: &quot;Your average level of \(avgLevel.isFinite ? Int(avgLevel) : 0) ng/dL falls within the typical target range of \(targetMin.isFinite ? Int(targetMin) : 0)-\(targetMax.isFinite ? Int(targetMax) : 0) ng/dL.&quot;,
                    type: .positive
                )
            )
        }
        
        return insights
    }
    
    /// Creates mock insights for a cycle
    private func createMockInsightsForCycle(
        _ cycle: Cycle,
        profile: UserProfile,
        simulationData: [DataPoint],
        compoundLibrary: CompoundLibrary
    ) -&gt; Insights {
        // Extract cycle details
        let cycleName = cycle.name
        let totalWeeks = cycle.totalWeeks
        let stageCount = cycle.stages.count
        
        // Generate summary of compounds and blends used in the cycle
        var compoundsUsed = Set&lt;String&gt;()
        var blendsUsed = Set&lt;String&gt;()
        
        for stage in cycle.stages {
            for compoundItem in stage.compounds {
                if let compound = compoundLibrary.compounds.first(where: { $0.id == compoundItem.compoundID }) {
                    compoundsUsed.insert(compound.commonName)
                }
            }
            
            for blendItem in stage.blends {
                if let blend = compoundLibrary.blends.first(where: { $0.id == blendItem.blendID }) {
                    blendsUsed.insert(blend.name)
                }
            }
        }
        
        // Get simulation statistics
        let maxLevel = simulationData.map { $0.level }.max() ?? 0
        let _ = simulationData.map { $0.level }.min() ?? 0
        let _ = simulationData.map { $0.level }.reduce(0, +) / Double(max(1, simulationData.count))
        
        // Generate insights for the cycle
        var insights = Insights(
            title: &quot;Cycle Analysis: \(cycleName)&quot;,
            summary: &quot;Analysis of your \(totalWeeks)-week cycle with \(stageCount) stages.&quot;,
            keyPoints: []
        )
        
        // 1. Cycle structure point
        insights.keyPoints.append(
            KeyPoint(
                title: &quot;Cycle Structure&quot;,
                description: &quot;Your cycle spans \(totalWeeks) weeks with \(stageCount) distinct stages, using \(compoundsUsed.count) compounds and \(blendsUsed.count) blends.&quot;,
                type: .information
            )
        )
        
        // 2. Compound/blend usage point
        if !compoundsUsed.isEmpty || !blendsUsed.isEmpty {
            let compoundsList = compoundsUsed.joined(separator: &quot;, &quot;)
            let blendsList = blendsUsed.joined(separator: &quot;, &quot;)
            
            var description = &quot;This cycle utilizes &quot;
            if !compoundsUsed.isEmpty {
                description += &quot;the following compounds: \(compoundsList)&quot;
            }
            if !compoundsUsed.isEmpty &amp;&amp; !blendsUsed.isEmpty {
                description += &quot; and &quot;
            }
            if !blendsUsed.isEmpty {
                description += &quot;the following blends: \(blendsList)&quot;
            }
            
            insights.keyPoints.append(
                KeyPoint(
                    title: &quot;Compounds and Blends&quot;,
                    description: description,
                    type: .information
                )
            )
        }
        
        // 3. Level analysis point
        let targetMax = 1000.0 // Example target maximum
        if maxLevel &gt; targetMax * 1.5 {
            insights.keyPoints.append(
                KeyPoint(
                    title: &quot;Very high peak levels&quot;,
                    description: &quot;This cycle produces a maximum concentration of \(maxLevel.isFinite ? Int(maxLevel) : 0) ng/dL, which is significantly above the typical target range. Consider reducing dosages during peak periods.&quot;,
                    type: .warning
                )
            )
        } else if maxLevel &gt; targetMax {
            insights.keyPoints.append(
                KeyPoint(
                    title: &quot;Elevated peak levels&quot;,
                    description: &quot;This cycle produces a maximum concentration of \(maxLevel.isFinite ? Int(maxLevel) : 0) ng/dL, which is above the typical target maximum of \(targetMax.isFinite ? Int(targetMax) : 0) ng/dL.&quot;,
                    type: .warning
                )
            )
        }
        
        // 4. Recovery suggestion if appropriate
        if totalWeeks &gt; 12 {
            insights.keyPoints.append(
                KeyPoint(
                    title: &quot;Consider post-cycle recovery&quot;,
                    description: &quot;Your cycle duration of \(totalWeeks) weeks is relatively long. Consider implementing a proper post-cycle recovery protocol to help restore natural hormone production.&quot;,
                    type: .suggestion
                )
            )
        }
        
        return insights
    }
    
    /// Creates a mock blend explanation
    private func createMockBlendExplanation(_ treatmentProtocol: InjectionProtocol, compoundLibrary: CompoundLibrary) -&gt; String? {
        guard treatmentProtocol.protocolType == .blend,
              let blendID = treatmentProtocol.blendID,
              let blend = compoundLibrary.blends.first(where: { $0.id == blendID }) else {
            return nil
        }
        
        // Get the components of the blend
        let components = blend.resolvedComponents(using: compoundLibrary)
        
        // Return nil if there are no components
        if components.isEmpty {
            return nil
        }
        
        // Create the explanation
        var explanation = &quot;\(blend.name) contains \(components.count) different compounds:\n\n&quot;
        
        // Sort components by half-life
        let sortedComponents = components.sorted { $0.compound.halfLifeDays &lt; $1.compound.halfLifeDays }
        
        // Add component descriptions
        for component in sortedComponents {
            let percentage = (component.mgPerML / blend.totalConcentration) * 100
            let halfLife = component.compound.halfLifeDays
            
            explanation += &quot;• \(component.compound.commonName)&quot;
            if let ester = component.compound.ester {
                explanation += &quot; \(ester)&quot;
            }
            explanation += &quot; (\(component.mgPerML.isFinite ? Int(component.mgPerML) : 0) mg/ml, approx. \(percentage.isFinite ? Int(percentage) : 0)%) - &quot;
            
            // Describe the expected behavior
            if halfLife &lt; 1.0 {
                explanation += &quot;Very fast-acting with a half-life of \(String(format: &quot;%.1f&quot;, halfLife)) days, providing an initial spike in hormone levels.\n&quot;
            } else if halfLife &lt; 3.0 {
                explanation += &quot;Fast-acting with a half-life of \(String(format: &quot;%.1f&quot;, halfLife)) days, providing relatively quick effects.\n&quot;
            } else if halfLife &lt; 7.0 {
                explanation += &quot;Medium-acting with a half-life of \(String(format: &quot;%.1f&quot;, halfLife)) days, providing balanced release.\n&quot;
            } else {
                explanation += &quot;Long-acting with a half-life of \(String(format: &quot;%.1f&quot;, halfLife)) days, providing extended release of hormone levels.\n&quot;
            }
        }
        
        // Add overall blend characteristics
        let shortActingCount = sortedComponents.filter { $0.compound.halfLifeDays &lt; 3.0 }.count
        let longActingCount = sortedComponents.filter { $0.compound.halfLifeDays &gt;= 7.0 }.count
        
        explanation += &quot;\nOverall characteristics: &quot;
        
        if shortActingCount &gt; 0 &amp;&amp; longActingCount &gt; 0 {
            explanation += &quot;This blend is designed to provide both immediate effects (from the shorter-acting compounds) and sustained release (from the longer-acting compounds), creating a balanced hormone profile over time.&quot;
        } else if shortActingCount &gt; 0 {
            explanation += &quot;This blend is primarily designed for quick onset of action, with effects becoming noticeable rapidly after injection.&quot;
        } else if longActingCount &gt; 0 {
            explanation += &quot;This blend is designed for stable, long-term release with minimal fluctuations, requiring less frequent injections.&quot;
        } else {
            explanation += &quot;This blend provides a balanced release profile with moderate onset and duration of action.&quot;
        }
        
        return explanation
    }
    
    /// Real implementation would make an API call to OpenAI
    private func makeOpenAIAPICall(
        for treatmentProtocol: InjectionProtocol,
        profile: UserProfile,
        simulationData: [DataPoint],
        compoundLibrary: CompoundLibrary,
        completion: @escaping (Result&lt;Insights, Error&gt;) -&gt; Void
    ) {
        // This would be implemented with actual API calls in a production version
        // For now, this is just a placeholder
        
        // 1. Construct the request data
        // 2. Make API call to OpenAI
        // 3. Process the response
        // 4. Return the insights
    }
}

// MARK: - Insights Model

/// Represents AI-generated insights
struct Insights {
    /// Title of the insights
    var title: String
    
    /// Summary paragraph
    var summary: String
    
    /// Detailed explanation for blend protocols
    var blendExplanation: String?
    
    /// Key points of the insights
    var keyPoints: [KeyPoint]
}

/// Represents a key point in the insights
struct KeyPoint {
    /// Title of the key point
    var title: String
    
    /// Detailed description
    var description: String
    
    /// Type of key point
    var type: KeyPointType
    
    /// Type of key point
    enum KeyPointType {
        case information
        case positive
        case warning
        case suggestion
    }
}</file><file path="TestoSim/Views/AddBloodworkView.swift">import SwiftUI

struct AddBloodworkView: View {
    @EnvironmentObject var dataStore: AppDataStore
    @Environment(\.dismiss) var dismiss
    
    var injectionProtocol: InjectionProtocol
    
    @State private var bloodValue: String = &quot;&quot;
    @State private var bloodDate: Date = Date()
    @State private var notes: String = &quot;&quot;
    
    @State private var showingAlert = false
    @State private var alertMessage = &quot;&quot;
    
    var body: some View {
        NavigationStack {
            Form {
                Section(&quot;Sample Details&quot;) {
                    TextField(&quot;Blood Level Value (\(dataStore.profile.unit))&quot;, text: $bloodValue)
                        .keyboardType(.numbersAndPunctuation)
                    
                    DatePicker(&quot;Sample Date&quot;, selection: $bloodDate, displayedComponents: [.date, .hourAndMinute])
                }
                
                Section(&quot;Notes&quot;) {
                    TextEditor(text: $notes)
                        .frame(minHeight: 100)
                }
                
                Section(&quot;Actions&quot;) {
                    Button(&quot;Add Sample and Calibrate&quot;) {
                        saveBloodwork(andCalibrate: true)
                    }
                    .frame(maxWidth: .infinity)
                    .foregroundColor(.white)
                    .padding()
                    .background(Color.blue)
                    .cornerRadius(10)
                    
                    Button(&quot;Add Sample Only&quot;) {
                        saveBloodwork(andCalibrate: false)
                    }
                    .frame(maxWidth: .infinity)
                    .foregroundColor(.white)
                    .padding()
                    .background(Color.green)
                    .cornerRadius(10)
                }
            }
            .navigationTitle(&quot;Add Blood Sample&quot;)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button(&quot;Cancel&quot;) {
                        dismiss()
                    }
                }
            }
            .alert(alertMessage, isPresented: $showingAlert) {
                Button(&quot;OK&quot;, role: .cancel) { }
            }
        }
    }
    
    private func saveBloodwork(andCalibrate: Bool) {
        guard let valueDouble = Double(bloodValue) else {
            alertMessage = &quot;Please enter a valid number for the blood level&quot;
            showingAlert = true
            return
        }
        
        // Create a new sample
        let newSample = BloodSample(
            date: bloodDate,
            value: valueDouble,
            unit: dataStore.profile.unit
        )
        
        // Add to the protocol
        var updatedProtocol = injectionProtocol
        updatedProtocol.bloodSamples.append(newSample)
        
        // Save back to the data store
        dataStore.updateProtocol(updatedProtocol)
        
        // If requested, perform calibration
        if andCalibrate {
            dataStore.calibrateProtocol(updatedProtocol)
        }
        
        dismiss()
    }
}

#Preview {
    AddBloodworkView(injectionProtocol: InjectionProtocol(
        name: &quot;Test Protocol&quot;,
        doseMg: 100,
        frequencyDays: 7,
        startDate: Date().addingTimeInterval(-30 * 24 * 3600) // 30 days ago
    ))
    .environmentObject(AppDataStore())
}</file><file path="TestoSim/Views/ProtocolListView.swift">import SwiftUI

struct ProtocolListView: View {
    @EnvironmentObject var dataStore: AppDataStore
    
    var body: some View {
        List {
            if dataStore.profile.protocols.isEmpty {
                Text(&quot;No protocols yet. Tap + to add one.&quot;)
                    .foregroundColor(.secondary)
            } else {
                ForEach(dataStore.profile.protocols) { injectionProtocol in
                    NavigationLink(destination: ProtocolDetailView(injectionProtocol: injectionProtocol)) {
                        protocolRowContent(for: injectionProtocol)
                    }
                }
                .onDelete(perform: deleteItems)
            }
        }
        .navigationTitle(&quot;Protocols&quot;)
        .toolbar {
            toolbarContent
        }
        .sheet(isPresented: $dataStore.isPresentingProtocolForm) {
            ProtocolFormView(protocolToEdit: dataStore.protocolToEdit)
                .environmentObject(dataStore)
        }
    }
    
    // Extracted toolbar content
    private var toolbarContent: some ToolbarContent {
        Group {
            ToolbarItem(placement: .automatic) {
                NavigationLink(destination: ProfileView()) {
                    Label(&quot;Profile&quot;, systemImage: &quot;person.circle&quot;)
                }
            }
            ToolbarItem(placement: .primaryAction) {
                Button {
                    dataStore.protocolToEdit = nil
                    dataStore.isPresentingProtocolForm = true
                } label: {
                    Label(&quot;Add Protocol&quot;, systemImage: &quot;plus&quot;)
                }
            }
        }
    }
    
    // Extracted protocol row content
    private func protocolRowContent(for injectionProtocol: InjectionProtocol) -&gt; some View {
        VStack(alignment: .leading) {
            Text(injectionProtocol.name)
                .font(.headline)
            
            // Summary text based on protocol type
            Group {
                switch injectionProtocol.protocolType {
                case .compound:
                    if let compoundID = injectionProtocol.compoundID,
                       let compound = dataStore.compoundLibrary.compound(withID: compoundID) {
                        Text(&quot;\(injectionProtocol.doseMg, format: .number.precision(.fractionLength(0))) mg \(compound.fullDisplayName) every \(injectionProtocol.frequencyDays, format: .number.precision(.fractionLength(1))) days&quot;)
                    } else {
                        Text(&quot;\(injectionProtocol.doseMg, format: .number.precision(.fractionLength(0))) mg every \(injectionProtocol.frequencyDays, format: .number.precision(.fractionLength(1))) days&quot;)
                    }
                    
                case .blend:
                    if let blendID = injectionProtocol.blendID,
                       let blend = dataStore.compoundLibrary.blend(withID: blendID) {
                        Text(&quot;\(injectionProtocol.doseMg, format: .number.precision(.fractionLength(0))) mg \(blend.name) every \(injectionProtocol.frequencyDays, format: .number.precision(.fractionLength(1))) days&quot;)
                    } else {
                        Text(&quot;\(injectionProtocol.doseMg, format: .number.precision(.fractionLength(0))) mg every \(injectionProtocol.frequencyDays, format: .number.precision(.fractionLength(1))) days&quot;)
                    }
                }
            }
            .font(.subheadline)
            .foregroundColor(.secondary)
        }
    }
    
    private func deleteItems(at offsets: IndexSet) {
        dataStore.removeProtocol(at: offsets)
    }
}

#Preview {
    NavigationStack {
        ProtocolListView()
            .environmentObject(AppDataStore())
    }
}</file><file path="repomix-output.txt">This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed, line numbers have been added.

================================================================
Directory Structure
================================================================
TestoSim/
  Assets.xcassets/
    AccentColor.colorset/
      Contents.json
    AppIcon.appiconset/
      Contents.json
    Contents.json
  Models/
    BloodworkModel.swift
    CDBloodSample+CoreDataClass.swift
    CDCompound+CoreDataClass.swift
    CDCycle+CoreDataClass.swift
    CDCycleStage+CoreDataClass.swift
    CDInjectionProtocol+CoreDataClass.swift
    CDUserProfile+CoreDataClass.swift
    CDVialBlend+CoreDataClass.swift
    CDVialComponent+CoreDataClass.swift
    Compound.swift
    CompoundLibrary.swift
    CoreDataExtensions.swift
    CycleModel.swift
    DataPoint.swift
    PKModel.swift
    ProfileModel.swift
    ProtocolModel.swift
    VialBlend.swift
  TestoSim.xcdatamodeld/
    TestoSim.xcdatamodel/
      contents
  ViewModels/
    AIInsightsGenerator.swift
    AppDataStore.swift
    CoreDataManager.swift
    NotificationManager.swift
    OpenAIService.swift
  Views/
    AddBloodworkView.swift
    AIInsightsView.swift
    CalibrationResultView.swift
    CompoundListView.swift
    CyclePlannerView.swift
    CycleStageFormView.swift
    InjectionHistoryView.swift
    NotificationSettingsView.swift
    ProfileView.swift
    ProtocolDetailView.swift
    ProtocolFormView.swift
    ProtocolListView.swift
    TestosteroneChart.swift
    VialBlendListView.swift
  Config-Sample.plist
  Config-Sample.xcconfig
  ContentView.swift
  TestoSim.entitlements
  TestoSimApp.swift
TestoSim.xcodeproj/
  project.xcworkspace/
    xcshareddata/
      swiftpm/
        configuration/
    contents.xcworkspacedata
  project.pbxproj
TestoSimTests/
  TestoSimTests.swift
TestoSimUITests/
  TestoSimUITests.swift
  TestoSimUITestsLaunchTests.swift
.gitignore
add_files_to_target.sh
build-test.sh
buildServer.json
close-simulators.sh
copy-config.sh
guide_full.md
guide.md
guide2.md
launch-test.sh
pkModel.md
README.md

================================================================
Files
================================================================

================
File: guide_full.md
================
  1: Okay, let&apos;s combine the information from the guides, README, and codebase into a comprehensive guide explaining how the TestoSim application was built.
  2: 
  3: # TestoSim: Comprehensive Implementation Guide
  4: 
  5: ## 1. Introduction
  6: 
  7: TestoSim is a sophisticated iOS application designed to simulate testosterone pharmacokinetics (PK). It helps users visualize injection protocols, predict hormone levels based on various compounds and blends, track adherence, manage cycles, and gain AI-powered insights into their therapy. This guide details the application&apos;s architecture, features, and implementation based on the development process outlined in the initial guides and the current state reflected in the codebase.
  8: 
  9: **Key Features:**
 10: 
 11: *   **Pharmacokinetic Simulation:** Utilizes a two-compartment model with allometric scaling for personalized predictions.
 12: *   **Compound Library:** Includes a wide range of testosterone esters and other anabolic compounds with literature-based parameters.
 13: *   **Vial Blend Support:** Models commercial multi-compound blends accurately.
 14: *   **Protocol Management:** Allows users to create, edit, and manage single-compound or blend-based injection protocols.
 15: *   **Cycle Planner:** Enables planning and simulation of multi-stage, multi-compound cycles.
 16: *   **Bloodwork Tracking:** Users can log blood test results and compare them against model predictions.
 17: *   **Calibration:** Simple model calibration based on bloodwork results. (Advanced Bayesian model exists but UI linkage differs).
 18: *   **Notifications &amp; Adherence:** Reminders for injections and tracking of adherence statistics.
 19: *   **AI Insights:** Integration with OpenAI (GPT-4o-mini) to provide analysis and suggestions on protocols and cycles (uses a test key by default).
 20: *   **Persistence:** Uses Core Data for local storage, with optional CloudKit synchronization.
 21: 
 22: ## 2. Project Setup and Core Architecture
 23: 
 24: The application was built using SwiftUI, targeting iOS 16.0+ and macOS 13.0+.
 25: 
 26: *   **Project Initialization:** Started as a standard SwiftUI App project in Xcode (`Codebase/TestoSim.xcodeproj`).
 27: *   **Group Structure:** The project follows a standard MVVM-like structure with groups for:
 28:     *   `Models`: Contains data structures (structs) and Core Data entity definitions.
 29:     *   `Views`: Contains SwiftUI views for the user interface.
 30:     *   `ViewModels`: Contains `ObservableObject` classes managing state and business logic (`AppDataStore`, `AIInsightsGenerator`, `CoreDataManager`, `NotificationManager`, `OpenAIService`).
 31:     *   `Resources`: Contains assets like `Assets.xcassets`.
 32: *   **Main App Structure (`Codebase/TestoSim/TestoSimApp.swift`):**
 33:     *   The `@main` struct `TestoSimApp` initializes the primary data store (`AppDataStore`) as a `@StateObject`.
 34:     *   It sets up the main `ContentView` and injects the `dataStore` as an `@EnvironmentObject`.
 35:     *   It provides the Core Data `managedObjectContext` to the environment.
 36:     *   Includes logic to save the Core Data context when the app resigns active state.
 37:     *   Initializes default settings for the OpenAI test API key upon first launch.
 38: *   **Core Data Manager (`Codebase/TestoSim/ViewModels/CoreDataManager.swift`):**
 39:     *   Manages the Core Data stack.
 40:     *   Handles the setup of the `NSPersistentContainer` or `NSPersistentCloudKitContainer` based on the `usesICloudSync` flag in `UserDefaults`.
 41:     *   Includes logic for migrating data from the older `UserDefaults` persistence (`migrateUserProfileFromJSON`) upon first launch after the persistence change.
 42:     *   Provides methods for saving the context and managing CloudKit sync settings.
 43: *   **Main Data Store (`Codebase/TestoSim/ViewModels/AppDataStore.swift`):**
 44:     *   Acts as the central hub for application state and logic (`ObservableObject`).
 45:     *   `@Published` properties hold the user&apos;s `profile`, `cycles`, simulation data (`simulationData`, `cycleSimulationData`), selected IDs (`selectedProtocolID`, `selectedCycleID`), UI state (`isPresentingProtocolForm`, etc.), and the `compoundLibrary`.
 46:     *   Initializes the `UserProfile` by loading from Core Data or creating a default test profile (see `createDefaultProfile`).
 47:     *   Manages CRUD operations for `InjectionProtocol` and `Cycle`.
 48:     *   Contains functions to trigger PK simulations (`recalcSimulation`, `simulateCycle`, `simulateProtocol`).
 49:     *   Holds the logic for calculating concentration levels (`calculateLevel`, `predictedLevel`) which internally uses `PKModel`.
 50:     *   Includes logic for the *simple* calibration mechanism triggered by the UI (`calibrateProtocol`).
 51:     *   Integrates with `NotificationManager` for scheduling and adherence tracking.
 52: *   **Navigation (`Codebase/TestoSim/ContentView.swift`):**
 53:     *   Uses a `TabView` for main navigation between sections: Protocols, Cycles, Insights, and Profile.
 54:     *   Each tab contains a `NavigationStack` for hierarchical navigation within that section.
 55: 
 56: ## 3. Data Modeling and Persistence
 57: 
 58: The application uses a combination of Swift structs for in-memory representation and Core Data entities for persistence.
 59: 
 60: *   **Core Data Model (`Codebase/TestoSim/TestoSim.xcdatamodeld`):** Defines the persistent schema with entities like `CDUserProfile`, `CDInjectionProtocol`, `CDBloodSample`, `CDCompound`, `CDVialBlend`, `CDVialComponent`, `CDCycle`, `CDCycleStage`. Relationships are defined between these entities (e.g., UserProfile -&gt; Protocols, Protocol -&gt; BloodSamples). Code generation is set to &quot;category&quot; to allow custom extensions.
 61: *   **Swift Models:**
 62:     *   **`Compound` (`Codebase/TestoSim/Models/Compound.swift`):** Replaced the initial `TestosteroneEster`. Defines individual compounds with properties like `commonName`, `classType` (enum: testosterone, nandrolone, etc.), `ester`, `halfLifeDays`, and route-specific parameters (`defaultBioavailability`, `defaultAbsorptionRateKa`). Supports different `Route` enums (IM, SubQ, Oral, Transdermal).
 63:     *   **`VialBlend` (`Codebase/TestoSim/Models/VialBlend.swift`):** Represents commercial multi-compound blends. Contains an array of `Component` structs, each linking a `Compound` ID to its concentration (`mgPerML`) within the blend. Calculates `totalConcentration` and provides methods for describing the composition (`compositionDescription`).
 64:     *   **`CompoundLibrary` (`Codebase/TestoSim/Models/CompoundLibrary.swift`):** An `ObservableObject` holding pre-populated lists of `Compound` and `VialBlend` objects based on literature values (Story 8). Includes helper methods for filtering and retrieving compounds/blends. Populated in its `init`.
 65:     *   **`InjectionProtocol` (`Codebase/TestoSim/Models/ProtocolModel.swift`):** Represents a user-defined injection schedule.
 66:         *   Properties: `id`, `name`, `doseMg`, `frequencyDays`, `startDate`, `notes`, `bloodSamples`.
 67:         *   **Deviation:** Unlike Guide One&apos;s `ester` property, it now uses `compoundID: UUID?` and `blendID: UUID?` to link to either a `Compound` or `VialBlend`.
 68:         *   Includes `selectedRoute: String?` to store the administration route (`Compound.Route.rawValue`).
 69:         *   Computed property `protocolType: ProtocolType` determines if it&apos;s compound- or blend-based.
 70:         *   Contains the `injectionDates(from:upto:)` helper function.
 71:     *   **`BloodSample` (`Codebase/TestoSim/Models/BloodworkModel.swift`):** Simple struct to hold blood test results (`id`, `date`, `value`, `unit`).
 72:     *   **`UserProfile` (`Codebase/TestoSim/Models/ProfileModel.swift`):** Holds user-specific data.
 73:         *   Basic properties from Guide One: `id`, `name`, `unit`, `calibrationFactor`.
 74:         *   Extended properties from Story 10: `dateOfBirth`, `heightCm`, `weight`, `biologicalSex` (enum), `usesICloudSync`, `useTwoCompartmentModel`.
 75:         *   Holds the array of `protocols: [InjectionProtocol]`. (Note: `cycles` are managed separately in `AppDataStore` and linked via Core Data relationships, not directly embedded in the `UserProfile` struct).
 76:         *   Computed properties: `bodySurfaceArea`, `age`.
 77:     *   **`Cycle` / `CycleStage` (`Codebase/TestoSim/Models/CycleModel.swift`):** Represents multi-stage treatment plans. `Cycle` has overall details (`name`, `startDate`, `totalWeeks`, `stages`). `CycleStage` defines a period within the cycle (`startWeek`, `durationWeeks`) and contains arrays of `CompoundStageItem` and `BlendStageItem` which specify the compounds/blends used during that stage with their dosing. Includes methods to generate temporary `InjectionProtocol` objects for simulation.
 78:     *   **`DataPoint` (`Codebase/TestoSim/Models/DataPoint.swift`):** Simple struct holding a `time` (Date) and `level` (Double) for simulation results used in charts.
 79: *   **Persistence Strategy:**
 80:     *   **Initial (Guide One):** Used `UserDefaults` to store the `UserProfile` (including protocols and blood samples) as JSON data.
 81:     *   **Current (Guide Two &amp; Codebase):** Migrated to **Core Data** for local persistence. Uses entities mirroring the Swift models (`CDUserProfile`, `CDInjectionProtocol`, etc.). Relationships are managed by Core Data.
 82:     *   **CloudKit Integration:** Optionally uses `NSPersistentCloudKitContainer` (enabled via a toggle in `ProfileView` which sets `usesICloudSync` and requires an app restart). Data is synced to the user&apos;s private CloudKit database (`iCloud.flight505.TestoSim`).
 83:     *   **Migration:** `CoreDataManager.migrateUserProfileFromJSON()` handles the one-time transfer of data from `UserDefaults` JSON to Core Data entities when the app is first launched after the update. A `UserDefaults` flag (`migrated`) prevents repeated migration.
 84:     *   **Deviation (Protocol Storage):** Due to Core Data model limitations during migration, extended `InjectionProtocol` properties (`compoundID`, `blendID`, `selectedRoute`) are temporarily serialized into the `notes` field of `CDInjectionProtocol` until the Core Data model is fully updated. `CoreDataExtensions.swift` handles this serialization/deserialization.
 85: 
 86: ## 4. Pharmacokinetic Engine (`Codebase/TestoSim/Models/PKModel.swift`)
 87: 
 88: The core logic for calculating hormone concentrations resides in the `PKModel` struct.
 89: 
 90: *   **Model Type:**
 91:     *   **Deviation:** While Guide Two mentioned an *optional* two-compartment model, the codebase (`PKModel.swift` init, `UserProfile.swift` default `useTwoCompartmentModel = true`, `ProfileView.swift` info text) indicates the **two-compartment model is always used**. This provides higher accuracy, especially for compounds with complex absorption or distribution phases. The one-compartment formula (`C(t)=(F*D*ka)/(Vd*(ka-ke))*(exp(-ke*t)-exp(-ka*t))`) mentioned in Guide Two serves as the basis, but the implementation uses the derived two-compartment parameters (alpha, beta based on fixed k12, k21). A fallback `oneCompartmentBolus` calculation exists for edge cases.
 92: *   **Key Parameters:**
 93:     *   `ka`: Absorption rate constant (route-specific, from `Compound.defaultAbsorptionRateKa`).
 94:     *   `ke`: Elimination rate constant (calculated as `ln(2) / halfLifeDays`).
 95:     *   `F`: Bioavailability (route-specific, from `Compound.defaultBioavailability`).
 96:     *   `Vd`: Volume of Distribution (scaled based on user weight).
 97:     *   `CL`: Clearance (scaled based on user weight).
 98:     *   `k12`, `k21`: Inter-compartmental transfer rates (fixed values for the two-compartment model).
 99: *   **Allometric Scaling:** Implemented as described in Guide Two. User&apos;s `weight` (and `height` for BSA, though BSA isn&apos;t directly used in the core PK formula shown) from `UserProfile` is used to scale `Vd` and `CL` relative to a standard 70kg person, improving personalization. The `ProfileView` includes an info button linking to `AllometricInfoView` explaining this.
100: *   **Concentration Calculation Functions:**
101:     *   `concentration(at:dose:halfLifeDays:...)`: Calculates concentration for a single dose at a specific time using the two-compartment model.
102:     *   `blendConcentration(at:components:...)`: Calculates the total concentration for a blend by summing the contributions of each component compound.
103:     *   `protocolConcentrations(at:injectionDates:compounds:...)`: Calculates concentration over time for a full protocol (multiple injections, potentially multiple compounds/blends) by summing the contributions of *all* past injections at each requested time point. This is the primary function used by `AppDataStore.calculateLevel`.
104: *   **Peak Calculations (`Tp`, `Cmax`):**
105:     *   `calculateTimeToMaxConcentration(...)`: Calculates `Tp` (Time to Peak). Uses a numerical search for the two-compartment model.
106:     *   `calculateMaxConcentration(...)`: Calculates `Cmax` (Maximum Concentration) by evaluating the concentration at the calculated `Tp`.
107:     *   `calculateBlendPeakDetails(...)` and `calculateProtocolPeakDetails(...)`: Specialized functions to find the overall peak time and concentration for complex blends or multi-injection protocols using numerical search over a time window. These are available in `AppDataStore` for potential UI display.
108: *   **Calibration:**
109:     *   **Simple Factor (Implemented in UI):** `AppDataStore.calibrateProtocol` implements the simple calibration described in Guide One. It calculates an `adjustmentRatio` based on the *latest* blood sample and the model&apos;s prediction at that point (using the current factor) and multiplies the global `profile.calibrationFactor` by this ratio. This is triggered by the &quot;Recalibrate&quot; button in `ProtocolDetailView`.
110:     *   **Bayesian Calibration (Model Logic Exists):** `PKModel.bayesianCalibration` contains the advanced logic described in Guide Two (gradient descent to adjust `ke` and `ka` based on *multiple* samples, parameter bounds, correlation calculation).
111:     *   **Deviation:** While the Bayesian logic exists in `PKModel`, the main UI flow doesn&apos;t seem to trigger it directly or display its detailed results (`CalibrationResultView`). The simpler calibration factor adjustment is what&apos;s currently active via the UI button. `CalibrationResultView.swift` exists but appears disconnected from this flow.
112: 
113: ## 5. User Interface (`Codebase/TestoSim/Views/`)
114: 
115: The UI is built with SwiftUI, organized into distinct views.
116: 
117: *   **Main Navigation (`ContentView.swift`):** A `TabView` with four main tabs: Protocols, Cycles, Insights, Profile.
118: *   **Protocols Tab (`ProtocolListView.swift`, `ProtocolDetailView.swift`, `ProtocolFormView.swift`):**
119:     *   `ProtocolListView`: Displays a list of user protocols. Each row is a `NavigationLink` to the detail view. Supports swipe-to-delete. Toolbar buttons for adding a protocol (+) and navigating to Profile. Uses `@EnvironmentObject dataStore`. Handles empty state.
120:     *   `ProtocolDetailView`: Shows details for a selected protocol. Includes:
121:         *   A summary section displaying compound/blend name, dose, frequency, route, start date, and notes. Dynamically adapts based on `protocolType`.
122:         *   `TestosteroneChart` view.
123:         *   Latest bloodwork comparison section.
124:         *   Next injection information and reminder button.
125:         *   Action buttons: &quot;Add Bloodwork&quot;, &quot;Record Injection&quot;, &quot;Recalibrate Model&quot;.
126:         *   Toolbar &quot;Edit&quot; button.
127:         *   Calls `dataStore.selectProtocol` on appear.
128:     *   `ProtocolFormView`: Presented as a sheet for adding/editing protocols.
129:         *   Fields for name, dose, frequency, start date, notes.
130:         *   **Deviation:** Includes a segmented control to select `protocolType` (Compound or Blend).
131:         *   Dynamically shows a button to launch `CompoundListView` or `VialBlendListView`.
132:         *   Includes a `Picker` for `selectedRoute`, dynamically showing only valid routes for the selected compound.
133: *   **Compound/Blend Selection (`CompoundListView.swift`, `VialBlendListView.swift`):**
134:     *   Presented as sheets from `ProtocolFormView`.
135:     *   Allow browsing and selecting from the `CompoundLibrary`.
136:     *   Include search bars and filtering options (by class type for compounds).
137: *   **Chart (`TestosteroneChart.swift`):**
138:     *   Uses `Swift Charts`.
139:     *   Displays simulation data (`dataStore.simulationData`) as a `LineMark`.
140:     *   **Deviation:** Marks injections using `PointMark` (green dots) on the curve and `RuleMark` (vertical dashed gray lines with syringe annotation at bottom was the plan, but code uses green dots on curve and vertical lines). Guide one planned `RuleMark` + annotation.
141:     *   Displays blood samples as `PointMark` (red dots - code doesn&apos;t show this, but `AddBloodworkView` exists). *Correction:* `TestosteroneChart.swift` does *not* explicitly plot blood samples; this was part of Guide One&apos;s plan but seems missing in the final chart implementation. The `latestBloodworkView` in `ProtocolDetailView` shows the *latest* sample textually.
142:     *   Includes customizable X and Y axes (`AxisMarks`).
143:     *   Features an interactive overlay (`chartOverlay`) using `DragGesture` to show the level at a specific date (`selectedDataPoint`).
144: *   **Bloodwork (`AddBloodworkView.swift`):**
145:     *   Presented as a sheet from `ProtocolDetailView`.
146:     *   Form with fields for blood level value, sample date/time, and notes.
147:     *   Uses the profile&apos;s preferred unit.
148:     *   Provides &quot;Add Sample and Calibrate&quot; and &quot;Add Sample Only&quot; buttons. The calibration triggers the simple factor adjustment in `AppDataStore`.
149: *   **Profile Tab (`ProfileView.swift`):**
150:     *   Uses a `Form` to display and edit user profile settings.
151:     *   Sections for User Info (name, sex, DOB), Physical Measurements (height, weight, BSA, Allometric Scaling info button), Notifications &amp; Adherence (links to settings/history, shows rate), Settings (unit preference, iCloud toggle, PK Model info button), and Calibration (factor display, reset button).
152:     *   Links to `NotificationSettingsView` and `InjectionHistoryView`.
153:     *   Includes `AllometricInfoView` explaining scaling.
154:     *   Saves profile changes `onDisappear`.
155: *   **Cycles Tab (`CyclePlannerView.swift`, `CycleFormView.swift`, `CycleStageFormView.swift`):**
156:     *   `CyclePlannerView`: Main view for the Cycles tab. Lists existing cycles. Shows simulation results (`CycleChartView`) for the selected cycle. Toolbar &quot;+&quot; button presents `CycleFormView`. Tapping a cycle row selects it and shows its details (likely intended to navigate or show details inline, currently selects and simulates).
157:     *   `CycleRowView`: Displays a summary of a cycle in the list.
158:     *   `CycleChartView`: Displays the combined concentration curve for a simulated cycle.
159:     *   `CycleFormView`: Sheet for creating a new cycle (name, start date, duration, notes).
160:     *   `CycleDetailView`: (Appears partially implemented) Shows details of a cycle, including stages and simulation. Buttons to add stages.
161:     *   `CycleStageFormView`: Sheet for adding/editing a stage within a cycle. Allows adding multiple `CompoundStageItem` or `BlendStageItem` entries with dose, frequency, and route for that stage. Uses pickers (`CompoundPickerView`, `BlendPickerView`) and an `ItemConfigurationView`.
162: *   **Insights Tab (`AIInsightsView.swift`, `AISettingsView.swift`):**
163:     *   `AIInsightsView`: Displays AI-generated insights for the currently selected protocol or cycle.
164:         *   Shows loading indicators, error messages, or &quot;No Insights&quot; state.
165:         *   Indicates if the test API key is in use.
166:         *   Presents insights with a title, summary, optional blend explanation, and expandable key points (color-coded by type: info, positive, warning, suggestion).
167:         *   Toolbar buttons for refreshing insights and accessing settings.
168:     *   `AISettingsView`: Sheet for managing OpenAI API key settings.
169:         *   Toggle to use the free test key (default).
170:         *   Secure field to enter a personal API key if the test key is disabled.
171:         *   Buttons to save/clear the personal key.
172:         *   Informational text about how insights work and privacy.
173: *   **Notifications UI (`NotificationSettingsView.swift`, `InjectionHistoryView.swift`):**
174:     *   `NotificationSettingsView`: Accessed from `ProfileView`. Allows enabling/disabling notifications, sound, and selecting lead time. Displays adherence stats.
175:     *   `InjectionHistoryView`: Accessed from `ProfileView`. Lists past scheduled injections with their status (On Time, Late, Missed) and acknowledged date/time. Includes overall adherence stats. Allows filtering by protocol.
176: 
177: ## 6. Advanced Features Implementation
178: 
179: Beyond the basic simulation and UI, several advanced features were implemented:
180: 
181: *   **Notifications &amp; Adherence (Story 11):**
182:     *   **Manager:** `NotificationManager.swift` handles requesting permissions (`UNUserNotificationCenter`), scheduling (`UNCalendarNotificationTrigger`), updating, and canceling notifications based on protocol schedules and user preferences (lead time, sound).
183:     *   **Integration:** `AppDataStore` calls `NotificationManager` methods when protocols are added, updated, or removed, and when notification settings change.
184:     *   **Tracking:** `NotificationManager` uses `UserDefaults` to persist `InjectionRecord` structs, logging scheduled injections and their acknowledged status/time. `AppDataStore` provides methods to acknowledge injections and retrieve history/stats.
185:     *   **UI:** `NotificationSettingsView` controls preferences. `InjectionHistoryView` displays past records and stats. `ProfileView` shows the overall adherence rate. `ProtocolDetailView` includes a &quot;Remind Me&quot; button and a &quot;Record Injection&quot; button.
186: *   **Cycle Builder (Story 12):**
187:     *   **Models:** `Cycle`, `CycleStage`, `CompoundStageItem`, `BlendStageItem` structs defined in `CycleModel.swift`.
188:     *   **Persistence:** `CDCycle`, `CDCycleStage` entities in Core Data. `CoreDataExtensions.swift` includes logic to convert between structs and entities, using JSON serialization for the stage items arrays (`compoundsData`, `blendsData`).
189:     *   **Logic:** `AppDataStore` manages CRUD operations for cycles (`loadCyclesFromCoreData`, `saveCycle`, `deleteCycle`). The `simulateCycle` method generates temporary `InjectionProtocol` objects from the cycle stages and accumulates their concentrations using the `PKModel`.
190:     *   **UI:** `CyclePlannerView` provides the main interface. `CycleFormView` and `CycleStageFormView` handle creation/editing. `CycleChartView` visualizes results. A `TabView` in `ContentView` provides access.
191: *   **AI Insights (Story 13):**
192:     *   **Service:** `OpenAIService.swift` handles communication with the OpenAI API (`api.openai.com/v1/chat/completions`). It manages the API key (user-provided via `UserDefaults` or the default test key from `Config.plist`). Uses `gpt-4o-mini`. Sends structured prompts (`buildProtocolPrompt`, `buildCyclePrompt`). Parses JSON responses.
193:     *   **Generator:** `AIInsightsGenerator.swift` orchestrates the process. It takes protocol/cycle data, calls `OpenAIService`, handles loading states and errors, caches results (`insightsCache`), and provides mock insights (`generateMockInsights`, `createMockInsightsForProtocol/Cycle`) as a fallback if the API key is missing or the call fails.
194:     *   **UI:** `AIInsightsView` displays the results fetched by `AIInsightsGenerator`. `AISettingsView` manages API key preferences.
195:     *   **Configuration:** API key is stored via `Config.plist` (runtime) and potentially `Config.xcconfig` (build time, though plist seems primary). The `copy-config.sh` script ensures these files exist from samples. `.gitignore` prevents committing actual keys.
196: 
197: ## 7. Configuration &amp; Setup
198: 
199: *   **API Keys:**
200:     *   Uses `Config.plist` for runtime API key access (`OpenAIService`).
201:     *   Sample files (`Config-Sample.plist`, `Config-Sample.xcconfig`) are provided.
202:     *   `copy-config.sh` copies samples to actual config files if they don&apos;t exist on first build.
203:     *   `Config.plist` and `Config.xcconfig` are in `.gitignore`.
204:     *   A default test API key (read from `Config.plist`) is used unless the user provides their own via `AISettingsView` and disables the &quot;Use Test Key&quot; toggle.
205: *   **CloudKit:**
206:     *   Enabled via `TestoSim.entitlements` specifying the `iCloud.flight505.TestoSim` container and CloudKit service.
207:     *   `CoreDataManager` conditionally initializes `NSPersistentCloudKitContainer` based on the `usesICloudSync` flag.
208:     *   Users toggle sync via `ProfileView`. A restart is needed for changes to take effect.
209:     *   Troubleshooting steps are provided in the README.
210: 
211: ## 8. Development &amp; Troubleshooting Workflow
212: 
213: The README provides scripts and guidance for developers:
214: 
215: *   **Simulator Management:**
216:     *   `build-test.sh`: Builds the app without launching a simulator (recommended for use with VS Code/SweetPad).
217:     *   `close-simulators.sh`: Shuts down all running simulator instances.
218:     *   `launch-test.sh`: Builds and launches the app in a specific, single simulator instance (closes others first).
219: *   **Recommended Workflow:** Use VS Code with SweetPad extension for streamlined building and running, or use the provided scripts for command-line control.
220: *   **Troubleshooting:** Steps for handling launch crashes (close simulators, clean build, launch specific device) and command for checking device logs (`xcrun simctl spawn booted log stream...`).
221: 
222: ## 9. Key Deviations from Initial Guides
223: 
224: Comparing the final codebase to the initial guides (especially Guide One) reveals several significant changes and deviations:
225: 
226: 1.  **`TestosteroneEster` Removed:** The simple `TestosteroneEster` model from Guide One was completely replaced by the more flexible `Compound` and `VialBlend` system described in Guide Two and implemented in the codebase.
227: 2.  **Persistence:** Shifted from `UserDefaults` (Guide One) to Core Data + optional CloudKit (Guide Two / Codebase).
228: 3.  **PK Model:** Advanced from a basic single-exponential model (Guide One) to always using a two-compartment model with allometric scaling (Codebase), diverging slightly from Guide Two&apos;s mention of an optional toggle.
229: 4.  **UI Navigation:** Uses `TabView` as the main structure (`ContentView`) instead of just a `NavigationStack` (Guide One).
230: 5.  **Protocol Form:** Significantly updated (`ProtocolFormView`) to handle Compound/Blend selection and administration route, differing from Guide One&apos;s simpler ester picker.
231: 6.  **Calibration:** The UI button (&quot;Recalibrate&quot;) triggers a simple calibration factor adjustment (`AppDataStore.calibrateProtocol`), not the detailed Bayesian model (`PKModel.bayesianCalibration`) or the display view (`CalibrationResultView`) described in Guide Two, although the Bayesian logic exists in the `PKModel`.
232: 7.  **Charting:** `TestosteroneChart` implementation details differ from Guide One&apos;s plan (uses `PointMark` for injections, does not plot blood samples directly).
233: 8.  **Major Features Added:** Cycles, Notifications, AI Insights were not part of Guide One but are core features implemented based on Guide Two.
234: 9.  **Naming Conventions:** Codebase reflects fixes described in Guide Two (e.g., using `treatmentProtocol` instead of `protocol` as variable names).
235: 
236: ## 10. Future Work (As per Guide Two)
237: 
238: The following areas were planned but not yet started according to Guide Two:
239: 
240: *   **Story 14: UI/UX Polish &amp; Animations:** Improving visual design, implementing animations (Lottie), adding haptics/sounds, adopting HIG guidelines, and enhancing chart interactivity.
241: *   **Story 15: Testing &amp; Validation:** Unit testing PK calculations against known data, UI testing, performance testing.
242: *   **Story 16: Help Center &amp; Documentation:** Creating a comprehensive in-app help center with detailed explanations and tutorials for various features (PK model, allometric scaling, calibration, cycle planning).
243: 
244: This guide provides a comprehensive overview of how TestoSim was developed, integrating the initial plans with the advanced features and reflecting the final state found in the codebase.

================
File: pkModel.md
================
  1: # Why your testosterone model flatlines: Technical fixes for the TestoSim app
  2: 
  3: ## Bottom line up front
  4: The near-zero concentration values in TestoSim&apos;s two-compartment pharmacokinetic model likely stem from one of three core issues: mathematical implementation errors in the differential equations solver, failure to account for testosterone&apos;s unique pharmacokinetic properties, or improper Bayesian calibration implementation. The most probable culprit is either incorrect eigenvalue calculation in the model solution or failure to account for endogenous testosterone production. Your immediate fixes should include verifying all rate constant implementations (especially k12/k21), implementing robust numerical methods with proper error handling, and incorporating baseline testosterone production (approximately 7 mg/day) into your model. Implementing these changes will likely resolve the concentration graph issues.
  5: 
  6: ## Mathematical formulation errors causing flat graphs
  7: 
  8: ### Eigenvalue calculation issues
  9: Two-compartment models require accurate calculation of eigenvalues (α and β) derived from the micro-rate constants. Implementation errors here can cause catastrophic calculation failures:
 10: 
 11: ```
 12: α = (ks + √(ks² - 4 × k₁₀ × k₂₁))/2
 13: β = (ks - √(ks² - 4 × k₁₀ × k₂₁))/2
 14: ```
 15: 
 16: Where ks = k₁₀ + k₁₂ + k₂₁
 17: 
 18: **Incorrect matrix formulation** or eigendecomposition in the solver can cause systematic errors producing near-zero concentrations. Special case handling is also critical - when eigenvalues are equal or very close (when k₀₁ equals either α or β), standard equations become indeterminate and require alternative formulations.
 19: 
 20: ### Parameter magnitude and unit errors
 21: PK models are extremely sensitive to parameter magnitude and unit consistency. Common errors include:
 22: 
 23: - Using minutes for some rate constants but hours for others
 24: - Setting absorption or elimination rate constants orders of magnitude too high, causing rapid drug disappearance
 25: - Volume overestimation artificially reducing calculated concentrations
 26: - Confusion between micro-constants (k12, k21) and macro-constants (α, β)
 27: 
 28: When implementing the concentration calculation equation:
 29: 
 30: ```
 31: C(t) = Dose × k₀₁ × [((α-k₂₁)/(α-β)) × ((e^(-k₀₁×t) - e^(-α×t))/(α-k₀₁)) 
 32:        + ((k₂₁-β)/(α-β)) × ((e^(-k₀₁×t) - e^(-β×t))/(β-k₀₁))] / V₁
 33: ```
 34: 
 35: Even small errors in any component can produce significantly distorted concentration profiles.
 36: 
 37: ### Numerical computation problems
 38: Two-compartment models can exhibit &quot;stiffness&quot; when rate constants differ by orders of magnitude, causing standard numerical solvers to fail. This produces instability that often manifests as near-zero values.
 39: 
 40: Verify the numerical method TestoSim uses - fixed-step explicit methods like forward Euler will fail with stiff equations, while adaptive implicit methods (backward differentiation formulas) are more appropriate.
 41: 
 42: ## Testosterone-specific modeling considerations
 43: 
 44: ### Missing endogenous production term
 45: Unlike most drugs, testosterone is produced endogenously at approximately 7 mg/day in healthy males. **Models that don&apos;t incorporate baseline testosterone production** will show artificially low or near-zero values, especially at trough times.
 46: 
 47: The model should include a zero-order production rate term in the central compartment differential equation:
 48: 
 49: ```
 50: dA₁/dt = k₀₁ × A₀ - (k₁₂ + k₁₀) × A₁ + k₂₁ × A₂ + Rendo
 51: ```
 52: 
 53: Where Rendo represents endogenous testosterone production rate.
 54: 
 55: ### Protein binding effects
 56: 97-99.5% of circulating testosterone binds to plasma proteins, with only 0.5-3.0% remaining as free testosterone. If your model doesn&apos;t account for protein binding, concentration calculations may be inaccurate:
 57: 
 58: - 30-44% binds to sex hormone-binding globulin (SHBG) 
 59: - 54-68% binds to albumin
 60: 
 61: At low concentrations, non-linear pharmacokinetics from saturable protein binding may require Michaelis-Menten kinetics rather than simple first-order elimination.
 62: 
 63: ### Realistic parameter ranges
 64: For troubleshooting, verify your parameters against these physiological ranges for testosterone:
 65: 
 66: | Parameter | Description | Expected Range | Units |
 67: |-----------|-------------|----------------|-------|
 68: | CL | Clearance | 2.0-3.5 | kL/day |
 69: | Vc | Central compartment volume | 10-20 | kL |
 70: | Q | Intercompartmental clearance | 0.5-2.0 | kL/day |
 71: | Vp | Peripheral compartment volume | 20-50 | kL |
 72: | ka | Absorption rate constant | 0.2-2.0 | 1/hour |
 73: 
 74: Parameters significantly outside these ranges will produce physiologically implausible results.
 75: 
 76: ## Bayesian calibration implementation issues
 77: 
 78: ### Proper implementation requirements
 79: Bayesian calibration combines prior parameter distributions with a likelihood function through Bayes&apos; theorem:
 80: 
 81: ```
 82: p(θ|Y) ∝ p(Y|θ) × p(θ)
 83: ```
 84: 
 85: For TestoSim&apos;s `calibrateProtocolWithBayesian` function to work properly, it must:
 86: 
 87: 1. Use appropriate prior distributions for testosterone-specific parameters
 88: 2. Implement an accurate likelihood function based on observation model
 89: 3. Use robust MCMC sampling methods (e.g., Metropolis-Hastings or Hamiltonian Monte Carlo)
 90: 4. Include sufficient burn-in period and convergence diagnostics
 91: 
 92: ### Common calibration failures
 93: Several issues can cause Bayesian calibration to produce physiologically implausible parameter estimates:
 94: 
 95: - **Overly restrictive priors** preventing the model from finding true parameter values
 96: - **Improper initialization** of MCMC chains outside plausible parameter space
 97: - **Insufficient sampling** or premature convergence declaration
 98: - **Parameter correlation** causing identifiability issues, especially between volume and clearance parameters
 99: 
100: If your implementation suffers from poor chain mixing or convergence, it may settle on parameter values that produce near-zero concentrations.
101: 
102: ## Debugging your implementation
103: 
104: ### Systematic verification process
105: Follow this systematic debugging process to identify the root cause:
106: 
107: 1. **Verify mathematical implementation**: Review eigenvalue calculations and the analytical solution for the two-compartment model
108: 2. **Implement log-transformed calculations**: Convert concentration calculations to log space to address numerical issues with small values
109: 3. **Check parameter physiological plausibility**: Confirm all parameters are within expected ranges
110: 4. **Add endogenous testosterone production**: Incorporate baseline production (7 mg/day) into your model
111: 5. **Validate with simplified cases**: Test one-compartment model with same parameters, then gradually increase complexity
112: 
113: ### Diagnostics and validation
114: Implement these diagnostics to validate your model:
115: 
116: 1. **Mass balance check**: Total drug in system should equal administered dose minus eliminated amount
117: 2. **Residual analysis**: Systematic errors in predictions may indicate model misspecification
118: 3. **Analytical solution verification**: Compare numerical solutions with closed-form solutions for simple cases
119: 4. **Cross-validation**: Validate against established PK software (NONMEM, SimCYP, etc.)
120: 
121: ### Implementation best practices
122: For robust implementation, consider these best practices:
123: 
124: ```
125: // Special case handling for eigenvalues
126: if (Math.abs(k12 + k10 - k21) &lt; EPSILON) {
127:     // Handle special case where eigenvalues are very close
128:     alpha = beta = (k12 + k10 + k21) / 2;
129:     // Use special solution form for equal eigenvalues
130: } else {
131:     // Standard calculation
132:     double term = Math.sqrt((k12 + k10 + k21) * (k12 + k10 + k21) - 4 * k10 * k21);
133:     alpha = ((k12 + k10 + k21) + term) / 2;
134:     beta = ((k12 + k10 + k21) - term) / 2;
135: }
136: 
137: // Handle near-zero concentrations
138: if (concentration &lt; MINIMUM_REPORTABLE_CONCENTRATION) {
139:     // Log warning
140:     logger.warn(&quot;Near-zero concentration calculated at time {}: {}&quot;, time, concentration);
141:     
142:     // Verify parameter values
143:     logger.debug(&quot;Parameters: k01={}, k10={}, k12={}, k21={}, V1={}&quot;, k01, k10, k12, k21, V1);
144:     
145:     // Check for numerical issues
146:     if (hasNumericalInstability()) {
147:         // Apply alternative calculation method
148:         concentration = calculateUsingLogTransformation();
149:     }
150: }
151: ```
152: 
153: ## Conclusion
154: The TestoSim app&apos;s near-zero concentration values likely stem from either mathematical implementation errors, failure to account for testosterone&apos;s unique properties, or issues in the Bayesian calibration process. By systematically reviewing these areas—particularly verifying rate constant implementations, accounting for endogenous testosterone production, and implementing robust numerical methods—you can identify and resolve the underlying issue. The solutions presented here provide a comprehensive troubleshooting framework specifically tailored to two-compartment pharmacokinetic models for testosterone.

================
File: TestoSim/Assets.xcassets/AccentColor.colorset/Contents.json
================
 1: {
 2:   &quot;colors&quot; : [
 3:     {
 4:       &quot;idiom&quot; : &quot;universal&quot;
 5:     }
 6:   ],
 7:   &quot;info&quot; : {
 8:     &quot;author&quot; : &quot;xcode&quot;,
 9:     &quot;version&quot; : 1
10:   }
11: }

================
File: TestoSim/Assets.xcassets/AppIcon.appiconset/Contents.json
================
 1: {
 2:   &quot;images&quot; : [
 3:     {
 4:       &quot;idiom&quot; : &quot;universal&quot;,
 5:       &quot;platform&quot; : &quot;ios&quot;,
 6:       &quot;size&quot; : &quot;1024x1024&quot;
 7:     },
 8:     {
 9:       &quot;appearances&quot; : [
10:         {
11:           &quot;appearance&quot; : &quot;luminosity&quot;,
12:           &quot;value&quot; : &quot;dark&quot;
13:         }
14:       ],
15:       &quot;idiom&quot; : &quot;universal&quot;,
16:       &quot;platform&quot; : &quot;ios&quot;,
17:       &quot;size&quot; : &quot;1024x1024&quot;
18:     },
19:     {
20:       &quot;appearances&quot; : [
21:         {
22:           &quot;appearance&quot; : &quot;luminosity&quot;,
23:           &quot;value&quot; : &quot;tinted&quot;
24:         }
25:       ],
26:       &quot;idiom&quot; : &quot;universal&quot;,
27:       &quot;platform&quot; : &quot;ios&quot;,
28:       &quot;size&quot; : &quot;1024x1024&quot;
29:     },
30:     {
31:       &quot;idiom&quot; : &quot;mac&quot;,
32:       &quot;scale&quot; : &quot;1x&quot;,
33:       &quot;size&quot; : &quot;16x16&quot;
34:     },
35:     {
36:       &quot;idiom&quot; : &quot;mac&quot;,
37:       &quot;scale&quot; : &quot;2x&quot;,
38:       &quot;size&quot; : &quot;16x16&quot;
39:     },
40:     {
41:       &quot;idiom&quot; : &quot;mac&quot;,
42:       &quot;scale&quot; : &quot;1x&quot;,
43:       &quot;size&quot; : &quot;32x32&quot;
44:     },
45:     {
46:       &quot;idiom&quot; : &quot;mac&quot;,
47:       &quot;scale&quot; : &quot;2x&quot;,
48:       &quot;size&quot; : &quot;32x32&quot;
49:     },
50:     {
51:       &quot;idiom&quot; : &quot;mac&quot;,
52:       &quot;scale&quot; : &quot;1x&quot;,
53:       &quot;size&quot; : &quot;128x128&quot;
54:     },
55:     {
56:       &quot;idiom&quot; : &quot;mac&quot;,
57:       &quot;scale&quot; : &quot;2x&quot;,
58:       &quot;size&quot; : &quot;128x128&quot;
59:     },
60:     {
61:       &quot;idiom&quot; : &quot;mac&quot;,
62:       &quot;scale&quot; : &quot;1x&quot;,
63:       &quot;size&quot; : &quot;256x256&quot;
64:     },
65:     {
66:       &quot;idiom&quot; : &quot;mac&quot;,
67:       &quot;scale&quot; : &quot;2x&quot;,
68:       &quot;size&quot; : &quot;256x256&quot;
69:     },
70:     {
71:       &quot;idiom&quot; : &quot;mac&quot;,
72:       &quot;scale&quot; : &quot;1x&quot;,
73:       &quot;size&quot; : &quot;512x512&quot;
74:     },
75:     {
76:       &quot;idiom&quot; : &quot;mac&quot;,
77:       &quot;scale&quot; : &quot;2x&quot;,
78:       &quot;size&quot; : &quot;512x512&quot;
79:     }
80:   ],
81:   &quot;info&quot; : {
82:     &quot;author&quot; : &quot;xcode&quot;,
83:     &quot;version&quot; : 1
84:   }
85: }

================
File: TestoSim/Assets.xcassets/Contents.json
================
1: {
2:   &quot;info&quot; : {
3:     &quot;author&quot; : &quot;xcode&quot;,
4:     &quot;version&quot; : 1
5:   }
6: }

================
File: TestoSim/Models/BloodworkModel.swift
================
 1: import Foundation
 2: struct BloodSample: Identifiable, Codable, Hashable {
 3:     let id: UUID
 4:     let date: Date
 5:     let value: Double
 6:     let unit: String
 7:     init(id: UUID = UUID(), date: Date, value: Double, unit: String) {
 8:         self.id = id
 9:         self.date = date
10:         self.value = value
11:         self.unit = unit
12:     }
13: }

================
File: TestoSim/Models/CDCycle+CoreDataClass.swift
================
1: import Foundation
2: import CoreData
3: @objc(CDCycle)
4: public class CDCycle: NSManagedObject {
5: }

================
File: TestoSim/Models/CDCycleStage+CoreDataClass.swift
================
1: import Foundation
2: import CoreData
3: @objc(CDCycleStage)
4: public class CDCycleStage: NSManagedObject {
5: }

================
File: TestoSim/Models/Compound.swift
================
 1: import Foundation
 2: struct Compound: Identifiable, Codable, Hashable {
 3:     enum Class: String, Codable, CaseIterable {
 4:         case testosterone, nandrolone, trenbolone,
 5:              boldenone, drostanolone, stanozolol, metenolone,
 6:              trestolone, dhb
 7:         var displayName: String {
 8:             switch self {
 9:             case .testosterone: return &quot;Testosterone&quot;
10:             case .nandrolone: return &quot;Nandrolone&quot;
11:             case .trenbolone: return &quot;Trenbolone&quot;
12:             case .boldenone: return &quot;Boldenone&quot;
13:             case .drostanolone: return &quot;Drostanolone (Masteron)&quot;
14:             case .stanozolol: return &quot;Stanozolol (Winstrol)&quot;
15:             case .metenolone: return &quot;Metenolone (Primobolan)&quot;
16:             case .trestolone: return &quot;Trestolone (MENT)&quot;
17:             case .dhb: return &quot;1-Testosterone (DHB)&quot;
18:             }
19:         }
20:     }
21:     enum Route: String, Codable, CaseIterable {
22:         case intramuscular, subcutaneous, oral, transdermal
23:         var displayName: String {
24:             switch self {
25:             case .intramuscular: return &quot;Intramuscular (IM)&quot;
26:             case .subcutaneous: return &quot;Subcutaneous (SubQ)&quot;
27:             case .oral: return &quot;Oral&quot;
28:             case .transdermal: return &quot;Transdermal&quot;
29:             }
30:         }
31:     }
32:     let id: UUID
33:     var commonName: String
34:     var classType: Class
35:     var ester: String?          // nil for suspensions
36:     var halfLifeDays: Double
37:     var defaultBioavailability: [Route: Double]
38:     var defaultAbsorptionRateKa: [Route: Double] // d-¹ (per day)
39:     init(id: UUID = UUID(), 
40:          commonName: String, 
41:          classType: Class, 
42:          ester: String? = nil, 
43:          halfLifeDays: Double, 
44:          defaultBioavailability: [Route: Double], 
45:          defaultAbsorptionRateKa: [Route: Double]) {
46:         self.id = id
47:         self.commonName = commonName
48:         self.classType = classType
49:         self.ester = ester
50:         self.halfLifeDays = halfLifeDays
51:         self.defaultBioavailability = defaultBioavailability
52:         self.defaultAbsorptionRateKa = defaultAbsorptionRateKa
53:     }
54:     // Returns the full display name with class and ester, e.g. &quot;Testosterone Enanthate&quot;
55:     var fullDisplayName: String {
56:         if let ester = ester {
57:             return &quot;\(classType.displayName) \(ester)&quot;
58:         } else {
59:             return &quot;\(classType.displayName) Suspension&quot;
60:         }
61:     }
62: }

================
File: TestoSim/Models/CompoundLibrary.swift
================
  1: import Foundation
  2: class CompoundLibrary: ObservableObject {
  3:     @Published private(set) var compounds: [Compound] = []
  4:     @Published private(set) var blends: [VialBlend] = []
  5:     init() {
  6:         populateCompounds()
  7:         populateBlends()
  8:     }
  9:     // MARK: - Helper Methods
 10:     func compound(withID id: UUID) -&gt; Compound? {
 11:         return compounds.first { $0.id == id }
 12:     }
 13:     func blend(withID id: UUID) -&gt; VialBlend? {
 14:         return blends.first { $0.id == id }
 15:     }
 16:     // MARK: - Filter Methods
 17:     func compounds(ofClass classType: Compound.Class) -&gt; [Compound] {
 18:         return compounds.filter { $0.classType == classType }
 19:     }
 20:     func compounds(forRoute route: Compound.Route) -&gt; [Compound] {
 21:         return compounds.filter { $0.defaultBioavailability[route] != nil }
 22:     }
 23:     func compounds(withEsterName esterName: String) -&gt; [Compound] {
 24:         return compounds.filter { $0.ester == esterName }
 25:     }
 26:     func compounds(withHalfLifeBetween min: Double, and max: Double) -&gt; [Compound] {
 27:         return compounds.filter { $0.halfLifeDays &gt;= min &amp;&amp; $0.halfLifeDays &lt;= max }
 28:     }
 29:     func blends(containing compoundID: UUID) -&gt; [VialBlend] {
 30:         return blends.filter { blend in
 31:             blend.components.contains { $0.compoundID == compoundID }
 32:         }
 33:     }
 34:     // MARK: - Populate Data
 35:     private func populateCompounds() {
 36:         // Default values for typical routes
 37:         let defaultIMBioavailability: [Compound.Route: Double] = [.intramuscular: 1.0, .subcutaneous: 0.85]
 38:         let defaultOralBioavailability: [Compound.Route: Double] = [.oral: 0.07] // Low for most oral testosterone
 39:         // Testosterone compounds
 40:         let testosteronePropionate = Compound(
 41:             commonName: &quot;Testosterone Propionate&quot;,
 42:             classType: .testosterone,
 43:             ester: &quot;Propionate&quot;,
 44:             halfLifeDays: 0.8, // Wikipedia
 45:             defaultBioavailability: defaultIMBioavailability,
 46:             defaultAbsorptionRateKa: [.intramuscular: 0.70, .subcutaneous: 0.50]
 47:         )
 48:         let testosteronePhenylpropionate = Compound(
 49:             commonName: &quot;Testosterone Phenylpropionate&quot;,
 50:             classType: .testosterone,
 51:             ester: &quot;Phenylpropionate&quot;,
 52:             halfLifeDays: 2.5, // Iron Daddy
 53:             defaultBioavailability: defaultIMBioavailability,
 54:             defaultAbsorptionRateKa: [.intramuscular: 0.50, .subcutaneous: 0.35]
 55:         )
 56:         let testosteroneIsocaproate = Compound(
 57:             commonName: &quot;Testosterone Isocaproate&quot;,
 58:             classType: .testosterone,
 59:             ester: &quot;Isocaproate&quot;,
 60:             halfLifeDays: 3.1, // Cayman Chemical
 61:             defaultBioavailability: defaultIMBioavailability,
 62:             defaultAbsorptionRateKa: [.intramuscular: 0.35, .subcutaneous: 0.25]
 63:         )
 64:         let testosteroneEnanthate = Compound(
 65:             commonName: &quot;Testosterone Enanthate&quot;,
 66:             classType: .testosterone,
 67:             ester: &quot;Enanthate&quot;,
 68:             halfLifeDays: 4.5, // From previous app data
 69:             defaultBioavailability: defaultIMBioavailability,
 70:             defaultAbsorptionRateKa: [.intramuscular: 0.30, .subcutaneous: 0.22]
 71:         )
 72:         let testosteroneCypionate = Compound(
 73:             commonName: &quot;Testosterone Cypionate&quot;,
 74:             classType: .testosterone,
 75:             ester: &quot;Cypionate&quot;,
 76:             halfLifeDays: 7.0, // From previous app data
 77:             defaultBioavailability: defaultIMBioavailability,
 78:             defaultAbsorptionRateKa: [.intramuscular: 0.25, .subcutaneous: 0.18]
 79:         )
 80:         let testosteroneDecanoate = Compound(
 81:             commonName: &quot;Testosterone Decanoate&quot;,
 82:             classType: .testosterone,
 83:             ester: &quot;Decanoate&quot;,
 84:             halfLifeDays: 10.0, // BloomTechz (7-14 day midpoint)
 85:             defaultBioavailability: defaultIMBioavailability,
 86:             defaultAbsorptionRateKa: [.intramuscular: 0.18, .subcutaneous: 0.14]
 87:         )
 88:         let testosteroneUndecanoateInjectable = Compound(
 89:             commonName: &quot;Testosterone Undecanoate (Injectable)&quot;,
 90:             classType: .testosterone,
 91:             ester: &quot;Undecanoate&quot;,
 92:             halfLifeDays: 21.0, // PubMed, Wikipedia (18-24 day midpoint)
 93:             defaultBioavailability: defaultIMBioavailability,
 94:             defaultAbsorptionRateKa: [.intramuscular: 0.15, .subcutaneous: 0.10]
 95:         )
 96:         let testosteroneUndecanoateOral = Compound(
 97:             commonName: &quot;Testosterone Undecanoate (Oral)&quot;,
 98:             classType: .testosterone,
 99:             ester: &quot;Undecanoate&quot;,
100:             halfLifeDays: 0.067, // Wikipedia t½ 1.6h = 0.067d
101:             defaultBioavailability: defaultOralBioavailability,
102:             defaultAbsorptionRateKa: [.oral: 6.0] // Fast absorption orally
103:         )
104:         // Nandrolone
105:         let nandroloneDecanoate = Compound(
106:             commonName: &quot;Nandrolone Decanoate&quot;,
107:             classType: .nandrolone,
108:             ester: &quot;Decanoate&quot;,
109:             halfLifeDays: 9.0, // Wikipedia (6-12 day midpoint)
110:             defaultBioavailability: defaultIMBioavailability,
111:             defaultAbsorptionRateKa: [.intramuscular: 0.20, .subcutaneous: 0.15]
112:         )
113:         // Boldenone
114:         let boldenoneUndecylenate = Compound(
115:             commonName: &quot;Boldenone Undecylenate&quot;,
116:             classType: .boldenone,
117:             ester: &quot;Undecylenate&quot;,
118:             halfLifeDays: 5.125, // ScienceDirect ~123h = 5.125d
119:             defaultBioavailability: defaultIMBioavailability,
120:             defaultAbsorptionRateKa: [.intramuscular: 0.25, .subcutaneous: 0.18]
121:         )
122:         // Trenbolone
123:         let trenboloneAcetate = Compound(
124:             commonName: &quot;Trenbolone Acetate&quot;,
125:             classType: .trenbolone,
126:             ester: &quot;Acetate&quot;,
127:             halfLifeDays: 1.5, // ScienceDirect (1-2 day midpoint)
128:             defaultBioavailability: defaultIMBioavailability,
129:             defaultAbsorptionRateKa: [.intramuscular: 1.00, .subcutaneous: 0.70]
130:         )
131:         let trenboloneEnanthate = Compound(
132:             commonName: &quot;Trenbolone Enanthate&quot;,
133:             classType: .trenbolone,
134:             ester: &quot;Enanthate&quot;,
135:             halfLifeDays: 11.0, // Wikipedia
136:             defaultBioavailability: defaultIMBioavailability,
137:             defaultAbsorptionRateKa: [.intramuscular: 0.18, .subcutaneous: 0.14]
138:         )
139:         let trenboloneHexahydrobenzylcarbonate = Compound(
140:             commonName: &quot;Trenbolone Hexahydrobenzylcarbonate&quot;,
141:             classType: .trenbolone,
142:             ester: &quot;Hexahydrobenzylcarbonate&quot;,
143:             halfLifeDays: 8.0, // Wikipedia
144:             defaultBioavailability: defaultIMBioavailability,
145:             defaultAbsorptionRateKa: [.intramuscular: 0.20, .subcutaneous: 0.15]
146:         )
147:         // Stanozolol
148:         let stanozololSuspension = Compound(
149:             commonName: &quot;Stanozolol Suspension&quot;,
150:             classType: .stanozolol,
151:             ester: nil, // Suspension has no ester
152:             halfLifeDays: 1.0, // Wikipedia 24h
153:             defaultBioavailability: defaultIMBioavailability,
154:             defaultAbsorptionRateKa: [.intramuscular: 1.50, .subcutaneous: 1.00]
155:         )
156:         // Drostanolone (Masteron)
157:         let drostanolonePropionate = Compound(
158:             commonName: &quot;Drostanolone Propionate&quot;,
159:             classType: .drostanolone,
160:             ester: &quot;Propionate&quot;,
161:             halfLifeDays: 2.0, // Wikipedia
162:             defaultBioavailability: defaultIMBioavailability,
163:             defaultAbsorptionRateKa: [.intramuscular: 0.70, .subcutaneous: 0.50]
164:         )
165:         let drostanoloneEnanthate = Compound(
166:             commonName: &quot;Drostanolone Enanthate&quot;,
167:             classType: .drostanolone,
168:             ester: &quot;Enanthate&quot;,
169:             halfLifeDays: 5.0, // Wikipedia approx
170:             defaultBioavailability: defaultIMBioavailability,
171:             defaultAbsorptionRateKa: [.intramuscular: 0.30, .subcutaneous: 0.22]
172:         )
173:         // Metenolone (Primobolan)
174:         let metenoloneEnanthate = Compound(
175:             commonName: &quot;Metenolone Enanthate&quot;,
176:             classType: .metenolone,
177:             ester: &quot;Enanthate&quot;,
178:             halfLifeDays: 10.5, // Wikipedia
179:             defaultBioavailability: defaultIMBioavailability,
180:             defaultAbsorptionRateKa: [.intramuscular: 0.18, .subcutaneous: 0.15]
181:         )
182:         // Trestolone (MENT)
183:         let trestoloneAcetate = Compound(
184:             commonName: &quot;Trestolone Acetate&quot;,
185:             classType: .trestolone,
186:             ester: &quot;Acetate&quot;,
187:             halfLifeDays: 0.083, // PubMed 40min IV ~2h SC, conservatively using IV
188:             defaultBioavailability: defaultIMBioavailability,
189:             defaultAbsorptionRateKa: [.intramuscular: 2.00, .subcutaneous: 1.50]
190:         )
191:         // 1-Testosterone (DHB)
192:         let dhbCypionate = Compound(
193:             commonName: &quot;1-Testosterone Cypionate&quot;,
194:             classType: .dhb,
195:             ester: &quot;Cypionate&quot;,
196:             halfLifeDays: 8.0, // Wikipedia class analogue
197:             defaultBioavailability: defaultIMBioavailability,
198:             defaultAbsorptionRateKa: [.intramuscular: 0.22, .subcutaneous: 0.16]
199:         )
200:         // Add all compounds to the library
201:         compounds = [
202:             testosteronePropionate,
203:             testosteronePhenylpropionate,
204:             testosteroneIsocaproate,
205:             testosteroneEnanthate,
206:             testosteroneCypionate,
207:             testosteroneDecanoate,
208:             testosteroneUndecanoateInjectable,
209:             testosteroneUndecanoateOral,
210:             nandroloneDecanoate,
211:             boldenoneUndecylenate,
212:             trenboloneAcetate,
213:             trenboloneEnanthate,
214:             trenboloneHexahydrobenzylcarbonate,
215:             stanozololSuspension,
216:             drostanolonePropionate,
217:             drostanoloneEnanthate,
218:             metenoloneEnanthate,
219:             trestoloneAcetate,
220:             dhbCypionate
221:         ]
222:     }
223:     private func populateBlends() {
224:         // Helper to find compound ID by common name
225:         func findCompoundID(byName name: String) -&gt; UUID? {
226:             return compounds.first { $0.commonName == name }?.id
227:         }
228:         // Sustanon blends
229:         if let testP = findCompoundID(byName: &quot;Testosterone Propionate&quot;),
230:            let testPP = findCompoundID(byName: &quot;Testosterone Phenylpropionate&quot;),
231:            let testIso = findCompoundID(byName: &quot;Testosterone Isocaproate&quot;),
232:            let testDec = findCompoundID(byName: &quot;Testosterone Decanoate&quot;) {
233:             // Sustanon 250
234:             let sustanon250 = VialBlend(
235:                 name: &quot;Sustanon 250&quot;,
236:                 manufacturer: &quot;Organon&quot;,
237:                 description: &quot;Mixed testosterone esters for TRT&quot;,
238:                 components: [
239:                     VialBlend.Component(compoundID: testP, mgPerML: 30),
240:                     VialBlend.Component(compoundID: testPP, mgPerML: 60),
241:                     VialBlend.Component(compoundID: testIso, mgPerML: 60),
242:                     VialBlend.Component(compoundID: testDec, mgPerML: 100)
243:                 ]
244:             )
245:             // Sustanon 350
246:             let sustanon350 = VialBlend(
247:                 name: &quot;Sustanon 350&quot;,
248:                 manufacturer: &quot;Generic&quot;,
249:                 description: &quot;Higher concentration mixed testosterone esters&quot;,
250:                 components: [
251:                     VialBlend.Component(compoundID: testP, mgPerML: 40),
252:                     VialBlend.Component(compoundID: testPP, mgPerML: 80),
253:                     VialBlend.Component(compoundID: testIso, mgPerML: 80),
254:                     VialBlend.Component(compoundID: testDec, mgPerML: 150)
255:                 ]
256:             )
257:             // Sustanon 400
258:             let sustanon400 = VialBlend(
259:                 name: &quot;Sustanon 400&quot;,
260:                 manufacturer: &quot;Generic&quot;,
261:                 description: &quot;Highest concentration mixed testosterone esters&quot;,
262:                 components: [
263:                     VialBlend.Component(compoundID: testP, mgPerML: 50),
264:                     VialBlend.Component(compoundID: testPP, mgPerML: 100),
265:                     VialBlend.Component(compoundID: testIso, mgPerML: 100),
266:                     VialBlend.Component(compoundID: testDec, mgPerML: 150)
267:                 ]
268:             )
269:             blends.append(contentsOf: [sustanon250, sustanon350, sustanon400])
270:         }
271:         // Add more commercial blends as needed - could add Winstrol Susp 50, Masteron P 100, etc.
272:         // as mentioned in the guide, but for brevity I&apos;ll focus on just Sustanon blends for now
273:         // The following would be added for a complete implementation:
274:         // - Winstrol Susp 50
275:         // - Masteron P 100 &amp; E 200
276:         // - Primobolan E 100
277:         // - Tren Susp 50, Tren A 100, Tren E 200, Tren Hex 76
278:         // - Tren Mix 150
279:         // - Cut-Stack 150 &amp; 250
280:         // - MENT Ac 50
281:         // - DHB Cyp 100
282:     }
283: }

================
File: TestoSim/Models/CycleModel.swift
================
 1: import Foundation
 2: /// Represents a complete treatment cycle with multiple stages
 3: struct Cycle: Identifiable, Codable {
 4:     var id: UUID = UUID()
 5:     var name: String
 6:     var startDate: Date
 7:     var totalWeeks: Int
 8:     var notes: String?
 9:     var stages: [CycleStage] = []
10:     /// Calculated end date based on start date and total weeks
11:     var endDate: Date {
12:         Calendar.current.date(byAdding: .day, value: totalWeeks * 7, to: startDate) ?? startDate
13:     }
14:     /// Converts this cycle to a set of temporary InjectionProtocols for simulation
15:     func generateTemporaryProtocols(compoundLibrary: CompoundLibrary) -&gt; [InjectionProtocol] {
16:         // Each stage will create one or more protocols
17:         return stages.flatMap { stage in
18:             stage.generateProtocols(cycleStartDate: startDate, compoundLibrary: compoundLibrary)
19:         }
20:     }
21: }
22: /// Represents a single stage in a cycle with specific compounds/blends and timing
23: struct CycleStage: Identifiable, Codable {
24:     var id: UUID = UUID()
25:     var name: String
26:     var startWeek: Int  // Week number in the cycle (0-based)
27:     var durationWeeks: Int
28:     var compounds: [CompoundStageItem] = []
29:     var blends: [BlendStageItem] = []
30:     /// Start date calculated from cycle start date and stage&apos;s start week
31:     func startDate(from cycleStartDate: Date) -&gt; Date {
32:         Calendar.current.date(byAdding: .day, value: startWeek * 7, to: cycleStartDate) ?? cycleStartDate
33:     }
34:     /// End date calculated from start date and duration
35:     func endDate(from cycleStartDate: Date) -&gt; Date {
36:         let start = startDate(from: cycleStartDate)
37:         return Calendar.current.date(byAdding: .day, value: durationWeeks * 7, to: start) ?? start
38:     }
39:     /// Generates temporary protocols for each compound and blend in this stage
40:     func generateProtocols(cycleStartDate: Date, compoundLibrary: CompoundLibrary) -&gt; [InjectionProtocol] {
41:         var protocols: [InjectionProtocol] = []
42:         // Add compound protocols
43:         for compoundItem in compounds {
44:             let name = &quot;\(self.name) - \(compoundItem.compoundName)&quot;
45:             let treatmentProtocol = InjectionProtocol(
46:                 name: name,
47:                 doseMg: compoundItem.doseMg,
48:                 frequencyDays: compoundItem.frequencyDays,
49:                 startDate: startDate(from: cycleStartDate),
50:                 notes: &quot;Part of cycle: \(self.name)&quot;,
51:                 compoundID: compoundItem.compoundID,
52:                 selectedRoute: compoundItem.administrationRoute
53:             )
54:             protocols.append(treatmentProtocol)
55:         }
56:         // Add blend protocols
57:         for blendItem in blends {
58:             let name = &quot;\(self.name) - \(blendItem.blendName)&quot;
59:             let treatmentProtocol = InjectionProtocol(
60:                 name: name,
61:                 doseMg: blendItem.doseMg,
62:                 frequencyDays: blendItem.frequencyDays,
63:                 startDate: startDate(from: cycleStartDate),
64:                 notes: &quot;Part of cycle: \(self.name)&quot;,
65:                 blendID: blendItem.blendID,
66:                 selectedRoute: blendItem.administrationRoute
67:             )
68:             protocols.append(treatmentProtocol)
69:         }
70:         return protocols
71:     }
72: }
73: /// Represents a single compound item within a cycle stage
74: struct CompoundStageItem: Identifiable, Codable {
75:     var id: UUID = UUID()
76:     var compoundID: UUID
77:     var compoundName: String
78:     var doseMg: Double
79:     var frequencyDays: Double
80:     var administrationRoute: String // Compound.Route.rawValue
81: }
82: /// Represents a single blend item within a cycle stage
83: struct BlendStageItem: Identifiable, Codable {
84:     var id: UUID = UUID()
85:     var blendID: UUID
86:     var blendName: String
87:     var doseMg: Double
88:     var frequencyDays: Double
89:     var administrationRoute: String // Compound.Route.rawValue
90: }

================
File: TestoSim/Views/CompoundListView.swift
================
  1: import SwiftUI
  2: struct CompoundListView: View {
  3:     @EnvironmentObject var dataStore: AppDataStore
  4:     @Environment(\.dismiss) var dismiss
  5:     @Binding var selectedCompoundID: UUID?
  6:     @State private var searchText = &quot;&quot;
  7:     @State private var filterClass: Compound.Class?
  8:     @State private var filterRoute: Compound.Route?
  9:     var filteredCompounds: [Compound] {
 10:         let compounds = dataStore.compoundLibrary.compounds
 11:         return compounds.filter { compound in
 12:             // Apply search filter
 13:             let matchesSearch = searchText.isEmpty || 
 14:                 compound.fullDisplayName.localizedCaseInsensitiveContains(searchText)
 15:             // Apply class filter
 16:             let matchesClass = filterClass == nil || compound.classType == filterClass
 17:             // Apply route filter - compound must support the selected route
 18:             let matchesRoute = filterRoute == nil || 
 19:                 (compound.defaultBioavailability[filterRoute!] ?? 0.0) &gt; 0
 20:             return matchesSearch &amp;&amp; matchesClass &amp;&amp; matchesRoute
 21:         }
 22:     }
 23:     var body: some View {
 24:         NavigationView {
 25:             VStack {
 26:                 // Search and filters
 27:                 SearchBar(text: $searchText, placeholder: &quot;Search compounds&quot;)
 28:                 // Class filter
 29:                 ScrollView(.horizontal, showsIndicators: false) {
 30:                     HStack(spacing: 10) {
 31:                         ClassFilterButton(title: &quot;All&quot;, isSelected: filterClass == nil) {
 32:                             filterClass = nil
 33:                         }
 34:                         ForEach(Compound.Class.allCases, id: \.self) { classType in
 35:                             ClassFilterButton(
 36:                                 title: classType.displayName,
 37:                                 isSelected: filterClass == classType
 38:                             ) {
 39:                                 filterClass = classType
 40:                             }
 41:                         }
 42:                     }
 43:                     .padding(.horizontal)
 44:                 }
 45:                 // Route filter
 46:                 ScrollView(.horizontal, showsIndicators: false) {
 47:                     HStack(spacing: 10) {
 48:                         RouteFilterButton(title: &quot;All Routes&quot;, isSelected: filterRoute == nil) {
 49:                             filterRoute = nil
 50:                         }
 51:                         ForEach(Compound.Route.allCases, id: \.self) { route in
 52:                             RouteFilterButton(
 53:                                 title: route.displayName,
 54:                                 isSelected: filterRoute == route
 55:                             ) {
 56:                                 filterRoute = route
 57:                             }
 58:                         }
 59:                     }
 60:                     .padding(.horizontal)
 61:                 }
 62:                 // Compound list
 63:                 List {
 64:                     ForEach(filteredCompounds) { compound in
 65:                         CompoundRow(compound: compound, isSelected: selectedCompoundID == compound.id)
 66:                             .contentShape(Rectangle())
 67:                             .onTapGesture {
 68:                                 selectedCompoundID = compound.id
 69:                                 dismiss()
 70:                             }
 71:                     }
 72:                 }
 73:                 .listStyle(PlainListStyle())
 74:             }
 75:             .navigationTitle(&quot;Select Compound&quot;)
 76:             .toolbar {
 77:                 ToolbarItem(placement: .cancellationAction) {
 78:                     Button(&quot;Cancel&quot;) {
 79:                         dismiss()
 80:                     }
 81:                 }
 82:             }
 83:         }
 84:     }
 85: }
 86: // MARK: - Supporting Views
 87: struct SearchBar: View {
 88:     @Binding var text: String
 89:     var placeholder: String
 90:     var body: some View {
 91:         HStack {
 92:             Image(systemName: &quot;magnifyingglass&quot;)
 93:                 .foregroundColor(.secondary)
 94:             TextField(placeholder, text: $text)
 95:                 .disableAutocorrection(true)
 96:             if !text.isEmpty {
 97:                 Button(action: {
 98:                     text = &quot;&quot;
 99:                 }) {
100:                     Image(systemName: &quot;xmark.circle.fill&quot;)
101:                         .foregroundColor(.secondary)
102:                 }
103:             }
104:         }
105:         .padding(8)
106:         .background(Color(.systemGray6))
107:         .cornerRadius(10)
108:         .padding(.horizontal)
109:     }
110: }
111: struct ClassFilterButton: View {
112:     var title: String
113:     var isSelected: Bool
114:     var action: () -&gt; Void
115:     var body: some View {
116:         Button(action: action) {
117:             Text(title)
118:                 .padding(.vertical, 8)
119:                 .padding(.horizontal, 16)
120:                 .background(isSelected ? Color.blue : Color(.systemGray5))
121:                 .foregroundColor(isSelected ? .white : .primary)
122:                 .cornerRadius(20)
123:         }
124:     }
125: }
126: struct RouteFilterButton: View {
127:     var title: String
128:     var isSelected: Bool
129:     var action: () -&gt; Void
130:     var body: some View {
131:         Button(action: action) {
132:             Text(title)
133:                 .padding(.vertical, 8)
134:                 .padding(.horizontal, 16)
135:                 .background(isSelected ? Color.green : Color(.systemGray5))
136:                 .foregroundColor(isSelected ? .white : .primary)
137:                 .cornerRadius(20)
138:         }
139:     }
140: }
141: struct CompoundRow: View {
142:     var compound: Compound
143:     var isSelected: Bool
144:     var body: some View {
145:         HStack {
146:             VStack(alignment: .leading) {
147:                 Text(compound.fullDisplayName)
148:                     .font(.headline)
149:                 Text(&quot;Half-life: \(String(format: &quot;%.1f&quot;, compound.halfLifeDays)) days&quot;)
150:                     .font(.subheadline)
151:                     .foregroundColor(.secondary)
152:                 // Show supported routes
153:                 let supportedRoutes = compound.defaultBioavailability.keys.map { $0.displayName }.joined(separator: &quot;, &quot;)
154:                 Text(&quot;Routes: \(supportedRoutes)&quot;)
155:                     .font(.caption)
156:                     .foregroundColor(.secondary)
157:             }
158:             Spacer()
159:             if isSelected {
160:                 Image(systemName: &quot;checkmark&quot;)
161:                     .foregroundColor(.blue)
162:             }
163:         }
164:         .padding(.vertical, 4)
165:     }
166: }
167: #Preview {
168:     CompoundListView(selectedCompoundID: .constant(nil))
169:         .environmentObject(AppDataStore())
170: }

================
File: TestoSim/Views/InjectionHistoryView.swift
================
  1: import SwiftUI
  2: struct InjectionHistoryView: View {
  3:     @EnvironmentObject var dataStore: AppDataStore
  4:     @State private var filterBy: UUID? = nil
  5:     var body: some View {
  6:         NavigationView {
  7:             VStack {
  8:                 InjectionAdherenceStatsView()
  9:                     .padding()
 10:                     .background(Color(.systemBackground))
 11:                     .cornerRadius(10)
 12:                     .shadow(radius: 1)
 13:                     .padding(.horizontal)
 14:                 protocolFilterPicker
 15:                 List {
 16:                     if historyRecords.isEmpty {
 17:                         Text(&quot;No injection records found&quot;)
 18:                             .foregroundColor(.secondary)
 19:                             .italic()
 20:                             .frame(maxWidth: .infinity, alignment: .center)
 21:                             .listRowBackground(Color.clear)
 22:                     } else {
 23:                         ForEach(historyRecords) { record in
 24:                             InjectionRecordRow(record: record)
 25:                         }
 26:                     }
 27:                 }
 28:                 .listStyle(InsetGroupedListStyle())
 29:             }
 30:             .navigationTitle(&quot;Injection History&quot;)
 31:             .navigationBarTitleDisplayMode(.inline)
 32:             .toolbar {
 33:                 ToolbarItem(placement: .navigationBarTrailing) {
 34:                     Button(&quot;Clear Old&quot;) {
 35:                         dataStore.cleanupOldRecords()
 36:                     }
 37:                 }
 38:             }
 39:         }
 40:     }
 41:     private var protocolFilterPicker: some View {
 42:         Picker(&quot;Filter by Protocol&quot;, selection: $filterBy) {
 43:             Text(&quot;All Protocols&quot;).tag(nil as UUID?)
 44:             ForEach(dataStore.profile.protocols) { treatmentProtocol in
 45:                 Text(treatmentProtocol.name).tag(treatmentProtocol.id as UUID?)
 46:             }
 47:         }
 48:         .pickerStyle(MenuPickerStyle())
 49:         .padding(.horizontal)
 50:     }
 51:     private var historyRecords: [NotificationManager.InjectionRecord] {
 52:         dataStore.injectionHistory(for: filterBy)
 53:             .sorted(by: { $0.scheduledDate &gt; $1.scheduledDate })
 54:     }
 55: }
 56: struct InjectionRecordRow: View {
 57:     let record: NotificationManager.InjectionRecord
 58:     var body: some View {
 59:         VStack(alignment: .leading, spacing: 8) {
 60:             HStack {
 61:                 Text(&quot;\(record.compoundOrBlendName) \(record.doseMg.isFinite ? Int(record.doseMg) : 0)mg&quot;)
 62:                     .font(.headline)
 63:                 Spacer()
 64:                 statusBadge
 65:             }
 66:             HStack {
 67:                 Label {
 68:                     Text(record.scheduledDate, style: .date)
 69:                         .font(.subheadline)
 70:                 } icon: {
 71:                     Image(systemName: &quot;calendar&quot;)
 72:                         .foregroundColor(.secondary)
 73:                 }
 74:                 Spacer()
 75:                 Label {
 76:                     Text(record.scheduledDate, style: .time)
 77:                         .font(.subheadline)
 78:                 } icon: {
 79:                     Image(systemName: &quot;clock&quot;)
 80:                         .foregroundColor(.secondary)
 81:                 }
 82:             }
 83:             if let acknowledgedDate = record.acknowledgedDate {
 84:                 Text(&quot;Taken: \(acknowledgedDate, style: .date) at \(acknowledgedDate, style: .time)&quot;)
 85:                     .font(.subheadline)
 86:                     .foregroundColor(.secondary)
 87:                     .padding(.top, 2)
 88:             }
 89:         }
 90:         .padding(.vertical, 4)
 91:     }
 92:     private var statusBadge: some View {
 93:         HStack(spacing: 4) {
 94:             Circle()
 95:                 .fill(statusColor)
 96:                 .frame(width: 8, height: 8)
 97:             Text(statusText)
 98:                 .font(.caption)
 99:                 .foregroundColor(statusColor)
100:         }
101:         .padding(.horizontal, 8)
102:         .padding(.vertical, 4)
103:         .background(statusColor.opacity(0.1))
104:         .cornerRadius(12)
105:     }
106:     private var statusColor: Color {
107:         switch record.status {
108:         case .onTime:
109:             return .green
110:         case .late:
111:             return .orange
112:         case .missed:
113:             return .red
114:         }
115:     }
116:     private var statusText: String {
117:         switch record.status {
118:         case .onTime:
119:             return &quot;On Time&quot;
120:         case .late:
121:             return &quot;Late&quot;
122:         case .missed:
123:             return &quot;Missed&quot;
124:         }
125:     }
126: }
127: struct InjectionAdherenceStatsView: View {
128:     @EnvironmentObject var dataStore: AppDataStore
129:     private var allRecords: [NotificationManager.InjectionRecord] {
130:         dataStore.injectionHistory()
131:     }
132:     private var onTimeCount: Int {
133:         allRecords.filter { $0.status == .onTime }.count
134:     }
135:     private var lateCount: Int {
136:         allRecords.filter { $0.status == .late }.count
137:     }
138:     private var missedCount: Int {
139:         allRecords.filter { $0.status == .missed }.count
140:     }
141:     private var adherencePercentage: Double {
142:         if allRecords.isEmpty {
143:             return 0
144:         }
145:         return Double(onTimeCount + lateCount) / Double(allRecords.count) * 100
146:     }
147:     var body: some View {
148:         VStack {
149:             Text(&quot;Adherence Rate: \(adherencePercentage.isFinite ? Int(adherencePercentage) : 0)%&quot;)
150:                 .font(.headline)
151:                 .padding(.bottom, 4)
152:             HStack(spacing: 20) {
153:                 StatItem(label: &quot;On Time&quot;, value: onTimeCount, color: .green)
154:                 StatItem(label: &quot;Late&quot;, value: lateCount, color: .orange)
155:                 StatItem(label: &quot;Missed&quot;, value: missedCount, color: .red)
156:             }
157:         }
158:     }
159: }
160: struct StatItem: View {
161:     let label: String
162:     let value: Int
163:     let color: Color
164:     var body: some View {
165:         VStack {
166:             Text(&quot;\(value)&quot;)
167:                 .font(.title2)
168:                 .fontWeight(.bold)
169:                 .foregroundColor(color)
170:             Text(label)
171:                 .font(.caption)
172:                 .foregroundColor(.secondary)
173:         }
174:     }
175: }
176: struct InjectionHistoryView_Previews: PreviewProvider {
177:     static var previews: some View {
178:         InjectionHistoryView()
179:             .environmentObject(AppDataStore())
180:     }
181: }

================
File: TestoSim/Views/VialBlendListView.swift
================
  1: import SwiftUI
  2: struct VialBlendListView: View {
  3:     @EnvironmentObject var dataStore: AppDataStore
  4:     @Environment(\.dismiss) var dismiss
  5:     @Binding var selectedBlendID: UUID?
  6:     @State private var searchText = &quot;&quot;
  7:     @State private var filterClass: Compound.Class?
  8:     var filteredBlends: [VialBlend] {
  9:         let blends = dataStore.compoundLibrary.blends
 10:         return blends.filter { blend in
 11:             // Apply search filter
 12:             let matchesSearch = searchText.isEmpty || 
 13:                 blend.name.localizedCaseInsensitiveContains(searchText) ||
 14:                 (blend.manufacturer?.localizedCaseInsensitiveContains(searchText) ?? false)
 15:             // Apply class filter (check if blend contains any compound of the selected class)
 16:             let matchesClass: Bool
 17:             if let filterClass = filterClass {
 18:                 matchesClass = blend.resolvedComponents(using: dataStore.compoundLibrary)
 19:                     .contains { $0.compound.classType == filterClass }
 20:             } else {
 21:                 matchesClass = true
 22:             }
 23:             return matchesSearch &amp;&amp; matchesClass
 24:         }
 25:     }
 26:     var body: some View {
 27:         NavigationView {
 28:             VStack {
 29:                 // Search and filters
 30:                 SearchBar(text: $searchText, placeholder: &quot;Search blends&quot;)
 31:                 // Class filter
 32:                 ScrollView(.horizontal, showsIndicators: false) {
 33:                     HStack(spacing: 10) {
 34:                         ClassFilterButton(title: &quot;All&quot;, isSelected: filterClass == nil) {
 35:                             filterClass = nil
 36:                         }
 37:                         ForEach(Compound.Class.allCases, id: \.self) { classType in
 38:                             ClassFilterButton(
 39:                                 title: classType.displayName,
 40:                                 isSelected: filterClass == classType
 41:                             ) {
 42:                                 filterClass = classType
 43:                             }
 44:                         }
 45:                     }
 46:                     .padding(.horizontal)
 47:                 }
 48:                 // Blend list
 49:                 List {
 50:                     ForEach(filteredBlends) { blend in
 51:                         BlendRow(
 52:                             blend: blend, 
 53:                             library: dataStore.compoundLibrary,
 54:                             isSelected: selectedBlendID == blend.id
 55:                         )
 56:                         .contentShape(Rectangle())
 57:                         .onTapGesture {
 58:                             selectedBlendID = blend.id
 59:                             dismiss()
 60:                         }
 61:                     }
 62:                 }
 63:                 .listStyle(PlainListStyle())
 64:             }
 65:             .navigationTitle(&quot;Select Blend&quot;)
 66:             .toolbar {
 67:                 ToolbarItem(placement: .cancellationAction) {
 68:                     Button(&quot;Cancel&quot;) {
 69:                         dismiss()
 70:                     }
 71:                 }
 72:             }
 73:         }
 74:     }
 75: }
 76: struct BlendRow: View {
 77:     var blend: VialBlend
 78:     var library: CompoundLibrary
 79:     var isSelected: Bool
 80:     var body: some View {
 81:         HStack {
 82:             VStack(alignment: .leading) {
 83:                 Text(blend.name)
 84:                     .font(.headline)
 85:                 if let manufacturer = blend.manufacturer {
 86:                     Text(manufacturer)
 87:                         .font(.subheadline)
 88:                         .foregroundColor(.secondary)
 89:                 }
 90:                 Text(blend.compositionDescription(using: library))
 91:                     .font(.caption)
 92:                     .foregroundColor(.secondary)
 93:                     .lineLimit(2)
 94:                 Text(&quot;Total: \(String(format: &quot;%.0f&quot;, blend.totalConcentration)) mg/mL&quot;)
 95:                     .font(.caption)
 96:                     .foregroundColor(.secondary)
 97:             }
 98:             Spacer()
 99:             if isSelected {
100:                 Image(systemName: &quot;checkmark&quot;)
101:                     .foregroundColor(.blue)
102:             }
103:         }
104:         .padding(.vertical, 4)
105:     }
106: }
107: #Preview {
108:     VialBlendListView(selectedBlendID: .constant(nil))
109:         .environmentObject(AppDataStore())
110: }

================
File: TestoSim/Config-Sample.plist
================
1: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
2: &lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
3: &lt;plist version=&quot;1.0&quot;&gt;
4: &lt;dict&gt;
5:     &lt;key&gt;OPENAI_API_KEY&lt;/key&gt;
6:     &lt;string&gt;PLACEHOLDER_API_KEY&lt;/string&gt;
7: &lt;/dict&gt;
8: &lt;/plist&gt;

================
File: TestoSim.xcodeproj/project.xcworkspace/contents.xcworkspacedata
================
1: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
2: &lt;Workspace
3:    version = &quot;1.0&quot;&gt;
4:    &lt;FileRef
5:       location = &quot;self:&quot;&gt;
6:    &lt;/FileRef&gt;
7: &lt;/Workspace&gt;

================
File: TestoSimTests/TestoSimTests.swift
================
 1: //
 2: //  TestoSimTests.swift
 3: //  TestoSimTests
 4: //
 5: //  Created by Jesper Vang on 01/05/2025.
 6: //
 7: import Testing
 8: struct TestoSimTests {
 9:     @Test func example() async throws {
10:         // Write your test here and use APIs like `#expect(...)` to check expected conditions.
11:     }
12: }

================
File: TestoSimUITests/TestoSimUITests.swift
================
 1: //
 2: //  TestoSimUITests.swift
 3: //  TestoSimUITests
 4: //
 5: //  Created by Jesper Vang on 01/05/2025.
 6: //
 7: import XCTest
 8: final class TestoSimUITests: XCTestCase {
 9:     override func setUpWithError() throws {
10:         // Put setup code here. This method is called before the invocation of each test method in the class.
11:         // In UI tests it is usually best to stop immediately when a failure occurs.
12:         continueAfterFailure = false
13:         // In UI tests it’s important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.
14:     }
15:     override func tearDownWithError() throws {
16:         // Put teardown code here. This method is called after the invocation of each test method in the class.
17:     }
18:     @MainActor
19:     func testExample() throws {
20:         // UI tests must launch the application that they test.
21:         let app = XCUIApplication()
22:         app.launch()
23:         // Use XCTAssert and related functions to verify your tests produce the correct results.
24:     }
25:     @MainActor
26:     func testLaunchPerformance() throws {
27:         // This measures how long it takes to launch your application.
28:         measure(metrics: [XCTApplicationLaunchMetric()]) {
29:             XCUIApplication().launch()
30:         }
31:     }
32: }

================
File: TestoSimUITests/TestoSimUITestsLaunchTests.swift
================
 1: //
 2: //  TestoSimUITestsLaunchTests.swift
 3: //  TestoSimUITests
 4: //
 5: //  Created by Jesper Vang on 01/05/2025.
 6: //
 7: import XCTest
 8: final class TestoSimUITestsLaunchTests: XCTestCase {
 9:     override class var runsForEachTargetApplicationUIConfiguration: Bool {
10:         true
11:     }
12:     override func setUpWithError() throws {
13:         continueAfterFailure = false
14:     }
15:     @MainActor
16:     func testLaunch() throws {
17:         let app = XCUIApplication()
18:         app.launch()
19:         // Insert steps here to perform after app launch but before taking a screenshot,
20:         // such as logging into a test account or navigating somewhere in the app
21:         let attachment = XCTAttachment(screenshot: app.screenshot())
22:         attachment.name = &quot;Launch Screen&quot;
23:         attachment.lifetime = .keepAlways
24:         add(attachment)
25:     }
26: }

================
File: add_files_to_target.sh
================
 1: #!/bin/bash
 2: # This script lists all Swift files in the project that need to be added to the target
 3: # Run this script, then add these files to your target in Xcode
 4: echo &quot;Swift files to add to target:&quot;
 5: echo &quot;&quot;
 6: # Find all Swift files in the TestoSim directory
 7: find ./TestoSim -name &quot;*.swift&quot; | sort
 8: echo &quot;&quot;
 9: echo &quot;Instructions:&quot;
10: echo &quot;1. In Xcode, select all these files in the Project Navigator (left sidebar)&quot;
11: echo &quot;2. In the File Inspector (right sidebar, first tab), check the box for TestoSim target&quot;
12: echo &quot;3. Clean and build the project (Cmd+Shift+K, then Cmd+B)&quot;

================
File: build-test.sh
================
 1: #!/bin/bash
 2: # TestoSim build script - avoids launching multiple simulators
 3: # Usage: ./build-test.sh [clean]
 4: set -o pipefail
 5: # Default simulator device
 6: DEVICE=&quot;iPhone 16,OS=18.4&quot;
 7: # Check if xcbeautify is installed
 8: if ! command -v xcbeautify &amp;&gt; /dev/null; then
 9:     echo &quot;xcbeautify not found. Installing...&quot;
10:     brew install xcbeautify
11: fi
12: # Check if we need to clean
13: if [ &quot;$1&quot; == &quot;clean&quot; ]; then
14:     echo &quot;Cleaning build...&quot;
15:     xcodebuild -project TestoSim.xcodeproj -scheme TestoSim -destination &quot;platform=iOS Simulator,name=$DEVICE&quot; clean | xcbeautify
16: fi
17: # Build only, don&apos;t run
18: echo &quot;Building TestoSim...&quot;
19: xcodebuild -project TestoSim.xcodeproj -scheme TestoSim -destination &quot;platform=iOS Simulator,name=$DEVICE&quot; build | xcbeautify
20: # Check build status
21: if [ $? -eq 0 ]; then
22:     echo &quot;✅ Build succeeded. Use SweetPad to run in simulator.&quot;
23:     echo &quot;&quot;
24:     echo &quot;To run in SweetPad:&quot;
25:     echo &quot;1. Open VS Code with SweetPad extension&quot;
26:     echo &quot;2. Run task &apos;SweetPad: Build&apos; from command palette or context menu&quot;
27:     echo &quot;&quot;
28:     echo &quot;This avoids launching multiple simulators.&quot;
29: else
30:     echo &quot;❌ Build failed.&quot;
31: fi

================
File: buildServer.json
================
 1: {
 2: 	&quot;name&quot;: &quot;xcode build server&quot;,
 3: 	&quot;version&quot;: &quot;0.2&quot;,
 4: 	&quot;bspVersion&quot;: &quot;2.0&quot;,
 5: 	&quot;languages&quot;: [
 6: 		&quot;c&quot;,
 7: 		&quot;cpp&quot;,
 8: 		&quot;objective-c&quot;,
 9: 		&quot;objective-cpp&quot;,
10: 		&quot;swift&quot;
11: 	],
12: 	&quot;argv&quot;: [
13: 		&quot;/opt/homebrew/bin/xcode-build-server&quot;
14: 	],
15: 	&quot;workspace&quot;: &quot;/Users/jesper/Projects/Dev_projects/Xcode/TestoSim/TestoSim.xcodeproj/project.xcworkspace&quot;,
16: 	&quot;build_root&quot;: &quot;/Users/jesper/Library/Developer/Xcode/DerivedData/TestoSim-amdpjdmzwgneoqgnxzlcnphserjo&quot;,
17: 	&quot;scheme&quot;: &quot;TestoSim&quot;,
18: 	&quot;kind&quot;: &quot;xcode&quot;
19: }

================
File: close-simulators.sh
================
 1: #!/bin/bash
 2: # TestoSim simulator management - closes all running simulators
 3: # Usage: ./close-simulators.sh
 4: echo &quot;Checking for running simulators...&quot;
 5: RUNNING_SIMS=$(xcrun simctl list devices | grep -i &quot;booted&quot; | wc -l)
 6: if [ $RUNNING_SIMS -gt 0 ]; then
 7:     echo &quot;Found $RUNNING_SIMS running simulator(s). Shutting down...&quot;
 8:     xcrun simctl shutdown all
 9:     echo &quot;All simulators are now closed.&quot;
10: else
11:     echo &quot;No running simulators found.&quot;
12: fi

================
File: launch-test.sh
================
 1: #!/bin/bash
 2: # TestoSim test launcher - uses a single simulator instance
 3: # Usage: ./launch-test.sh [device_name]
 4: # Example: ./launch-test.sh &quot;iPhone 16&quot;
 5: set -o pipefail
 6: # Default device if not specified
 7: DEFAULT_DEVICE=&quot;iPhone 16&quot;
 8: DEVICE=&quot;${1:-$DEFAULT_DEVICE}&quot;
 9: echo &quot;📱 Using device: $DEVICE&quot;
10: # Check for any running simulators first
11: RUNNING_SIMS=$(xcrun simctl list devices | grep -i &quot;booted&quot; | wc -l)
12: if [ $RUNNING_SIMS -gt 0 ]; then
13:     echo &quot;⚠️ Found running simulators. Shutting them down first...&quot;
14:     xcrun simctl shutdown all
15:     sleep 2
16: fi
17: # Boot the specific simulator
18: echo &quot;🚀 Booting simulator: $DEVICE&quot;
19: xcrun simctl boot &quot;$DEVICE&quot; 2&gt;/dev/null || echo &quot;ℹ️ Device may already be booted&quot;
20: # Build the app
21: echo &quot;🔨 Building TestoSim...&quot;
22: xcodebuild -project TestoSim.xcodeproj -scheme TestoSim -destination &quot;platform=iOS Simulator,name=$DEVICE&quot; build | xcbeautify
23: # Check if build succeeded
24: if [ $? -ne 0 ]; then
25:     echo &quot;❌ Build failed. Exiting.&quot;
26:     exit 1
27: fi
28: # Install and launch
29: echo &quot;📲 Installing and launching app...&quot;
30: APP_PATH=$(find ${HOME}/Library/Developer/Xcode/DerivedData/TestoSim-*/Build/Products/Debug-iphonesimulator -name &quot;TestoSim.app&quot; -type d | head -n 1)
31: if [ -z &quot;$APP_PATH&quot; ]; then
32:     echo &quot;❌ Could not find built app. Path may be different.&quot;
33:     exit 1
34: fi
35: xcrun simctl install &quot;$DEVICE&quot; &quot;$APP_PATH&quot;
36: xcrun simctl launch &quot;$DEVICE&quot; &quot;$(defaults read &quot;$APP_PATH/Info&quot; CFBundleIdentifier)&quot;
37: echo &quot;✅ App launched in a single simulator instance.&quot;
38: echo &quot;📝 To close all simulators when done, run: ./close-simulators.sh&quot;

================
File: TestoSim/Models/CDBloodSample+CoreDataClass.swift
================
 1: //
 2: //  CDBloodSample+CoreDataClass.swift
 3: //  TestoSim
 4: //
 5: //  Created by Jesper Vang on 02/05/2025.
 6: //
 7: //
 8: import Foundation
 9: import CoreData
10: @objc(CDBloodSample)
11: public class CDBloodSample: NSManagedObject {
12: }

================
File: TestoSim/Models/CDCompound+CoreDataClass.swift
================
 1: //
 2: //  CDCompound+CoreDataClass.swift
 3: //  TestoSim
 4: //
 5: //  Created by Jesper Vang on 02/05/2025.
 6: //
 7: //
 8: import Foundation
 9: import CoreData
10: @objc(CDCompound)
11: public class CDCompound: NSManagedObject {
12: }

================
File: TestoSim/Models/CDInjectionProtocol+CoreDataClass.swift
================
 1: //
 2: //  CDInjectionProtocol+CoreDataClass.swift
 3: //  TestoSim
 4: //
 5: //  Created by Jesper Vang on 02/05/2025.
 6: //
 7: //
 8: import Foundation
 9: import CoreData
10: @objc(CDInjectionProtocol)
11: public class CDInjectionProtocol: NSManagedObject {
12: }

================
File: TestoSim/Models/CDUserProfile+CoreDataClass.swift
================
 1: //
 2: //  CDUserProfile+CoreDataClass.swift
 3: //  TestoSim
 4: //
 5: //  Created by Jesper Vang on 02/05/2025.
 6: //
 7: //
 8: import Foundation
 9: import CoreData
10: @objc(CDUserProfile)
11: public class CDUserProfile: NSManagedObject {
12: }

================
File: TestoSim/Models/CDVialBlend+CoreDataClass.swift
================
 1: //
 2: //  CDVialBlend+CoreDataClass.swift
 3: //  TestoSim
 4: //
 5: //  Created by Jesper Vang on 02/05/2025.
 6: //
 7: //
 8: import Foundation
 9: import CoreData
10: @objc(CDVialBlend)
11: public class CDVialBlend: NSManagedObject {
12: }

================
File: TestoSim/Models/CDVialComponent+CoreDataClass.swift
================
 1: //
 2: //  CDVialComponent+CoreDataClass.swift
 3: //  TestoSim
 4: //
 5: //  Created by Jesper Vang on 02/05/2025.
 6: //
 7: //
 8: import Foundation
 9: import CoreData
10: @objc(CDVialComponent)
11: public class CDVialComponent: NSManagedObject {
12: }

================
File: TestoSim/Models/DataPoint.swift
================
1: import Foundation
2: struct DataPoint: Identifiable {
3:     let id = UUID()
4:     let time: Date
5:     let level: Double
6: }

================
File: TestoSim/Models/VialBlend.swift
================
 1: import Foundation
 2: struct VialBlend: Identifiable, Codable, Hashable {
 3:     struct Component: Codable, Hashable {
 4:         let compoundID: UUID
 5:         let mgPerML: Double
 6:         init(compoundID: UUID, mgPerML: Double) {
 7:             self.compoundID = compoundID
 8:             self.mgPerML = mgPerML
 9:         }
10:     }
11:     let id: UUID
12:     var name: String
13:     var manufacturer: String?
14:     var description: String?
15:     var components: [Component]
16:     init(id: UUID = UUID(), 
17:          name: String, 
18:          manufacturer: String? = nil, 
19:          description: String? = nil, 
20:          components: [Component]) {
21:         self.id = id
22:         self.name = name
23:         self.manufacturer = manufacturer
24:         self.description = description
25:         self.components = components
26:     }
27:     // Total concentration in mg/mL
28:     var totalConcentration: Double {
29:         components.reduce(0) { $0 + $1.mgPerML }
30:     }
31:     // Returns components with their actual compounds (requires CompoundLibrary lookup)
32:     func resolvedComponents(using library: CompoundLibrary) -&gt; [(compound: Compound, mgPerML: Double)] {
33:         return components.compactMap { component in
34:             guard let compound = library.compound(withID: component.compoundID) else {
35:                 return nil
36:             }
37:             return (compound: compound, mgPerML: component.mgPerML)
38:         }
39:     }
40:     // Creates a descriptive string representing the blend contents
41:     func compositionDescription(using library: CompoundLibrary) -&gt; String {
42:         let resolved = resolvedComponents(using: library)
43:         if resolved.isEmpty {
44:             return &quot;Unknown composition&quot;
45:         }
46:         // Completely rewritten to avoid any string interpolation complexity
47:         let descriptions = resolved.map { component -&gt; String in
48:             let name = component.compound.fullDisplayName
49:             let dosage = Int(component.mgPerML)
50:             return name + &quot; &quot; + String(dosage) + &quot;mg/mL&quot;
51:         }
52:         return descriptions.joined(separator: &quot;, &quot;)
53:     }
54: }

================
File: TestoSim/ViewModels/NotificationManager.swift
================
  1: import Foundation
  2: import UserNotifications
  3: import SwiftUI
  4: class NotificationManager: NSObject, UNUserNotificationCenterDelegate {
  5:     static let shared = NotificationManager()
  6:     enum LeadTime: String, CaseIterable, Identifiable {
  7:         case oneHour = &quot;1 hour&quot;
  8:         case sixHours = &quot;6 hours&quot;
  9:         case twelveHours = &quot;12 hours&quot;
 10:         var id: String { self.rawValue }
 11:         var timeInterval: TimeInterval {
 12:             switch self {
 13:             case .oneHour: return 3600
 14:             case .sixHours: return 21600
 15:             case .twelveHours: return 43200
 16:             }
 17:         }
 18:     }
 19:     enum AdherenceStatus: String, Codable {
 20:         case onTime, late, missed
 21:     }
 22:     struct InjectionRecord: Codable, Identifiable {
 23:         let id: UUID
 24:         let protocolID: UUID
 25:         let scheduledDate: Date
 26:         let acknowledgedDate: Date?
 27:         let status: AdherenceStatus
 28:         let doseMg: Double
 29:         let compoundOrBlendName: String
 30:         var isAcknowledged: Bool {
 31:             return acknowledgedDate != nil
 32:         }
 33:     }
 34:     // User preferences
 35:     var notificationsEnabled: Bool {
 36:         get { UserDefaults.standard.bool(forKey: &quot;notificationsEnabled&quot;) }
 37:         set { UserDefaults.standard.set(newValue, forKey: &quot;notificationsEnabled&quot;) }
 38:     }
 39:     var soundEnabled: Bool {
 40:         get { UserDefaults.standard.bool(forKey: &quot;notificationSoundEnabled&quot;) }
 41:         set { UserDefaults.standard.set(newValue, forKey: &quot;notificationSoundEnabled&quot;) }
 42:     }
 43:     var selectedLeadTime: LeadTime {
 44:         get {
 45:             if let storedValue = UserDefaults.standard.string(forKey: &quot;notificationLeadTime&quot;),
 46:                let leadTime = LeadTime(rawValue: storedValue) {
 47:                 return leadTime
 48:             }
 49:             return .oneHour
 50:         }
 51:         set {
 52:             UserDefaults.standard.set(newValue.rawValue, forKey: &quot;notificationLeadTime&quot;)
 53:         }
 54:     }
 55:     // Adherence tracking
 56:     private var injectionRecords: [InjectionRecord] = []
 57:     override init() {
 58:         super.init()
 59:         // Set delegate for handling notifications when app is in foreground
 60:         UNUserNotificationCenter.current().delegate = self
 61:         // Load adherence records
 62:         loadInjectionRecords()
 63:     }
 64:     // MARK: - Notification Permissions
 65:     func requestNotificationPermission() async -&gt; Bool {
 66:         do {
 67:             let options: UNAuthorizationOptions = [.alert, .sound, .badge]
 68:             return try await UNUserNotificationCenter.current().requestAuthorization(options: options)
 69:         } catch {
 70:             print(&quot;Error requesting notification permission: \(error)&quot;)
 71:             return false
 72:         }
 73:     }
 74:     // MARK: - Scheduling Notifications
 75:     func scheduleNotifications(for protocol: InjectionProtocol, using compoundLibrary: CompoundLibrary) {
 76:         guard notificationsEnabled else { return }
 77:         // Cancel existing notifications for this protocol
 78:         cancelNotifications(for: `protocol`.id)
 79:         // Calculate next injection dates from today onwards
 80:         let today = Date()
 81:         let simulationEndDate = today.addingTimeInterval(365 * 24 * 3600) // Schedule for up to a year
 82:         let injectionDates = `protocol`.injectionDates(from: today, upto: simulationEndDate)
 83:         // Get compound or blend name for the notification
 84:         let itemName: String
 85:         if let compoundID = `protocol`.compoundID, 
 86:            let compound = compoundLibrary.compound(withID: compoundID) {
 87:             itemName = compound.commonName
 88:         } else if let blendID = `protocol`.blendID,
 89:                   let blend = compoundLibrary.blend(withID: blendID) {
 90:             itemName = blend.name
 91:         } else {
 92:             itemName = &quot;medication&quot;
 93:         }
 94:         // Schedule notifications for each upcoming injection
 95:         for injectionDate in injectionDates {
 96:             // Calculate notification time based on lead time preference
 97:             let notificationDate = injectionDate.addingTimeInterval(-selectedLeadTime.timeInterval)
 98:             // Only schedule if the notification date is in the future
 99:             if notificationDate &gt; today {
100:                 scheduleInjectionNotification(
101:                     for: `protocol`.id,
102:                     protocolName: `protocol`.name,
103:                     compoundName: itemName,
104:                     doseMg: `protocol`.doseMg,
105:                     injectionDate: injectionDate,
106:                     notificationDate: notificationDate
107:                 )
108:                 // Also track this upcoming injection in our records
109:                 let newRecord = InjectionRecord(
110:                     id: UUID(),
111:                     protocolID: `protocol`.id,
112:                     scheduledDate: injectionDate,
113:                     acknowledgedDate: nil,
114:                     status: .onTime, // Default status will be updated later
115:                     doseMg: `protocol`.doseMg,
116:                     compoundOrBlendName: itemName
117:                 )
118:                 // Only add if we don&apos;t already have a record for this date
119:                 if !injectionRecords.contains(where: { 
120:                     $0.protocolID == newRecord.protocolID &amp;&amp; 
121:                     Calendar.current.isDate($0.scheduledDate, inSameDayAs: newRecord.scheduledDate)
122:                 }) {
123:                     injectionRecords.append(newRecord)
124:                 }
125:             }
126:         }
127:         // Save the updated records
128:         saveInjectionRecords()
129:     }
130:     private func scheduleInjectionNotification(for protocolID: UUID, protocolName: String, compoundName: String, doseMg: Double, injectionDate: Date, notificationDate: Date) {
131:         // Create a unique identifier for this notification
132:         let identifier = &quot;injection-\(protocolID.uuidString)-\(injectionDate.timeIntervalSince1970)&quot;
133:         // Create the notification content
134:         let content = UNMutableNotificationContent()
135:         content.title = &quot;Injection Reminder&quot;
136:         content.body = &quot;Time for your \(doseMg)mg \(compoundName) injection (\(protocolName))&quot;
137:         content.sound = soundEnabled ? UNNotificationSound.default : nil
138:         content.userInfo = [
139:             &quot;protocolID&quot;: protocolID.uuidString,
140:             &quot;injectionDate&quot;: injectionDate.timeIntervalSince1970,
141:             &quot;type&quot;: &quot;injection-reminder&quot;
142:         ]
143:         // Create date components for a precise date
144:         let dateComponents = Calendar.current.dateComponents(
145:             [.year, .month, .day, .hour, .minute, .second],
146:             from: notificationDate
147:         )
148:         // Create the trigger
149:         let trigger = UNCalendarNotificationTrigger(dateMatching: dateComponents, repeats: false)
150:         // Create the request
151:         let request = UNNotificationRequest(identifier: identifier, content: content, trigger: trigger)
152:         // Add it to the notification center
153:         UNUserNotificationCenter.current().add(request) { error in
154:             if let error = error {
155:                 print(&quot;Error scheduling notification: \(error)&quot;)
156:             }
157:         }
158:     }
159:     func cancelNotifications(for protocolID: UUID) {
160:         // Get all pending notification requests
161:         UNUserNotificationCenter.current().getPendingNotificationRequests { requests in
162:             // Find all requests for this protocol
163:             let identifiers = requests
164:                 .filter { $0.content.userInfo[&quot;protocolID&quot;] as? String == protocolID.uuidString }
165:                 .map { $0.identifier }
166:             // Remove these notifications
167:             UNUserNotificationCenter.current().removePendingNotificationRequests(withIdentifiers: identifiers)
168:         }
169:     }
170:     func cancelAllNotifications() {
171:         UNUserNotificationCenter.current().removeAllPendingNotificationRequests()
172:     }
173:     // MARK: - Notification Delegate Methods
174:     func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -&gt; Void) {
175:         // Display notification even when app is in foreground
176:         completionHandler([.banner, .sound, .badge])
177:     }
178:     func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) {
179:         // Handle the user&apos;s response to the notification
180:         let userInfo = response.notification.request.content.userInfo
181:         if userInfo[&quot;type&quot;] as? String == &quot;injection-reminder&quot;,
182:            let protocolIDString = userInfo[&quot;protocolID&quot;] as? String,
183:            let protocolID = UUID(uuidString: protocolIDString),
184:            let injectionTimeInterval = userInfo[&quot;injectionDate&quot;] as? TimeInterval {
185:             let injectionDate = Date(timeIntervalSince1970: injectionTimeInterval)
186:             acknowledgeInjection(protocolID: protocolID, injectionDate: injectionDate)
187:         }
188:         completionHandler()
189:     }
190:     // MARK: - Adherence Tracking
191:     func acknowledgeInjection(protocolID: UUID, injectionDate: Date) {
192:         let now = Date()
193:         // Find the record for this injection
194:         if let index = injectionRecords.firstIndex(where: { 
195:             $0.protocolID == protocolID &amp;&amp; 
196:             Calendar.current.isDate($0.scheduledDate, inSameDayAs: injectionDate)
197:         }) {
198:             // Update the record
199:             let record = injectionRecords[index]
200:             // Determine adherence status
201:             let hoursBetween = injectionDate.distance(to: now) / 3600
202:             var status: AdherenceStatus
203:             if hoursBetween &lt; 24 {
204:                 status = .onTime
205:             } else if hoursBetween &lt; 48 {
206:                 status = .late
207:             } else {
208:                 status = .missed
209:             }
210:             // Create new record with updated status
211:             let updatedRecord = InjectionRecord(
212:                 id: record.id,
213:                 protocolID: record.protocolID,
214:                 scheduledDate: record.scheduledDate,
215:                 acknowledgedDate: now,
216:                 status: status,
217:                 doseMg: record.doseMg,
218:                 compoundOrBlendName: record.compoundOrBlendName
219:             )
220:             // Update the record
221:             injectionRecords[index] = updatedRecord
222:             saveInjectionRecords()
223:         }
224:     }
225:     // MARK: - Analytics
226:     func adherenceStats() -&gt; (total: Int, onTime: Int, late: Int, missed: Int) {
227:         let acknowledged = injectionRecords.filter { $0.isAcknowledged }
228:         let onTime = acknowledged.filter { $0.status == .onTime }.count
229:         let late = acknowledged.filter { $0.status == .late }.count
230:         let missed = acknowledged.filter { $0.status == .missed }.count
231:         return (total: acknowledged.count, onTime: onTime, late: late, missed: missed)
232:     }
233:     func adherencePercentage() -&gt; Double {
234:         let stats = adherenceStats()
235:         guard stats.total &gt; 0 else { return 0 }
236:         return Double(stats.onTime) / Double(stats.total) * 100.0
237:     }
238:     // MARK: - Persistence
239:     private func saveInjectionRecords() {
240:         if let encodedData = try? JSONEncoder().encode(injectionRecords) {
241:             UserDefaults.standard.set(encodedData, forKey: &quot;injectionRecords&quot;)
242:         }
243:     }
244:     private func loadInjectionRecords() {
245:         if let savedData = UserDefaults.standard.data(forKey: &quot;injectionRecords&quot;),
246:            let decodedRecords = try? JSONDecoder().decode([InjectionRecord].self, from: savedData) {
247:             self.injectionRecords = decodedRecords
248:         }
249:     }
250:     func injectionHistory(for protocolID: UUID? = nil) -&gt; [InjectionRecord] {
251:         if let protocolID = protocolID {
252:             return injectionRecords.filter { $0.protocolID == protocolID }
253:         } else {
254:             return injectionRecords
255:         }
256:     }
257:     // Cleanup old records older than 6 months
258:     func cleanupOldRecords() {
259:         let sixMonthsAgo = Calendar.current.date(byAdding: .month, value: -6, to: Date())!
260:         injectionRecords = injectionRecords.filter { $0.scheduledDate &gt; sixMonthsAgo }
261:         saveInjectionRecords()
262:     }
263: }

================
File: TestoSim/Views/CalibrationResultView.swift
================
  1: import SwiftUI
  2: import Charts
  3: struct CalibrationResultView: View {
  4:     @EnvironmentObject var dataStore: AppDataStore
  5:     // Sample calibration data (in a real app, this would come from the model)
  6:     let calibrationResults: CalibrationResults
  7:     struct CalibrationResults {
  8:         let halfLifeDays: Double
  9:         let absorptionRateFactor: Double
 10:         let calibrationFactor: Double
 11:         let treatmentProtocol: InjectionProtocol
 12:         let compound: Compound
 13:         let bloodSamples: [BloodSample]
 14:         let originalPredictions: [DataPoint]
 15:         let calibratedPredictions: [DataPoint]
 16:         let rmseImprovement: Double  // Root Mean Square Error improvement percentage
 17:     }
 18:     var body: some View {
 19:         ScrollView {
 20:             VStack(alignment: .leading, spacing: 20) {
 21:                 // Header
 22:                 VStack(alignment: .leading, spacing: 8) {
 23:                     Text(&quot;Calibration Complete&quot;)
 24:                         .font(.title)
 25:                         .fontWeight(.bold)
 26:                     Text(&quot;Protocol: \(calibrationResults.treatmentProtocol.name)&quot;)
 27:                         .font(.headline)
 28:                     Text(&quot;Compound: \(calibrationResults.compound.fullDisplayName)&quot;)
 29:                         .font(.subheadline)
 30:                 }
 31:                 .frame(maxWidth: .infinity, alignment: .leading)
 32:                 .padding()
 33:                 .background(Color.blue.opacity(0.1))
 34:                 .cornerRadius(12)
 35:                 // Chart
 36:                 chartSection
 37:                 // Parameters
 38:                 parametersSection
 39:                 // Blood Samples
 40:                 bloodSamplesSection
 41:                 // Improvement metrics
 42:                 improvementSection
 43:             }
 44:             .padding()
 45:         }
 46:     }
 47:     var chartSection: some View {
 48:         VStack(alignment: .leading, spacing: 8) {
 49:             Text(&quot;Calibration Results&quot;)
 50:                 .font(.headline)
 51:             Text(&quot;The chart shows the original and calibrated testosterone predictions alongside your blood samples.&quot;)
 52:                 .font(.caption)
 53:                 .foregroundColor(.secondary)
 54:             Chart {
 55:                 // Original prediction line
 56:                 ForEach(calibrationResults.originalPredictions) { point in
 57:                     LineMark(
 58:                         x: .value(&quot;Date&quot;, point.time),
 59:                         y: .value(&quot;Level&quot;, point.level)
 60:                     )
 61:                     .foregroundStyle(.orange)
 62:                     .lineStyle(StrokeStyle(lineWidth: 2, dash: [5, 3]))
 63:                 }
 64:                 // Calibrated prediction line
 65:                 ForEach(calibrationResults.calibratedPredictions) { point in
 66:                     LineMark(
 67:                         x: .value(&quot;Date&quot;, point.time),
 68:                         y: .value(&quot;Level&quot;, point.level)
 69:                     )
 70:                     .foregroundStyle(.blue)
 71:                     .lineStyle(StrokeStyle(lineWidth: 2))
 72:                 }
 73:                 // Blood samples as points
 74:                 ForEach(calibrationResults.bloodSamples) { sample in
 75:                     PointMark(
 76:                         x: .value(&quot;Date&quot;, sample.date),
 77:                         y: .value(&quot;Level&quot;, sample.value)
 78:                     )
 79:                     .foregroundStyle(.red)
 80:                     .symbolSize(100)
 81:                 }
 82:             }
 83:             .frame(height: 250)
 84:             // Legend
 85:             VStack(alignment: .leading, spacing: 4) {
 86:                 HStack {
 87:                     Circle()
 88:                         .fill(Color.red)
 89:                         .frame(width: 8, height: 8)
 90:                     Text(&quot;Blood Samples&quot;)
 91:                         .font(.caption)
 92:                 }
 93:                 HStack {
 94:                     Rectangle()
 95:                         .fill(Color.orange)
 96:                         .frame(width: 15, height: 2)
 97:                     Text(&quot;Original Prediction&quot;)
 98:                         .font(.caption)
 99:                 }
100:                 HStack {
101:                     Rectangle()
102:                         .fill(Color.blue)
103:                         .frame(width: 15, height: 2)
104:                     Text(&quot;Calibrated Prediction&quot;)
105:                         .font(.caption)
106:                 }
107:             }
108:             .frame(maxWidth: .infinity, alignment: .leading)
109:             .padding(.vertical, 4)
110:         }
111:         .padding()
112:         .background(Color.gray.opacity(0.1))
113:         .cornerRadius(12)
114:     }
115:     var parametersSection: some View {
116:         VStack(alignment: .leading, spacing: 8) {
117:             Text(&quot;Calibrated Parameters&quot;)
118:                 .font(.headline)
119:             VStack(alignment: .leading, spacing: 4) {
120:                 HStack {
121:                     Text(&quot;Half-life:&quot;)
122:                         .fontWeight(.semibold)
123:                     Spacer()
124:                     Text(&quot;\(calibrationResults.halfLifeDays, specifier: &quot;%.1f&quot;) days&quot;)
125:                 }
126:                 HStack {
127:                     Text(&quot;Absorption rate:&quot;)
128:                         .fontWeight(.semibold)
129:                     Spacer()
130:                     Text(&quot;\(calibrationResults.absorptionRateFactor, specifier: &quot;%.2f&quot;)x&quot;)
131:                 }
132:                 HStack {
133:                     Text(&quot;Calibration factor:&quot;)
134:                         .fontWeight(.semibold)
135:                     Spacer()
136:                     Text(&quot;\(calibrationResults.calibrationFactor, specifier: &quot;%.2f&quot;)x&quot;)
137:                 }
138:                 Divider()
139:                 HStack {
140:                     Text(&quot;Based on:&quot;)
141:                         .fontWeight(.semibold)
142:                     Spacer()
143:                     Text(&quot;\(calibrationResults.bloodSamples.count) blood samples&quot;)
144:                 }
145:             }
146:         }
147:         .padding()
148:         .background(Color.gray.opacity(0.1))
149:         .cornerRadius(12)
150:     }
151:     var bloodSamplesSection: some View {
152:         VStack(alignment: .leading, spacing: 8) {
153:             Text(&quot;Blood Samples Used&quot;)
154:                 .font(.headline)
155:             ForEach(calibrationResults.bloodSamples) { sample in
156:                 HStack {
157:                     VStack(alignment: .leading) {
158:                         Text(formatDate(sample.date))
159:                             .font(.subheadline)
160:                     }
161:                     Spacer()
162:                     Text(&quot;\(sample.value, specifier: &quot;%.1f&quot;) \(dataStore.profile.unit)&quot;)
163:                         .fontWeight(.semibold)
164:                 }
165:                 .padding(.vertical, 4)
166:                 if sample.id != calibrationResults.bloodSamples.last?.id {
167:                     Divider()
168:                 }
169:             }
170:         }
171:         .padding()
172:         .background(Color.gray.opacity(0.1))
173:         .cornerRadius(12)
174:     }
175:     // Helper function to format dates
176:     private func formatDate(_ date: Date) -&gt; String {
177:         let formatter = DateFormatter()
178:         formatter.dateStyle = .medium
179:         formatter.timeStyle = .short
180:         return formatter.string(from: date)
181:     }
182:     var improvementSection: some View {
183:         VStack(alignment: .leading, spacing: 8) {
184:             Text(&quot;Calibration Quality&quot;)
185:                 .font(.headline)
186:             HStack {
187:                 VStack(alignment: .leading) {
188:                     Text(&quot;Prediction Improvement:&quot;)
189:                         .fontWeight(.semibold)
190:                     Text(&quot;The calibrated model is \(calibrationResults.rmseImprovement, specifier: &quot;%.1f&quot;)% more accurate&quot;)
191:                         .font(.caption)
192:                         .foregroundColor(.secondary)
193:                 }
194:                 Spacer()
195:                 // Simple quality indicator
196:                 ZStack {
197:                     Circle()
198:                         .stroke(Color.gray.opacity(0.3), lineWidth: 6)
199:                         .frame(width: 50, height: 50)
200:                     Circle()
201:                         .trim(from: 0, to: min(1.0, calibrationResults.rmseImprovement / 100))
202:                         .stroke(
203:                             calibrationResults.rmseImprovement &gt; 50 ? Color.green :
204:                                 calibrationResults.rmseImprovement &gt; 25 ? Color.yellow : Color.red,
205:                             lineWidth: 6
206:                         )
207:                         .frame(width: 50, height: 50)
208:                         .rotationEffect(.degrees(-90))
209:                     Text(&quot;\(calibrationResults.rmseImprovement.isFinite ? Int(calibrationResults.rmseImprovement) : 0)%&quot;)
210:                         .font(.system(size: 12, weight: .bold))
211:                 }
212:             }
213:         }
214:         .padding()
215:         .background(Color.gray.opacity(0.1))
216:         .cornerRadius(12)
217:     }
218: }
219: // Preview
220: struct CalibrationResultView_Previews: PreviewProvider {
221:     static var previews: some View {
222:         // Create sample data for preview
223:         let appDataStore = AppDataStore()
224:         // Create a sample compound
225:         let compound = Compound(
226:             id: UUID(),
227:             commonName: &quot;Testosterone Cypionate&quot;,
228:             classType: .testosterone,
229:             ester: &quot;cypionate&quot;,
230:             halfLifeDays: 8.0,
231:             defaultBioavailability: [.intramuscular: 1.0],
232:             defaultAbsorptionRateKa: [.intramuscular: 0.7]
233:         )
234:         // Create a sample protocol
235:         let testProtocol = InjectionProtocol(
236:             name: &quot;Test Protocol&quot;,
237:             doseMg: 100,
238:             frequencyDays: 7,
239:             startDate: Date().addingTimeInterval(-60*60*24*30) // 30 days ago
240:         )
241:         // Add compoundID to the protocol
242:         var updatedProtocol = testProtocol
243:         updatedProtocol.compoundID = compound.id
244:         // Create sample blood samples
245:         let bloodSamples: [BloodSample] = [
246:             BloodSample(date: Date().addingTimeInterval(-60*60*24*20), value: 650, unit: &quot;ng/dL&quot;),
247:             BloodSample(date: Date().addingTimeInterval(-60*60*24*10), value: 750, unit: &quot;ng/dL&quot;),
248:             BloodSample(date: Date().addingTimeInterval(-60*60*24*2), value: 550, unit: &quot;ng/dL&quot;),
249:         ]
250:         // Create sample prediction points
251:         let originalPredictions: [DataPoint] = (0...30).map { i in
252:             let date = Date().addingTimeInterval(-60*60*24*Double(30-i))
253:             let baseValue = 500.0 + 200 * sin(Double(i) / 7.0 * .pi)
254:             return DataPoint(time: date, level: baseValue)
255:         }
256:         let calibratedPredictions: [DataPoint] = (0...30).map { i in
257:             let date = Date().addingTimeInterval(-60*60*24*Double(30-i))
258:             let baseValue = 600.0 + 150 * sin(Double(i) / 7.0 * .pi)
259:             return DataPoint(time: date, level: baseValue)
260:         }
261:         // Create sample calibration results
262:         let sampleResults = CalibrationResultView.CalibrationResults(
263:             halfLifeDays: 7.5,
264:             absorptionRateFactor: 1.2,
265:             calibrationFactor: 0.95,
266:             treatmentProtocol: updatedProtocol,
267:             compound: compound,
268:             bloodSamples: bloodSamples,
269:             originalPredictions: originalPredictions,
270:             calibratedPredictions: calibratedPredictions,
271:             rmseImprovement: 62.5
272:         )
273:         return CalibrationResultView(calibrationResults: sampleResults)
274:             .environmentObject(appDataStore)
275:     }
276: }

================
File: TestoSim/Views/CycleStageFormView.swift
================
  1: import SwiftUI
  2: struct CycleStageFormView: View {
  3:     @EnvironmentObject var dataStore: AppDataStore
  4:     @Binding var isPresented: Bool
  5:     var cycle: Cycle
  6:     var stageToEdit: CycleStage?
  7:     @State private var stageName: String = &quot;&quot;
  8:     @State private var startWeek: Int = 0
  9:     @State private var durationWeeks: Int = 4
 10:     @State private var isPresentingCompoundPicker = false
 11:     @State private var isPresentingBlendPicker = false
 12:     // Stage items
 13:     @State private var compounds: [CompoundStageItem] = []
 14:     @State private var blends: [BlendStageItem] = []
 15:     // Temporary item being configured
 16:     @State private var tempCompound: Compound?
 17:     @State private var tempBlend: VialBlend?
 18:     @State private var tempDoseMg: Double = 0
 19:     @State private var tempFrequencyDays: Double = 0
 20:     @State private var tempRoute: Compound.Route = .intramuscular
 21:     @State private var isAddingItem = false
 22:     @State private var itemType: ItemType = .compound
 23:     enum ItemType {
 24:         case compound, blend
 25:     }
 26:     var body: some View {
 27:         NavigationView {
 28:             Form {
 29:                 Section(header: Text(&quot;Stage Details&quot;)) {
 30:                     TextField(&quot;Stage Name&quot;, text: $stageName)
 31:                     HStack {
 32:                         Text(&quot;Start Week&quot;)
 33:                         Spacer()
 34:                         Picker(&quot;Start Week&quot;, selection: $startWeek) {
 35:                             ForEach(Array(0..&lt;cycle.totalWeeks), id: \.self) { week in
 36:                                 Text(&quot;Week \(week + 1)&quot;).tag(week)
 37:                             }
 38:                         }
 39:                         .pickerStyle(MenuPickerStyle())
 40:                     }
 41:                     Stepper(&quot;Duration: \(durationWeeks) weeks&quot;, value: $durationWeeks, in: 1...max(1, cycle.totalWeeks - startWeek))
 42:                 }
 43:                 Section(header: stageItemsHeader) {
 44:                     if compounds.isEmpty &amp;&amp; blends.isEmpty {
 45:                         Text(&quot;No compounds or blends added&quot;)
 46:                             .foregroundColor(.secondary)
 47:                             .italic()
 48:                     } else {
 49:                         ForEach(compounds) { item in
 50:                             CompoundItemRow(item: item)
 51:                                 .contextMenu {
 52:                                     Button(role: .destructive) {
 53:                                         withAnimation {
 54:                                             compounds.removeAll { $0.id == item.id }
 55:                                         }
 56:                                     } label: {
 57:                                         Label(&quot;Delete&quot;, systemImage: &quot;trash&quot;)
 58:                                     }
 59:                                 }
 60:                         }
 61:                         ForEach(blends) { item in
 62:                             BlendItemRow(item: item)
 63:                                 .contextMenu {
 64:                                     Button(role: .destructive) {
 65:                                         withAnimation {
 66:                                             blends.removeAll { $0.id == item.id }
 67:                                         }
 68:                                     } label: {
 69:                                         Label(&quot;Delete&quot;, systemImage: &quot;trash&quot;)
 70:                                     }
 71:                                 }
 72:                         }
 73:                     }
 74:                 }
 75:             }
 76:             .navigationTitle(stageToEdit == nil ? &quot;New Stage&quot; : &quot;Edit Stage&quot;)
 77:             .toolbar {
 78:                 ToolbarItem(placement: .cancellationAction) {
 79:                     Button(&quot;Cancel&quot;) {
 80:                         isPresented = false
 81:                     }
 82:                 }
 83:                 ToolbarItem(placement: .confirmationAction) {
 84:                     Button(&quot;Save&quot;) {
 85:                         saveStage()
 86:                         isPresented = false
 87:                     }
 88:                     .disabled(stageName.isEmpty || (compounds.isEmpty &amp;&amp; blends.isEmpty))
 89:                 }
 90:             }
 91:             .sheet(isPresented: $isPresentingCompoundPicker) {
 92:                 CompoundPickerView(selectedCompound: $tempCompound, onCompoundSelected: configureCompound)
 93:             }
 94:             .sheet(isPresented: $isPresentingBlendPicker) {
 95:                 BlendPickerView(selectedBlend: $tempBlend, onBlendSelected: configureBlend)
 96:             }
 97:             .sheet(isPresented: $isAddingItem) {
 98:                 if itemType == .compound, let compound = tempCompound {
 99:                     ItemConfigurationView(
100:                         title: &quot;Configure \(compound.fullDisplayName)&quot;,
101:                         doseMg: $tempDoseMg,
102:                         frequencyDays: $tempFrequencyDays,
103:                         route: $tempRoute,
104:                         onSave: {
105:                             addCompoundItem()
106:                             isAddingItem = false
107:                         },
108:                         onCancel: {
109:                             isAddingItem = false
110:                         }
111:                     )
112:                 } else if itemType == .blend, let blend = tempBlend {
113:                     ItemConfigurationView(
114:                         title: &quot;Configure \(blend.name)&quot;,
115:                         doseMg: $tempDoseMg,
116:                         frequencyDays: $tempFrequencyDays,
117:                         route: $tempRoute,
118:                         onSave: {
119:                             addBlendItem()
120:                             isAddingItem = false
121:                         },
122:                         onCancel: {
123:                             isAddingItem = false
124:                         }
125:                     )
126:                 }
127:             }
128:             .onAppear {
129:                 initializeForm()
130:             }
131:         }
132:     }
133:     private var stageItemsHeader: some View {
134:         HStack {
135:             Text(&quot;Compounds &amp; Blends&quot;)
136:             Spacer()
137:             Menu {
138:                 Button(action: {
139:                     itemType = .compound
140:                     isPresentingCompoundPicker = true
141:                 }) {
142:                     Label(&quot;Add Compound&quot;, systemImage: &quot;pill&quot;)
143:                 }
144:                 Button(action: {
145:                     itemType = .blend
146:                     isPresentingBlendPicker = true
147:                 }) {
148:                     Label(&quot;Add Blend&quot;, systemImage: &quot;cross.vial&quot;)
149:                 }
150:             } label: {
151:                 Image(systemName: &quot;plus&quot;)
152:             }
153:         }
154:     }
155:     private func initializeForm() {
156:         if let stage = stageToEdit {
157:             stageName = stage.name
158:             startWeek = stage.startWeek
159:             durationWeeks = stage.durationWeeks
160:             compounds = stage.compounds
161:             blends = stage.blends
162:         } else {
163:             // Find the first available week after any existing stages
164:             if !cycle.stages.isEmpty {
165:                 let lastStage = cycle.stages.max(by: { $0.startWeek + $0.durationWeeks &lt; $1.startWeek + $1.durationWeeks })
166:                 if let lastStage = lastStage {
167:                     startWeek = min(lastStage.startWeek + lastStage.durationWeeks, cycle.totalWeeks - 1)
168:                 }
169:             }
170:             // Default stage name if creating new
171:             stageName = &quot;Stage \(cycle.stages.count + 1)&quot;
172:         }
173:     }
174:     private func saveStage() {
175:         // Create a new stage or update existing
176:         var updatedStage: CycleStage
177:         if let existingStage = stageToEdit {
178:             // Update existing stage
179:             updatedStage = existingStage
180:             updatedStage.name = stageName
181:             updatedStage.startWeek = startWeek
182:             updatedStage.durationWeeks = durationWeeks
183:             updatedStage.compounds = compounds
184:             updatedStage.blends = blends
185:             // Find and replace in cycle
186:             var updatedCycle = cycle
187:             if let index = updatedCycle.stages.firstIndex(where: { $0.id == existingStage.id }) {
188:                 updatedCycle.stages[index] = updatedStage
189:             }
190:             // Save cycle
191:             dataStore.saveCycle(updatedCycle)
192:         } else {
193:             // Create new stage
194:             updatedStage = CycleStage(
195:                 name: stageName,
196:                 startWeek: startWeek,
197:                 durationWeeks: durationWeeks,
198:                 compounds: compounds,
199:                 blends: blends
200:             )
201:             // Add to cycle
202:             var updatedCycle = cycle
203:             updatedCycle.stages.append(updatedStage)
204:             // Save cycle
205:             dataStore.saveCycle(updatedCycle)
206:         }
207:     }
208:     private func configureCompound(_ compound: Compound) {
209:         tempCompound = compound
210:         // Set default values
211:         if let route = Compound.Route(rawValue: Compound.Route.intramuscular.rawValue) {
212:             tempRoute = route
213:         }
214:         // Set default dosage based on compound class
215:         switch compound.classType {
216:         case .testosterone:
217:             tempDoseMg = 100
218:             tempFrequencyDays = 3.5
219:         case .trenbolone:
220:             tempDoseMg = 50
221:             tempFrequencyDays = 2
222:         default:
223:             tempDoseMg = 50
224:             tempFrequencyDays = 3.5
225:         }
226:         isPresentingCompoundPicker = false
227:         isAddingItem = true
228:     }
229:     private func configureBlend(_ blend: VialBlend) {
230:         tempBlend = blend
231:         // Set default values
232:         if let route = Compound.Route(rawValue: Compound.Route.intramuscular.rawValue) {
233:             tempRoute = route
234:         }
235:         // Set default values based on blend concentration
236:         tempDoseMg = 1.0 // Default to 1mL (will be shown as volume)
237:         tempFrequencyDays = 3.5 // Default to twice weekly
238:         isPresentingBlendPicker = false
239:         isAddingItem = true
240:     }
241:     private func addCompoundItem() {
242:         guard let compound = tempCompound else { return }
243:         let newItem = CompoundStageItem(
244:             compoundID: compound.id,
245:             compoundName: compound.fullDisplayName,
246:             doseMg: tempDoseMg,
247:             frequencyDays: tempFrequencyDays,
248:             administrationRoute: tempRoute.rawValue
249:         )
250:         compounds.append(newItem)
251:     }
252:     private func addBlendItem() {
253:         guard let blend = tempBlend else { return }
254:         let newItem = BlendStageItem(
255:             blendID: blend.id,
256:             blendName: blend.name,
257:             doseMg: tempDoseMg,
258:             frequencyDays: tempFrequencyDays,
259:             administrationRoute: tempRoute.rawValue
260:         )
261:         blends.append(newItem)
262:     }
263: }
264: struct CompoundItemRow: View {
265:     let item: CompoundStageItem
266:     var body: some View {
267:         VStack(alignment: .leading, spacing: 4) {
268:             Text(item.compoundName)
269:                 .font(.headline)
270:             HStack {
271:                 Text(&quot;\(item.doseMg.isFinite ? Int(item.doseMg) : 0)mg&quot;)
272:                 Spacer()
273:                 Text(&quot;Every \(formatFrequency(item.frequencyDays))&quot;)
274:             }
275:             .font(.subheadline)
276:             .foregroundColor(.secondary)
277:             Text(&quot;Route: \(item.administrationRoute)&quot;)
278:                 .font(.caption)
279:                 .foregroundColor(.secondary)
280:         }
281:         .padding(.vertical, 4)
282:     }
283:     private func formatFrequency(_ days: Double) -&gt; String {
284:         if days == 1 {
285:             return &quot;day&quot;
286:         } else if days == 7 {
287:             return &quot;week&quot;
288:         } else if days == 3.5 {
289:             return &quot;3.5 days&quot;
290:         } else {
291:             return &quot;\(days) days&quot;
292:         }
293:     }
294: }
295: struct BlendItemRow: View {
296:     let item: BlendStageItem
297:     var body: some View {
298:         VStack(alignment: .leading, spacing: 4) {
299:             Text(item.blendName)
300:                 .font(.headline)
301:             HStack {
302:                 Text(&quot;\(item.doseMg.isFinite ? Int(item.doseMg) : 0)mg&quot;)
303:                 Spacer()
304:                 Text(&quot;Every \(formatFrequency(item.frequencyDays))&quot;)
305:             }
306:             .font(.subheadline)
307:             .foregroundColor(.secondary)
308:             Text(&quot;Route: \(item.administrationRoute)&quot;)
309:                 .font(.caption)
310:                 .foregroundColor(.secondary)
311:         }
312:         .padding(.vertical, 4)
313:     }
314:     private func formatFrequency(_ days: Double) -&gt; String {
315:         if days == 1 {
316:             return &quot;day&quot;
317:         } else if days == 7 {
318:             return &quot;week&quot;
319:         } else if days == 3.5 {
320:             return &quot;3.5 days&quot;
321:         } else {
322:             return &quot;\(days) days&quot;
323:         }
324:     }
325: }
326: struct ItemConfigurationView: View {
327:     let title: String
328:     @Binding var doseMg: Double
329:     @Binding var frequencyDays: Double
330:     @Binding var route: Compound.Route
331:     let onSave: () -&gt; Void
332:     let onCancel: () -&gt; Void
333:     var body: some View {
334:         NavigationView {
335:             Form {
336:                 Section(header: Text(&quot;Dosage&quot;)) {
337:                     Stepper(value: $doseMg, in: 10...500, step: 10) {
338:                         Text(&quot;Dose: \(doseMg.isFinite ? Int(doseMg) : 0)mg&quot;)
339:                     }
340:                 }
341:                 Section(header: Text(&quot;Frequency&quot;)) {
342:                     Picker(&quot;Frequency&quot;, selection: $frequencyDays) {
343:                         Text(&quot;Daily&quot;).tag(1.0)
344:                         Text(&quot;Every other day&quot;).tag(2.0)
345:                         Text(&quot;Twice weekly&quot;).tag(3.5)
346:                         Text(&quot;Weekly&quot;).tag(7.0)
347:                         Text(&quot;Every 2 weeks&quot;).tag(14.0)
348:                     }
349:                     .pickerStyle(InlinePickerStyle())
350:                 }
351:                 Section(header: Text(&quot;Route&quot;)) {
352:                     Picker(&quot;Administration Route&quot;, selection: $route) {
353:                         Text(&quot;Intramuscular&quot;).tag(Compound.Route.intramuscular)
354:                         Text(&quot;Subcutaneous&quot;).tag(Compound.Route.subcutaneous)
355:                         Text(&quot;Oral&quot;).tag(Compound.Route.oral)
356:                         Text(&quot;Transdermal&quot;).tag(Compound.Route.transdermal)
357:                     }
358:                     .pickerStyle(InlinePickerStyle())
359:                 }
360:             }
361:             .navigationTitle(title)
362:             .toolbar {
363:                 ToolbarItem(placement: .cancellationAction) {
364:                     Button(&quot;Cancel&quot;, action: onCancel)
365:                 }
366:                 ToolbarItem(placement: .confirmationAction) {
367:                     Button(&quot;Save&quot;, action: onSave)
368:                 }
369:             }
370:         }
371:     }
372: }
373: // Compound Picker View (simplified version)
374: struct CompoundPickerView: View {
375:     @EnvironmentObject var dataStore: AppDataStore
376:     @Binding var selectedCompound: Compound?
377:     let onCompoundSelected: (Compound) -&gt; Void
378:     var body: some View {
379:         NavigationView {
380:             List {
381:                 ForEach(dataStore.compoundLibrary.compounds) { compound in
382:                     Button(action: {
383:                         selectedCompound = compound
384:                         onCompoundSelected(compound)
385:                     }) {
386:                         HStack {
387:                             Text(compound.fullDisplayName)
388:                             Spacer()
389:                             if selectedCompound?.id == compound.id {
390:                                 Image(systemName: &quot;checkmark&quot;)
391:                                     .foregroundColor(.accentColor)
392:                             }
393:                         }
394:                     }
395:                     .buttonStyle(PlainButtonStyle())
396:                 }
397:             }
398:             .navigationTitle(&quot;Select Compound&quot;)
399:         }
400:     }
401: }
402: // Blend Picker View (simplified version)
403: struct BlendPickerView: View {
404:     @EnvironmentObject var dataStore: AppDataStore
405:     @Binding var selectedBlend: VialBlend?
406:     let onBlendSelected: (VialBlend) -&gt; Void
407:     var body: some View {
408:         NavigationView {
409:             List {
410:                 ForEach(dataStore.compoundLibrary.blends) { blend in
411:                     Button(action: {
412:                         selectedBlend = blend
413:                         onBlendSelected(blend)
414:                     }) {
415:                         HStack {
416:                             VStack(alignment: .leading) {
417:                                 Text(blend.name)
418:                                     .font(.headline)
419:                                 Text(blend.compositionDescription(using: dataStore.compoundLibrary))
420:                                     .font(.caption)
421:                                     .foregroundColor(.secondary)
422:                             }
423:                             Spacer()
424:                             if selectedBlend?.id == blend.id {
425:                                 Image(systemName: &quot;checkmark&quot;)
426:                                     .foregroundColor(.accentColor)
427:                             }
428:                         }
429:                     }
430:                     .buttonStyle(PlainButtonStyle())
431:                 }
432:             }
433:             .navigationTitle(&quot;Select Blend&quot;)
434:         }
435:     }
436: }

================
File: TestoSim/Views/NotificationSettingsView.swift
================
  1: import SwiftUI
  2: struct NotificationSettingsView: View {
  3:     @EnvironmentObject var dataStore: AppDataStore
  4:     @Environment(\.dismiss) private var dismiss
  5:     // Local state for notification settings
  6:     @State private var notificationsEnabled: Bool
  7:     @State private var soundEnabled: Bool
  8:     @State private var selectedLeadTime: NotificationManager.LeadTime
  9:     // Initialize state from the notification manager
 10:     init() {
 11:         let notificationManager = NotificationManager.shared
 12:         _notificationsEnabled = State(initialValue: notificationManager.notificationsEnabled)
 13:         _soundEnabled = State(initialValue: notificationManager.soundEnabled)
 14:         _selectedLeadTime = State(initialValue: notificationManager.selectedLeadTime)
 15:     }
 16:     var body: some View {
 17:         NavigationView {
 18:             Form {
 19:                 Section(header: Text(&quot;Notifications&quot;)) {
 20:                     Toggle(&quot;Enable Injection Reminders&quot;, isOn: $notificationsEnabled)
 21:                         .onChange(of: notificationsEnabled) { oldValue, newValue in
 22:                             dataStore.toggleNotifications(enabled: newValue)
 23:                         }
 24:                     if notificationsEnabled {
 25:                         Toggle(&quot;Play Sound&quot;, isOn: $soundEnabled)
 26:                             .onChange(of: soundEnabled) { oldValue, newValue in
 27:                                 dataStore.setNotificationSound(enabled: newValue)
 28:                             }
 29:                         Picker(&quot;Remind Me&quot;, selection: $selectedLeadTime) {
 30:                             ForEach(NotificationManager.LeadTime.allCases) { leadTime in
 31:                                 Text(&quot;Before \(leadTime.rawValue)&quot;)
 32:                                     .tag(leadTime)
 33:                             }
 34:                         }
 35:                         .onChange(of: selectedLeadTime) { oldValue, newValue in
 36:                             dataStore.setNotificationLeadTime(newValue)
 37:                         }
 38:                     }
 39:                 }
 40:                 Section(header: Text(&quot;Adherence Statistics&quot;)) {
 41:                     NotificationAdherenceStatsView()
 42:                 }
 43:                 Section(header: Text(&quot;About Notifications&quot;), footer: Text(&quot;Notifications help you stay on schedule with your injections. You&apos;ll receive reminders before each scheduled injection based on your preferences.&quot;)) {
 44:                     // This section is just for information
 45:                     Label(&quot;Notifications help improve adherence&quot;, systemImage: &quot;bell.badge&quot;)
 46:                         .font(.subheadline)
 47:                         .foregroundColor(.secondary)
 48:                 }
 49:             }
 50:             .navigationTitle(&quot;Notification Settings&quot;)
 51:             .navigationBarItems(trailing: Button(&quot;Done&quot;) {
 52:                 dismiss()
 53:             })
 54:         }
 55:     }
 56: }
 57: struct NotificationAdherenceStatsView: View {
 58:     @EnvironmentObject var dataStore: AppDataStore
 59:     var body: some View {
 60:         VStack(alignment: .leading, spacing: 12) {
 61:             let stats = dataStore.adherenceStats()
 62:             let adherencePercent = dataStore.adherencePercentage()
 63:             HStack {
 64:                 Text(&quot;Adherence Rate:&quot;)
 65:                     .fontWeight(.medium)
 66:                 Spacer()
 67:                 Text(String(format: &quot;%.1f%%&quot;, adherencePercent))
 68:                     .fontWeight(.bold)
 69:                     .foregroundColor(adherenceColor(for: adherencePercent))
 70:             }
 71:             if stats.total &gt; 0 {
 72:                 Divider()
 73:                 HStack {
 74:                     Text(&quot;On Time:&quot;)
 75:                     Spacer()
 76:                     Text(&quot;\(stats.onTime) of \(stats.total)&quot;)
 77:                         .foregroundColor(.green)
 78:                 }
 79:                 HStack {
 80:                     Text(&quot;Late:&quot;)
 81:                     Spacer()
 82:                     Text(&quot;\(stats.late) of \(stats.total)&quot;)
 83:                         .foregroundColor(.orange)
 84:                 }
 85:                 HStack {
 86:                     Text(&quot;Missed:&quot;)
 87:                     Spacer()
 88:                     Text(&quot;\(stats.missed) of \(stats.total)&quot;)
 89:                         .foregroundColor(.red)
 90:                 }
 91:             } else {
 92:                 Text(&quot;No injections recorded yet&quot;)
 93:                     .foregroundColor(.secondary)
 94:                     .italic()
 95:             }
 96:         }
 97:     }
 98:     private func adherenceColor(for percent: Double) -&gt; Color {
 99:         if percent &gt;= 90 {
100:             return .green
101:         } else if percent &gt;= 75 {
102:             return .orange
103:         } else {
104:             return .red
105:         }
106:     }
107: }
108: #Preview {
109:     NotificationSettingsView()
110:         .environmentObject(AppDataStore())
111: }

================
File: TestoSim/Config-Sample.xcconfig
================
1: // Configuration settings file format documentation can be found at:
2: // https://help.apple.com/xcode/#/dev745c5c974
3: 
4: // OpenAI API Key (replace with your actual API key)
5: OPENAI_API_KEY = _YOUR_OPENAI_API_KEY_HERE_

================
File: TestoSim.xcodeproj/project.pbxproj
================
  1: // !$*UTF8*$!
  2: {
  3: 	archiveVersion = 1;
  4: 	classes = {
  5: 	};
  6: 	objectVersion = 77;
  7: 	objects = {
  8: 
  9: /* Begin PBXContainerItemProxy section */
 10: 		243FDC412DC4C75F002945A1 /* PBXContainerItemProxy */ = {
 11: 			isa = PBXContainerItemProxy;
 12: 			containerPortal = 243FDC2B2DC4C75E002945A1 /* Project object */;
 13: 			proxyType = 1;
 14: 			remoteGlobalIDString = 243FDC322DC4C75E002945A1;
 15: 			remoteInfo = TestoSim;
 16: 		};
 17: 		243FDC4B2DC4C75F002945A1 /* PBXContainerItemProxy */ = {
 18: 			isa = PBXContainerItemProxy;
 19: 			containerPortal = 243FDC2B2DC4C75E002945A1 /* Project object */;
 20: 			proxyType = 1;
 21: 			remoteGlobalIDString = 243FDC322DC4C75E002945A1;
 22: 			remoteInfo = TestoSim;
 23: 		};
 24: /* End PBXContainerItemProxy section */
 25: 
 26: /* Begin PBXFileReference section */
 27: 		243FDC332DC4C75E002945A1 /* TestoSim.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = TestoSim.app; sourceTree = BUILT_PRODUCTS_DIR; };
 28: 		243FDC402DC4C75F002945A1 /* TestoSimTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = TestoSimTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
 29: 		243FDC4A2DC4C75F002945A1 /* TestoSimUITests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = TestoSimUITests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
 30: /* End PBXFileReference section */
 31: 
 32: /* Begin PBXFileSystemSynchronizedRootGroup section */
 33: 		243FDC352DC4C75E002945A1 /* TestoSim */ = {
 34: 			isa = PBXFileSystemSynchronizedRootGroup;
 35: 			path = TestoSim;
 36: 			sourceTree = &quot;&lt;group&gt;&quot;;
 37: 		};
 38: 		243FDC432DC4C75F002945A1 /* TestoSimTests */ = {
 39: 			isa = PBXFileSystemSynchronizedRootGroup;
 40: 			path = TestoSimTests;
 41: 			sourceTree = &quot;&lt;group&gt;&quot;;
 42: 		};
 43: 		243FDC4D2DC4C75F002945A1 /* TestoSimUITests */ = {
 44: 			isa = PBXFileSystemSynchronizedRootGroup;
 45: 			path = TestoSimUITests;
 46: 			sourceTree = &quot;&lt;group&gt;&quot;;
 47: 		};
 48: /* End PBXFileSystemSynchronizedRootGroup section */
 49: 
 50: /* Begin PBXFrameworksBuildPhase section */
 51: 		243FDC302DC4C75E002945A1 /* Frameworks */ = {
 52: 			isa = PBXFrameworksBuildPhase;
 53: 			buildActionMask = 2147483647;
 54: 			files = (
 55: 			);
 56: 			runOnlyForDeploymentPostprocessing = 0;
 57: 		};
 58: 		243FDC3D2DC4C75F002945A1 /* Frameworks */ = {
 59: 			isa = PBXFrameworksBuildPhase;
 60: 			buildActionMask = 2147483647;
 61: 			files = (
 62: 			);
 63: 			runOnlyForDeploymentPostprocessing = 0;
 64: 		};
 65: 		243FDC472DC4C75F002945A1 /* Frameworks */ = {
 66: 			isa = PBXFrameworksBuildPhase;
 67: 			buildActionMask = 2147483647;
 68: 			files = (
 69: 			);
 70: 			runOnlyForDeploymentPostprocessing = 0;
 71: 		};
 72: /* End PBXFrameworksBuildPhase section */
 73: 
 74: /* Begin PBXGroup section */
 75: 		243FDC2A2DC4C75E002945A1 = {
 76: 			isa = PBXGroup;
 77: 			children = (
 78: 				243FDC352DC4C75E002945A1 /* TestoSim */,
 79: 				243FDC432DC4C75F002945A1 /* TestoSimTests */,
 80: 				243FDC4D2DC4C75F002945A1 /* TestoSimUITests */,
 81: 				243FDC342DC4C75E002945A1 /* Products */,
 82: 			);
 83: 			sourceTree = &quot;&lt;group&gt;&quot;;
 84: 		};
 85: 		243FDC342DC4C75E002945A1 /* Products */ = {
 86: 			isa = PBXGroup;
 87: 			children = (
 88: 				243FDC332DC4C75E002945A1 /* TestoSim.app */,
 89: 				243FDC402DC4C75F002945A1 /* TestoSimTests.xctest */,
 90: 				243FDC4A2DC4C75F002945A1 /* TestoSimUITests.xctest */,
 91: 			);
 92: 			name = Products;
 93: 			sourceTree = &quot;&lt;group&gt;&quot;;
 94: 		};
 95: /* End PBXGroup section */
 96: 
 97: /* Begin PBXNativeTarget section */
 98: 		243FDC322DC4C75E002945A1 /* TestoSim */ = {
 99: 			isa = PBXNativeTarget;
100: 			buildConfigurationList = 243FDC542DC4C75F002945A1 /* Build configuration list for PBXNativeTarget &quot;TestoSim&quot; */;
101: 			buildPhases = (
102: 				243FDC2F2DC4C75E002945A1 /* Sources */,
103: 				243FDC302DC4C75E002945A1 /* Frameworks */,
104: 				243FDC312DC4C75E002945A1 /* Resources */,
105: 			);
106: 			buildRules = (
107: 			);
108: 			dependencies = (
109: 			);
110: 			fileSystemSynchronizedGroups = (
111: 				243FDC352DC4C75E002945A1 /* TestoSim */,
112: 			);
113: 			name = TestoSim;
114: 			packageProductDependencies = (
115: 			);
116: 			productName = TestoSim;
117: 			productReference = 243FDC332DC4C75E002945A1 /* TestoSim.app */;
118: 			productType = &quot;com.apple.product-type.application&quot;;
119: 		};
120: 		243FDC3F2DC4C75F002945A1 /* TestoSimTests */ = {
121: 			isa = PBXNativeTarget;
122: 			buildConfigurationList = 243FDC572DC4C75F002945A1 /* Build configuration list for PBXNativeTarget &quot;TestoSimTests&quot; */;
123: 			buildPhases = (
124: 				243FDC3C2DC4C75F002945A1 /* Sources */,
125: 				243FDC3D2DC4C75F002945A1 /* Frameworks */,
126: 				243FDC3E2DC4C75F002945A1 /* Resources */,
127: 			);
128: 			buildRules = (
129: 			);
130: 			dependencies = (
131: 				243FDC422DC4C75F002945A1 /* PBXTargetDependency */,
132: 			);
133: 			fileSystemSynchronizedGroups = (
134: 				243FDC432DC4C75F002945A1 /* TestoSimTests */,
135: 			);
136: 			name = TestoSimTests;
137: 			packageProductDependencies = (
138: 			);
139: 			productName = TestoSimTests;
140: 			productReference = 243FDC402DC4C75F002945A1 /* TestoSimTests.xctest */;
141: 			productType = &quot;com.apple.product-type.bundle.unit-test&quot;;
142: 		};
143: 		243FDC492DC4C75F002945A1 /* TestoSimUITests */ = {
144: 			isa = PBXNativeTarget;
145: 			buildConfigurationList = 243FDC5A2DC4C75F002945A1 /* Build configuration list for PBXNativeTarget &quot;TestoSimUITests&quot; */;
146: 			buildPhases = (
147: 				243FDC462DC4C75F002945A1 /* Sources */,
148: 				243FDC472DC4C75F002945A1 /* Frameworks */,
149: 				243FDC482DC4C75F002945A1 /* Resources */,
150: 			);
151: 			buildRules = (
152: 			);
153: 			dependencies = (
154: 				243FDC4C2DC4C75F002945A1 /* PBXTargetDependency */,
155: 			);
156: 			fileSystemSynchronizedGroups = (
157: 				243FDC4D2DC4C75F002945A1 /* TestoSimUITests */,
158: 			);
159: 			name = TestoSimUITests;
160: 			packageProductDependencies = (
161: 			);
162: 			productName = TestoSimUITests;
163: 			productReference = 243FDC4A2DC4C75F002945A1 /* TestoSimUITests.xctest */;
164: 			productType = &quot;com.apple.product-type.bundle.ui-testing&quot;;
165: 		};
166: /* End PBXNativeTarget section */
167: 
168: /* Begin PBXProject section */
169: 		243FDC2B2DC4C75E002945A1 /* Project object */ = {
170: 			isa = PBXProject;
171: 			attributes = {
172: 				BuildIndependentTargetsInParallel = 1;
173: 				LastSwiftUpdateCheck = 1630;
174: 				LastUpgradeCheck = 1630;
175: 				TargetAttributes = {
176: 					243FDC322DC4C75E002945A1 = {
177: 						CreatedOnToolsVersion = 16.3;
178: 					};
179: 					243FDC3F2DC4C75F002945A1 = {
180: 						CreatedOnToolsVersion = 16.3;
181: 						TestTargetID = 243FDC322DC4C75E002945A1;
182: 					};
183: 					243FDC492DC4C75F002945A1 = {
184: 						CreatedOnToolsVersion = 16.3;
185: 						TestTargetID = 243FDC322DC4C75E002945A1;
186: 					};
187: 				};
188: 			};
189: 			buildConfigurationList = 243FDC2E2DC4C75E002945A1 /* Build configuration list for PBXProject &quot;TestoSim&quot; */;
190: 			developmentRegion = en;
191: 			hasScannedForEncodings = 0;
192: 			knownRegions = (
193: 				en,
194: 				Base,
195: 			);
196: 			mainGroup = 243FDC2A2DC4C75E002945A1;
197: 			minimizedProjectReferenceProxies = 1;
198: 			preferredProjectObjectVersion = 77;
199: 			productRefGroup = 243FDC342DC4C75E002945A1 /* Products */;
200: 			projectDirPath = &quot;&quot;;
201: 			projectRoot = &quot;&quot;;
202: 			targets = (
203: 				243FDC322DC4C75E002945A1 /* TestoSim */,
204: 				243FDC3F2DC4C75F002945A1 /* TestoSimTests */,
205: 				243FDC492DC4C75F002945A1 /* TestoSimUITests */,
206: 			);
207: 		};
208: /* End PBXProject section */
209: 
210: /* Begin PBXResourcesBuildPhase section */
211: 		243FDC312DC4C75E002945A1 /* Resources */ = {
212: 			isa = PBXResourcesBuildPhase;
213: 			buildActionMask = 2147483647;
214: 			files = (
215: 			);
216: 			runOnlyForDeploymentPostprocessing = 0;
217: 		};
218: 		243FDC3E2DC4C75F002945A1 /* Resources */ = {
219: 			isa = PBXResourcesBuildPhase;
220: 			buildActionMask = 2147483647;
221: 			files = (
222: 			);
223: 			runOnlyForDeploymentPostprocessing = 0;
224: 		};
225: 		243FDC482DC4C75F002945A1 /* Resources */ = {
226: 			isa = PBXResourcesBuildPhase;
227: 			buildActionMask = 2147483647;
228: 			files = (
229: 			);
230: 			runOnlyForDeploymentPostprocessing = 0;
231: 		};
232: /* End PBXResourcesBuildPhase section */
233: 
234: /* Begin PBXSourcesBuildPhase section */
235: 		243FDC2F2DC4C75E002945A1 /* Sources */ = {
236: 			isa = PBXSourcesBuildPhase;
237: 			buildActionMask = 2147483647;
238: 			files = (
239: 			);
240: 			runOnlyForDeploymentPostprocessing = 0;
241: 		};
242: 		243FDC3C2DC4C75F002945A1 /* Sources */ = {
243: 			isa = PBXSourcesBuildPhase;
244: 			buildActionMask = 2147483647;
245: 			files = (
246: 			);
247: 			runOnlyForDeploymentPostprocessing = 0;
248: 		};
249: 		243FDC462DC4C75F002945A1 /* Sources */ = {
250: 			isa = PBXSourcesBuildPhase;
251: 			buildActionMask = 2147483647;
252: 			files = (
253: 			);
254: 			runOnlyForDeploymentPostprocessing = 0;
255: 		};
256: /* End PBXSourcesBuildPhase section */
257: 
258: /* Begin PBXTargetDependency section */
259: 		243FDC422DC4C75F002945A1 /* PBXTargetDependency */ = {
260: 			isa = PBXTargetDependency;
261: 			target = 243FDC322DC4C75E002945A1 /* TestoSim */;
262: 			targetProxy = 243FDC412DC4C75F002945A1 /* PBXContainerItemProxy */;
263: 		};
264: 		243FDC4C2DC4C75F002945A1 /* PBXTargetDependency */ = {
265: 			isa = PBXTargetDependency;
266: 			target = 243FDC322DC4C75E002945A1 /* TestoSim */;
267: 			targetProxy = 243FDC4B2DC4C75F002945A1 /* PBXContainerItemProxy */;
268: 		};
269: /* End PBXTargetDependency section */
270: 
271: /* Begin XCBuildConfiguration section */
272: 		243FDC522DC4C75F002945A1 /* Debug */ = {
273: 			isa = XCBuildConfiguration;
274: 			buildSettings = {
275: 				ALWAYS_SEARCH_USER_PATHS = NO;
276: 				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
277: 				CLANG_ANALYZER_NONNULL = YES;
278: 				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
279: 				CLANG_CXX_LANGUAGE_STANDARD = &quot;gnu++20&quot;;
280: 				CLANG_ENABLE_MODULES = YES;
281: 				CLANG_ENABLE_OBJC_ARC = YES;
282: 				CLANG_ENABLE_OBJC_WEAK = YES;
283: 				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
284: 				CLANG_WARN_BOOL_CONVERSION = YES;
285: 				CLANG_WARN_COMMA = YES;
286: 				CLANG_WARN_CONSTANT_CONVERSION = YES;
287: 				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
288: 				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
289: 				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
290: 				CLANG_WARN_EMPTY_BODY = YES;
291: 				CLANG_WARN_ENUM_CONVERSION = YES;
292: 				CLANG_WARN_INFINITE_RECURSION = YES;
293: 				CLANG_WARN_INT_CONVERSION = YES;
294: 				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
295: 				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
296: 				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
297: 				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
298: 				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
299: 				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
300: 				CLANG_WARN_STRICT_PROTOTYPES = YES;
301: 				CLANG_WARN_SUSPICIOUS_MOVE = YES;
302: 				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
303: 				CLANG_WARN_UNREACHABLE_CODE = YES;
304: 				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
305: 				COPY_PHASE_STRIP = NO;
306: 				DEBUG_INFORMATION_FORMAT = dwarf;
307: 				DEVELOPMENT_TEAM = LF5UPMD2CC;
308: 				ENABLE_STRICT_OBJC_MSGSEND = YES;
309: 				ENABLE_TESTABILITY = YES;
310: 				ENABLE_USER_SCRIPT_SANDBOXING = YES;
311: 				GCC_C_LANGUAGE_STANDARD = gnu17;
312: 				GCC_DYNAMIC_NO_PIC = NO;
313: 				GCC_NO_COMMON_BLOCKS = YES;
314: 				GCC_OPTIMIZATION_LEVEL = 0;
315: 				GCC_PREPROCESSOR_DEFINITIONS = (
316: 					&quot;DEBUG=1&quot;,
317: 					&quot;$(inherited)&quot;,
318: 				);
319: 				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
320: 				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
321: 				GCC_WARN_UNDECLARED_SELECTOR = YES;
322: 				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
323: 				GCC_WARN_UNUSED_FUNCTION = YES;
324: 				GCC_WARN_UNUSED_VARIABLE = YES;
325: 				IPHONEOS_DEPLOYMENT_TARGET = 18.4;
326: 				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
327: 				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
328: 				MTL_FAST_MATH = YES;
329: 				ONLY_ACTIVE_ARCH = YES;
330: 				SDKROOT = iphoneos;
331: 				SWIFT_ACTIVE_COMPILATION_CONDITIONS = &quot;DEBUG $(inherited)&quot;;
332: 				SWIFT_OPTIMIZATION_LEVEL = &quot;-Onone&quot;;
333: 			};
334: 			name = Debug;
335: 		};
336: 		243FDC532DC4C75F002945A1 /* Release */ = {
337: 			isa = XCBuildConfiguration;
338: 			buildSettings = {
339: 				ALWAYS_SEARCH_USER_PATHS = NO;
340: 				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
341: 				CLANG_ANALYZER_NONNULL = YES;
342: 				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
343: 				CLANG_CXX_LANGUAGE_STANDARD = &quot;gnu++20&quot;;
344: 				CLANG_ENABLE_MODULES = YES;
345: 				CLANG_ENABLE_OBJC_ARC = YES;
346: 				CLANG_ENABLE_OBJC_WEAK = YES;
347: 				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
348: 				CLANG_WARN_BOOL_CONVERSION = YES;
349: 				CLANG_WARN_COMMA = YES;
350: 				CLANG_WARN_CONSTANT_CONVERSION = YES;
351: 				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
352: 				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
353: 				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
354: 				CLANG_WARN_EMPTY_BODY = YES;
355: 				CLANG_WARN_ENUM_CONVERSION = YES;
356: 				CLANG_WARN_INFINITE_RECURSION = YES;
357: 				CLANG_WARN_INT_CONVERSION = YES;
358: 				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
359: 				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
360: 				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
361: 				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
362: 				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
363: 				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
364: 				CLANG_WARN_STRICT_PROTOTYPES = YES;
365: 				CLANG_WARN_SUSPICIOUS_MOVE = YES;
366: 				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
367: 				CLANG_WARN_UNREACHABLE_CODE = YES;
368: 				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
369: 				COPY_PHASE_STRIP = NO;
370: 				DEBUG_INFORMATION_FORMAT = &quot;dwarf-with-dsym&quot;;
371: 				DEVELOPMENT_TEAM = LF5UPMD2CC;
372: 				ENABLE_NS_ASSERTIONS = NO;
373: 				ENABLE_STRICT_OBJC_MSGSEND = YES;
374: 				ENABLE_USER_SCRIPT_SANDBOXING = YES;
375: 				GCC_C_LANGUAGE_STANDARD = gnu17;
376: 				GCC_NO_COMMON_BLOCKS = YES;
377: 				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
378: 				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
379: 				GCC_WARN_UNDECLARED_SELECTOR = YES;
380: 				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
381: 				GCC_WARN_UNUSED_FUNCTION = YES;
382: 				GCC_WARN_UNUSED_VARIABLE = YES;
383: 				IPHONEOS_DEPLOYMENT_TARGET = 18.4;
384: 				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
385: 				MTL_ENABLE_DEBUG_INFO = NO;
386: 				MTL_FAST_MATH = YES;
387: 				SDKROOT = iphoneos;
388: 				SWIFT_COMPILATION_MODE = wholemodule;
389: 				VALIDATE_PRODUCT = YES;
390: 			};
391: 			name = Release;
392: 		};
393: 		243FDC552DC4C75F002945A1 /* Debug */ = {
394: 			isa = XCBuildConfiguration;
395: 			buildSettings = {
396: 				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
397: 				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
398: 				CODE_SIGN_STYLE = Automatic;
399: 				CURRENT_PROJECT_VERSION = 1;
400: 				DEVELOPMENT_TEAM = LF5UPMD2CC;
401: 				ENABLE_PREVIEWS = YES;
402: 				GENERATE_INFOPLIST_FILE = YES;
403: 				INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
404: 				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
405: 				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
406: 				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = &quot;UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight&quot;;
407: 				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = &quot;UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight&quot;;
408: 				LD_RUNPATH_SEARCH_PATHS = (
409: 					&quot;$(inherited)&quot;,
410: 					&quot;@executable_path/Frameworks&quot;,
411: 				);
412: 				MARKETING_VERSION = 1.0;
413: 				PRODUCT_BUNDLE_IDENTIFIER = flight505.TestoSim;
414: 				PRODUCT_NAME = &quot;$(TARGET_NAME)&quot;;
415: 				SWIFT_EMIT_LOC_STRINGS = YES;
416: 				SWIFT_VERSION = 5.0;
417: 				TARGETED_DEVICE_FAMILY = &quot;1,2&quot;;
418: 			};
419: 			name = Debug;
420: 		};
421: 		243FDC562DC4C75F002945A1 /* Release */ = {
422: 			isa = XCBuildConfiguration;
423: 			buildSettings = {
424: 				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
425: 				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
426: 				CODE_SIGN_STYLE = Automatic;
427: 				CURRENT_PROJECT_VERSION = 1;
428: 				DEVELOPMENT_TEAM = LF5UPMD2CC;
429: 				ENABLE_PREVIEWS = YES;
430: 				GENERATE_INFOPLIST_FILE = YES;
431: 				INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
432: 				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
433: 				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
434: 				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = &quot;UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight&quot;;
435: 				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = &quot;UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight&quot;;
436: 				LD_RUNPATH_SEARCH_PATHS = (
437: 					&quot;$(inherited)&quot;,
438: 					&quot;@executable_path/Frameworks&quot;,
439: 				);
440: 				MARKETING_VERSION = 1.0;
441: 				PRODUCT_BUNDLE_IDENTIFIER = flight505.TestoSim;
442: 				PRODUCT_NAME = &quot;$(TARGET_NAME)&quot;;
443: 				SWIFT_EMIT_LOC_STRINGS = YES;
444: 				SWIFT_VERSION = 5.0;
445: 				TARGETED_DEVICE_FAMILY = &quot;1,2&quot;;
446: 			};
447: 			name = Release;
448: 		};
449: 		243FDC582DC4C75F002945A1 /* Debug */ = {
450: 			isa = XCBuildConfiguration;
451: 			buildSettings = {
452: 				BUNDLE_LOADER = &quot;$(TEST_HOST)&quot;;
453: 				CODE_SIGN_STYLE = Automatic;
454: 				CURRENT_PROJECT_VERSION = 1;
455: 				DEVELOPMENT_TEAM = LF5UPMD2CC;
456: 				GENERATE_INFOPLIST_FILE = YES;
457: 				IPHONEOS_DEPLOYMENT_TARGET = 18.4;
458: 				MARKETING_VERSION = 1.0;
459: 				PRODUCT_BUNDLE_IDENTIFIER = flight505.TestoSimTests;
460: 				PRODUCT_NAME = &quot;$(TARGET_NAME)&quot;;
461: 				SWIFT_EMIT_LOC_STRINGS = NO;
462: 				SWIFT_VERSION = 5.0;
463: 				TARGETED_DEVICE_FAMILY = &quot;1,2&quot;;
464: 				TEST_HOST = &quot;$(BUILT_PRODUCTS_DIR)/TestoSim.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/TestoSim&quot;;
465: 			};
466: 			name = Debug;
467: 		};
468: 		243FDC592DC4C75F002945A1 /* Release */ = {
469: 			isa = XCBuildConfiguration;
470: 			buildSettings = {
471: 				BUNDLE_LOADER = &quot;$(TEST_HOST)&quot;;
472: 				CODE_SIGN_STYLE = Automatic;
473: 				CURRENT_PROJECT_VERSION = 1;
474: 				DEVELOPMENT_TEAM = LF5UPMD2CC;
475: 				GENERATE_INFOPLIST_FILE = YES;
476: 				IPHONEOS_DEPLOYMENT_TARGET = 18.4;
477: 				MARKETING_VERSION = 1.0;
478: 				PRODUCT_BUNDLE_IDENTIFIER = flight505.TestoSimTests;
479: 				PRODUCT_NAME = &quot;$(TARGET_NAME)&quot;;
480: 				SWIFT_EMIT_LOC_STRINGS = NO;
481: 				SWIFT_VERSION = 5.0;
482: 				TARGETED_DEVICE_FAMILY = &quot;1,2&quot;;
483: 				TEST_HOST = &quot;$(BUILT_PRODUCTS_DIR)/TestoSim.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/TestoSim&quot;;
484: 			};
485: 			name = Release;
486: 		};
487: 		243FDC5B2DC4C75F002945A1 /* Debug */ = {
488: 			isa = XCBuildConfiguration;
489: 			buildSettings = {
490: 				CODE_SIGN_STYLE = Automatic;
491: 				CURRENT_PROJECT_VERSION = 1;
492: 				DEVELOPMENT_TEAM = LF5UPMD2CC;
493: 				GENERATE_INFOPLIST_FILE = YES;
494: 				MARKETING_VERSION = 1.0;
495: 				PRODUCT_BUNDLE_IDENTIFIER = flight505.TestoSimUITests;
496: 				PRODUCT_NAME = &quot;$(TARGET_NAME)&quot;;
497: 				SWIFT_EMIT_LOC_STRINGS = NO;
498: 				SWIFT_VERSION = 5.0;
499: 				TARGETED_DEVICE_FAMILY = &quot;1,2&quot;;
500: 				TEST_TARGET_NAME = TestoSim;
501: 			};
502: 			name = Debug;
503: 		};
504: 		243FDC5C2DC4C75F002945A1 /* Release */ = {
505: 			isa = XCBuildConfiguration;
506: 			buildSettings = {
507: 				CODE_SIGN_STYLE = Automatic;
508: 				CURRENT_PROJECT_VERSION = 1;
509: 				DEVELOPMENT_TEAM = LF5UPMD2CC;
510: 				GENERATE_INFOPLIST_FILE = YES;
511: 				MARKETING_VERSION = 1.0;
512: 				PRODUCT_BUNDLE_IDENTIFIER = flight505.TestoSimUITests;
513: 				PRODUCT_NAME = &quot;$(TARGET_NAME)&quot;;
514: 				SWIFT_EMIT_LOC_STRINGS = NO;
515: 				SWIFT_VERSION = 5.0;
516: 				TARGETED_DEVICE_FAMILY = &quot;1,2&quot;;
517: 				TEST_TARGET_NAME = TestoSim;
518: 			};
519: 			name = Release;
520: 		};
521: /* End XCBuildConfiguration section */
522: 
523: /* Begin XCConfigurationList section */
524: 		243FDC2E2DC4C75E002945A1 /* Build configuration list for PBXProject &quot;TestoSim&quot; */ = {
525: 			isa = XCConfigurationList;
526: 			buildConfigurations = (
527: 				243FDC522DC4C75F002945A1 /* Debug */,
528: 				243FDC532DC4C75F002945A1 /* Release */,
529: 			);
530: 			defaultConfigurationIsVisible = 0;
531: 			defaultConfigurationName = Release;
532: 		};
533: 		243FDC542DC4C75F002945A1 /* Build configuration list for PBXNativeTarget &quot;TestoSim&quot; */ = {
534: 			isa = XCConfigurationList;
535: 			buildConfigurations = (
536: 				243FDC552DC4C75F002945A1 /* Debug */,
537: 				243FDC562DC4C75F002945A1 /* Release */,
538: 			);
539: 			defaultConfigurationIsVisible = 0;
540: 			defaultConfigurationName = Release;
541: 		};
542: 		243FDC572DC4C75F002945A1 /* Build configuration list for PBXNativeTarget &quot;TestoSimTests&quot; */ = {
543: 			isa = XCConfigurationList;
544: 			buildConfigurations = (
545: 				243FDC582DC4C75F002945A1 /* Debug */,
546: 				243FDC592DC4C75F002945A1 /* Release */,
547: 			);
548: 			defaultConfigurationIsVisible = 0;
549: 			defaultConfigurationName = Release;
550: 		};
551: 		243FDC5A2DC4C75F002945A1 /* Build configuration list for PBXNativeTarget &quot;TestoSimUITests&quot; */ = {
552: 			isa = XCConfigurationList;
553: 			buildConfigurations = (
554: 				243FDC5B2DC4C75F002945A1 /* Debug */,
555: 				243FDC5C2DC4C75F002945A1 /* Release */,
556: 			);
557: 			defaultConfigurationIsVisible = 0;
558: 			defaultConfigurationName = Release;
559: 		};
560: /* End XCConfigurationList section */
561: 	};
562: 	rootObject = 243FDC2B2DC4C75E002945A1 /* Project object */;
563: }

================
File: guide.md
================
  1: Okay, this is an excellent and highly detailed implementation plan. Let&apos;s transform it into the precise checklist format suitable for a code assistant. Each item will be a specific, actionable task with an unchecked checkbox `[ ]`.
  2: 
  3: Here is the detailed checklist:
  4: 
  5: **Testosterone Pharmacokinetics Simulation App – Detailed Implementation Checklist**
  6: 
  7: **Instructions for Code Assistant:** Follow this checklist step-by-step. Each `[ ]` represents a task to complete. Implement the code exactly as described, using the provided names, structures, formulas, and UI components. Assume you are working within an Xcode project targeting iOS 16+ and macOS 13+.
  8: 
  9: ---
 10: 
 11: ### Story 1: Project Setup and Structure
 12: 
 13: *   [x] **Initialize SwiftUI Project:**
 14:     *   Create a new Xcode project using the **SwiftUI App** template.
 15:     *   Name the project `TestoSim`.
 16:     *   Ensure the targets include **iOS** (and optionally **macOS**).
 17:     *   Set the minimum deployment target to **iOS 16.0** and **macOS 13.0**.
 18: *   [x] **Create Project Groups:**
 19:     *   In the Xcode Project Navigator, create the following groups (folders):
 20:         *   `Models`
 21:         *   `Views`
 22:         *   `ViewModels` (or `Stores`)
 23:         *   `Resources` (for assets like AppIcon later)
 24: *   [x] **Add Frameworks:**
 25:     *   Confirm the **Charts** framework is available (part of SwiftUI on iOS 16+). Add `import Charts` in files that will use it.
 26:     *   *(Optional - If adding Lottie)* Add the Lottie package via Swift Package Manager: `File &gt; Add Packages...`, search for `airbnb/lottie-ios`, and add the package dependency.
 27: *   [x] **Setup SwiftUI App Struct:**
 28:     *   Open the main App struct file (e.g., `TestoSimApp.swift`).
 29:     *   Declare an `@StateObject` for the central data store (which will be created later).
 30:     *   Provide this store as an `@EnvironmentObject` to the `ContentView`.
 31:     ```swift
 32:     import SwiftUI
 33: 
 34:     @main
 35:     struct TestoSimApp: App {
 36:         @StateObject private var dataStore = AppDataStore() // Implementation follows in Story 3
 37: 
 38:         var body: some Scene {
 39:             WindowGroup {
 40:                 ContentView() // Implementation follows in Story 4
 41:                     .environmentObject(dataStore)
 42:             }
 43:         }
 44:     }
 45:     ```
 46: 
 47: ---
 48: 
 49: ### Story 2: Data Models and Persistence
 50: 
 51: *   [x] **Define Testosterone Ester Data:**
 52:     *   Create a new Swift file named `EsterData.swift` inside the `Models` group.
 53:     *   Define the `TestosteroneEster` struct:
 54:         *   Make it conform to `Identifiable` and `Codable`.
 55:         *   Include properties: `id: UUID`, `name: String`, `halfLifeDays: Double`.
 56:         *   Define static constants for the supported esters using the provided half-life values:
 57:             *   `propionate`: name &quot;Propionate&quot;, halfLifeDays `0.8`
 58:             *   `enanthate`: name &quot;Enanthate&quot;, halfLifeDays `4.5`
 59:             *   `cypionate`: name &quot;Cypionate&quot;, halfLifeDays `7.0`
 60:             *   `undecanoate`: name &quot;Undecanoate&quot;, halfLifeDays `30.0`
 61:         *   Add a static property `all: [TestosteroneEster]` containing all defined esters.
 62:     ```swift
 63:     import Foundation
 64: 
 65:     struct TestosteroneEster: Identifiable, Codable, Hashable { // Added Hashable for potential use in Pickers
 66:         let id: UUID
 67:         let name: String
 68:         let halfLifeDays: Double
 69: 
 70:         // Default initializer if needed, or rely on memberwise
 71:         init(id: UUID = UUID(), name: String, halfLifeDays: Double) {
 72:             self.id = id
 73:             self.name = name
 74:             self.halfLifeDays = halfLifeDays
 75:         }
 76: 
 77:         static let propionate = TestosteroneEster(name: &quot;Propionate&quot;, halfLifeDays: 0.8)
 78:         static let enanthate = TestosteroneEster(name: &quot;Enanthate&quot;, halfLifeDays: 4.5)
 79:         static let cypionate = TestosteroneEster(name: &quot;Cypionate&quot;, halfLifeDays: 7.0)
 80:         static let undecanoate = TestosteroneEster(name: &quot;Undecanoate&quot;, halfLifeDays: 30.0)
 81: 
 82:         static let all: [TestosteroneEster] = [ .propionate, .enanthate, .cypionate, .undecanoate ]
 83:     }
 84:     ```
 85: *   [x] **Define Injection Protocol Model:**
 86:     *   Create a new Swift file named `ProtocolModel.swift` inside the `Models` group.
 87:     *   Define the `InjectionProtocol` struct:
 88:         *   Make it conform to `Identifiable` and `Codable`.
 89:         *   Include properties:
 90:             *   `id: UUID`
 91:             *   `name: String`
 92:             *   `ester: TestosteroneEster`
 93:             *   `doseMg: Double`
 94:             *   `frequencyDays: Double`
 95:             *   `startDate: Date`
 96:             *   `notes: String?` (optional)
 97:             *   `bloodSamples: [BloodSample]` (initialize as `[]`. `BloodSample` defined next).
 98:     ```swift
 99:     import Foundation
100: 
101:     struct InjectionProtocol: Identifiable, Codable {
102:         var id: UUID = UUID() // Use var if you might need to replace it during edits
103:         var name: String
104:         var ester: TestosteroneEster
105:         var doseMg: Double
106:         var frequencyDays: Double
107:         var startDate: Date
108:         var notes: String?
109:         var bloodSamples: [BloodSample] = [] // BloodSample struct defined next
110:     }
111:     ```
112: *   [x] **Define Bloodwork Model:**
113:     *   Create a new Swift file named `BloodworkModel.swift` inside the `Models` group.
114:     *   Define the `BloodSample` struct:
115:         *   Make it conform to `Identifiable` and `Codable`.
116:         *   Include properties:
117:             *   `id: UUID`
118:             *   `date: Date`
119:             *   `value: Double`
120:             *   `unit: String` (e.g., &quot;ng/dL&quot; or &quot;nmol/L&quot;)
121:     ```swift
122:     import Foundation
123: 
124:     struct BloodSample: Identifiable, Codable, Hashable { // Added Hashable for ForEach iteration if needed
125:         let id: UUID
126:         let date: Date
127:         let value: Double
128:         let unit: String
129: 
130:         // Default initializer if needed
131:         init(id: UUID = UUID(), date: Date, value: Double, unit: String) {
132:             self.id = id
133:             self.date = date
134:             self.value = value
135:             self.unit = unit
136:         }
137:     }
138:     ```
139: *   [x] **Define User Profile Model:**
140:     *   Create a new Swift file named `ProfileModel.swift` inside the `Models` group.
141:     *   Define the `UserProfile` struct:
142:         *   Make it conform to `Codable`.
143:         *   Include properties:
144:             *   `id: UUID`
145:             *   `name: String`
146:             *   `unit: String` (default &quot;ng/dL&quot;)
147:             *   `calibrationFactor: Double` (default `1.0`)
148:             *   `protocols: [InjectionProtocol]` (initialize as `[]`)
149:     ```swift
150:     import Foundation
151: 
152:     struct UserProfile: Codable {
153:         var id: UUID = UUID()
154:         var name: String = &quot;My Profile&quot;
155:         var unit: String = &quot;ng/dL&quot; // Default unit
156:         var calibrationFactor: Double = 1.0 // Default calibration
157:         var protocols: [InjectionProtocol] = []
158:     }
159:     ```
160: *   [x] **Implement Default Data Creation:**
161:     *   Inside the `AppDataStore` class initializer (to be created in Story 3), implement logic to create a default `UserProfile` if none is loaded.
162:     *   This default profile should include at least one sample `InjectionProtocol`. Example:
163:         *   Name: &quot;Default TRT&quot;
164:         *   Ester: `.cypionate`
165:         *   Dose: `100.0` mg
166:         *   Frequency: `7.0` days
167:         *   Start Date: `Date()` (today)
168: *   [x] **Implement Persistence Logic (in AppDataStore):**
169:     *   Inside the `AppDataStore` class (Story 3), add methods for saving and loading the `UserProfile`.
170:     *   **Saving:** Create `func saveProfile()`. Use `JSONEncoder` to encode the `profile` property and save it to `UserDefaults` under the key `&quot;userProfileData&quot;`.
171:     *   **Loading:** In the `init()` of `AppDataStore`, attempt to load data from `UserDefaults` using the key `&quot;userProfileData&quot;`. Use `JSONDecoder` to decode it into a `UserProfile`. If loading fails or no data exists, create the default profile (as defined in the previous step). Handle potential decoding errors (e.g., using `try?` and falling back to default).
172: 
173: ---
174: 
175: ### Story 3: Pharmacokinetic Simulation Logic
176: 
177: *   [x] **Define Simulation Parameters:**
178:     *   In `AppDataStore`, add properties to control the simulation duration.
179:     *   `let simulationDurationDays: Double = 90.0` (or adjust based on half-life later if desired).
180:     *   Add a computed property `simulationEndDate` based on the *selected* protocol&apos;s `startDate` and `simulationDurationDays`.
181: *   [x] **Implement Level Calculation Function:**
182:     *   Create a helper function, perhaps within `AppDataStore` or as a static method, to calculate the concentration at a specific time `t` for a given protocol.
183:     *   Signature idea: `func calculateLevel(at targetDate: Date, for protocol: InjectionProtocol, using calibrationFactor: Double) -&gt; Double`
184:     *   Implement the logic based on the formula:
185:         1.  Calculate time `t_days` in days from `protocol.startDate` to `targetDate`. Return 0 if `targetDate` is before `startDate`.
186:         2.  Calculate the elimination constant `k = log(2) / protocol.ester.halfLifeDays`. Use `log` from `Foundation` (natural logarithm).
187:         3.  Initialize `totalLevel = 0.0`.
188:         4.  Iterate through injection indices `n = 0, 1, 2, ...`.
189:         5.  For each `n`, calculate injection time `injTime_days = Double(n) * protocol.frequencyDays`.
190:         6.  If `injTime_days &gt; t_days`, break the loop.
191:         7.  Calculate time since this injection: `timeDiff_days = t_days - injTime_days`.
192:         8.  Calculate contribution: `contribution = protocol.doseMg * exp(-k * timeDiff_days)`. Use `exp` from `Foundation`.
193:         9.  Add contribution to `totalLevel`.
194:         10. After the loop, multiply `totalLevel` by the `calibrationFactor`.
195:         11. Return the final `totalLevel`.
196:     ```swift
197:     // Example placement inside AppDataStore or a dedicated utility struct/file
198:     func calculateLevel(at targetDate: Date, for protocol: InjectionProtocol, using calibrationFactor: Double) -&gt; Double {
199:         let t_days = targetDate.timeIntervalSince(protocol.startDate) / (24 * 3600) // Time in days since start
200:         guard t_days &gt;= 0 else { return 0.0 }
201: 
202:         guard protocol.ester.halfLifeDays &gt; 0 else { return 0.0 } // Avoid division by zero if halfLife is 0
203:         let k = log(2) / protocol.ester.halfLifeDays // Natural log
204: 
205:         var totalLevel = 0.0
206:         var injIndex = 0
207:         while true {
208:             let injTime_days = Double(injIndex) * protocol.frequencyDays
209:             // Optimization: If frequency is 0 or negative, only consider the first injection
210:             if protocol.frequencyDays &lt;= 0 &amp;&amp; injIndex &gt; 0 { break }
211: 
212:             if injTime_days &gt; t_days { break } // Stop if injection time is after target time
213: 
214:             let timeDiff_days = t_days - injTime_days
215:             if timeDiff_days &gt;= 0 { // Ensure we only calculate for times after injection
216:                  let contribution = protocol.doseMg * exp(-k * timeDiff_days)
217:                  totalLevel += contribution
218:             }
219: 
220:             // Check for infinite loop condition if frequency is 0
221:              if protocol.frequencyDays &lt;= 0 { break }
222: 
223:             injIndex += 1
224:              // Safety break if index gets excessively large (e.g., &gt; 10000) though unlikely with date limits
225:              if injIndex &gt; 10000 { break }
226:         }
227: 
228:         return totalLevel * calibrationFactor
229:     }
230:     ```
231: *   [x] **Define DataPoint Struct:**
232:     *   Create a simple struct to hold simulation data points for the chart. Place it maybe near `AppDataStore` or in `Models`.
233:     ```swift
234:     import Foundation
235: 
236:     struct DataPoint: Identifiable {
237:         let id = UUID() // For ForEach iteration if needed
238:         let time: Date // Use Date for direct use with Swift Charts axis
239:         let level: Double
240:     }
241:     ```
242: *   [x] **Implement Data Series Generation Function:**
243:     *   Create a method in `AppDataStore`, e.g., `func generateSimulationData(for protocol: InjectionProtocol) -&gt; [DataPoint]`.
244:     *   Determine the `endDate` (e.g., `protocol.startDate + simulationDurationDays * 24 * 3600`).
245:     *   Define the time step (e.g., `stepInterval: TimeInterval = 24 * 3600` for daily points, or smaller like `4 * 3600` for 4-hourly).
246:     *   Iterate from `protocol.startDate` up to `endDate` with the chosen `stepInterval`.
247:     *   In each step, call `calculateLevel(at: currentDate, for: protocol, using: profile.calibrationFactor)`.
248:     *   Create a `DataPoint` with the `currentDate` and calculated `level`.
249:     *   Append the `DataPoint` to an array.
250:     *   Return the completed array of `DataPoint`.
251: *   [x] **Setup AppDataStore Class:**
252:     *   Create a new Swift file named `AppDataStore.swift` inside the `ViewModels` group.
253:     *   Define the class `AppDataStore: ObservableObject`. Mark it with `@MainActor`.
254:     *   Add `@Published var profile: UserProfile`.
255:     *   Add `@Published var simulationData: [DataPoint] = []`.
256:     *   Add `@Published var selectedProtocolID: UUID?`.
257:     *   Add `@Published var isPresentingProtocolForm = false`. // For add/edit sheet
258:     *   Add `@Published var protocolToEdit: InjectionProtocol?`. // To know if adding or editing
259: 
260:     *   Implement the `init()` method:
261:         *   Call the loading logic (defined in Story 2) to load `profile` from UserDefaults or create a default one.
262:         *   If `profile.protocols` is not empty, set `selectedProtocolID = profile.protocols.first?.id`.
263:         *   Call `recalcSimulation()` to generate initial data for the selected protocol.
264: *   [x] **Implement AppDataStore Methods:**
265:     *   Implement `func addProtocol(_ newProtocol: InjectionProtocol)`:
266:         *   Append `newProtocol` to `profile.protocols`.
267:         *   Optionally set `selectedProtocolID = newProtocol.id`.
268:         *   Call `recalcSimulation()`.
269:         *   Call `saveProfile()`.
270:     *   Implement `func updateProtocol(_ updatedProtocol: InjectionProtocol)`:
271:         *   Find the index of the protocol with the same `id` in `profile.protocols`.
272:         *   If found, replace the protocol at that index with `updatedProtocol`.
273:         *   If the updated protocol is the currently selected one (`updatedProtocol.id == selectedProtocolID`), call `recalcSimulation()`.
274:         *   Call `saveProfile()`.
275:     *   Implement `func removeProtocol(at offsets: IndexSet)` (for List onDelete):
276:         *   Remove protocols from `profile.protocols` using the provided `offsets`.
277:         *   If the deleted protocol was the selected one, potentially select the first remaining one or set `selectedProtocolID = nil`.
278:         *   Recalculate simulation data if selection changed or list is now empty.
279:         *   Call `saveProfile()`.
280:     *   Implement `func selectProtocol(id: UUID)`:
281:         *   Set `selectedProtocolID = id`.
282:         *   Call `recalcSimulation()`.
283:     *   Implement `func recalcSimulation()`:
284:         *   Guard that `selectedProtocolID` is not nil and find the corresponding `protocol` in `profile.protocols`.
285:         *   If found, call `generateSimulationData(for: foundProtocol)` and assign the result to the `@Published var simulationData`.
286:         *   If not found (e.g., protocol was deleted), clear `simulationData = []`.
287:         *   *(Optimization Note: Consider DispatchQueue only if generation proves slow for very long durations/small steps)*.
288:     *   Implement placeholder `func calibrateProtocol(_ protocol: InjectionProtocol)` (logic in Story 6).
289:     *   Implement placeholder `func predictedLevel(on date: Date, for protocol: InjectionProtocol) -&gt; Double` (reuse `calculateLevel`).
290: *   [x] **Implement Helper Function: Injection Dates:**
291:     *   Add this instance method to the `InjectionProtocol` struct in `ProtocolModel.swift`.
292:     ```swift
293:     // Inside struct InjectionProtocol
294:     func injectionDates(from simulationStartDate: Date, upto endDate: Date) -&gt; [Date] {
295:         var dates: [Date] = []
296:         var current = startDate // Protocol&apos;s own start date
297:         var injectionIndex = 0
298: 
299:         // Find the first injection date that is on or after the simulation&apos;s start date
300:         while current &lt; simulationStartDate {
301:             // Check for zero/negative frequency to avoid infinite loop
302:             guard frequencyDays &gt; 0 else {
303:                 // If first injection is before sim start, add it if it&apos;s the *only* injection
304:                 if injectionIndex == 0 &amp;&amp; current &lt;= endDate { dates.append(current) }
305:                 return dates // Only one injection possible
306:             }
307:             injectionIndex += 1
308:             current = Calendar.current.date(byAdding: .day, value: Int(frequencyDays * Double(injectionIndex)), to: startDate)! // More robust date calculation
309:             // Safety Break
310:             if injectionIndex &gt; 10000 { break }
311:         }
312: 
313: 
314:         // Now add dates within the simulation range [simStartDate, endDate]
315:         // Reset index based on where we are starting relative to protocol start
316:         injectionIndex = Int(round(current.timeIntervalSince(startDate) / (frequencyDays * 24 * 3600)))
317: 
318: 
319:         while current &lt;= endDate {
320:             // Only add if it&apos;s within the simulation&apos;s actual display window start
321:              if current &gt;= simulationStartDate {
322:                  dates.append(current)
323:              }
324: 
325:              // Check for zero/negative frequency
326:              guard frequencyDays &gt; 0 else { break } // Should only add the first one if freq &lt;= 0
327: 
328:             injectionIndex += 1
329:             // Use calendar calculation for adding days to avoid potential DST issues if frequency isn&apos;t integer days
330:             // However, since frequency is Double, TimeInterval is more direct. Stick to TimeInterval for consistency with PK math.
331:             current = startDate.addingTimeInterval(Double(injectionIndex) * frequencyDays * 24 * 3600)
332:              // Safety Break
333:              if injectionIndex &gt; 10000 { break }
334:         }
335:         return dates
336:     }
337:     ```
338:     *   *Correction:* The chart needs dates relative to the simulation window, not just the protocol start. The `injectionDates` function needs the simulation&apos;s start/end. Update signature and logic.
339: *   [x] **Implement Helper Function: Formatting Value:**
340:     *   Add a helper function, maybe in `AppDataStore` or a utility file, to format numbers.
341:     ```swift
342:     func formatValue(_ value: Double, unit: String) -&gt; String {
343:         let formatter = NumberFormatter()
344:         formatter.numberStyle = .decimal
345:         if unit == &quot;nmol/L&quot; {
346:             formatter.maximumFractionDigits = 1
347:         } else { // ng/dL typically whole numbers
348:             formatter.maximumFractionDigits = 0
349:         }
350:         formatter.minimumFractionDigits = formatter.maximumFractionDigits // Ensure consistency
351:         return formatter.string(from: NSNumber(value: value)) ?? &quot;\(value)&quot;
352:     }
353: 
354:     // Add unit conversion helper if needed later, for now assume values are stored correctly
355:     // let NGDL_PER_NMOL = 28.85
356:     ```
357: 
358: ---
359: 
360: ### Story 4: UI – Protocol List &amp; Navigation
361: 
362: *   [x] **Implement ContentView:**
363:     *   Create `ContentView.swift` in the `Views` group.
364:     *   Use `NavigationStack`.
365:     *   Embed `ProtocolListView`.
366:     *   Inject `AppDataStore` using `@EnvironmentObject`.
367:     ```swift
368:     import SwiftUI
369: 
370:     struct ContentView: View {
371:         @EnvironmentObject var dataStore: AppDataStore
372: 
373:         var body: some View {
374:             NavigationStack {
375:                 ProtocolListView()
376:             }
377:         }
378:     }
379:     ```
380: *   [x] **Implement ProtocolListView:**
381:     *   Create `ProtocolListView.swift` in the `Views` group.
382:     *   Use `@EnvironmentObject var dataStore: AppDataStore`.
383:     *   Use a `List` to display `dataStore.profile.protocols`.
384:     *   Inside the `List`, use `ForEach` over the protocols.
385:     *   Each row should be a `NavigationLink` pointing to `ProtocolDetailView(protocol: proto)`.
386:     *   The `NavigationLink` label should display the protocol `name` (e.g., `.headline`) and a summary (`dose`, `ester`, `frequency` - e.g., `.subheadline`, `.secondary`).
387:     *   Add `.navigationTitle(&quot;Protocols&quot;)`.
388:     *   Handle the case where `dataStore.profile.protocols` is empty (display a message like &quot;No protocols yet. Tap + to add one.&quot;).
389: *   [x] **Implement List Delete Functionality:**
390:     *   Add the `.onDelete(perform: deleteItems)` modifier to the `ForEach` inside the `List`.
391:     *   Implement the `private func deleteItems(at offsets: IndexSet)` method in `ProtocolListView`.
392:     *   This method should call the corresponding removal function in `dataStore` (e.g., `dataStore.removeProtocol(at: offsets)`).
393: *   [x] **Implement Toolbar Actions:**
394:     *   Add a `.toolbar` modifier to the `List` or containing `VStack`.
395:     *   Add a `ToolbarItem(placement: .primaryAction)` with a `Button` containing a `Label(&quot;Add Protocol&quot;, systemImage: &quot;plus&quot;)`.
396:     *   The button&apos;s action should set `dataStore.protocolToEdit = nil` and `dataStore.isPresentingProtocolForm = true`.
397:     *   Add a `ToolbarItem(placement: .navigationBarLeading)` with a `NavigationLink` to `ProfileView()` using a `Label(&quot;Profile&quot;, systemImage: &quot;person.circle&quot;)`.
398: *   [x] **Implement Sheet Presentation for Form:**
399:     *   Add the `.sheet(isPresented: $dataStore.isPresentingProtocolForm)` modifier.
400:     *   The sheet&apos;s content should be `ProtocolFormView(protocolToEdit: dataStore.protocolToEdit)`. ( `ProtocolFormView` is defined later).
401:     *   Pass the `environmentObject` to the sheet content: `.environmentObject(dataStore)`.
402: *   [x] **Implement ProfileView:**
403:     *   Create `ProfileView.swift` in the `Views` group.
404:     *   Use `@EnvironmentObject var dataStore: AppDataStore`.
405:     *   Use a `Form` for the layout.
406:     *   Add a `Section(&quot;User&quot;)` with a `TextField(&quot;Name&quot;, text: $dataStore.profile.name)`.
407:     *   Add a `Section(&quot;Settings&quot;)` with a `Picker(&quot;Preferred Unit&quot;, selection: $dataStore.profile.unit)` containing options &quot;ng/dL&quot; and &quot;nmol/L&quot;. Use `Text` views for the options.
408:     *   Add a `Section(&quot;Calibration&quot;)` displaying the current `dataStore.profile.calibrationFactor` (read-only for now, or add a Reset button).
409:         ```swift
410:         Text(&quot;Model Calibration Factor: \(dataStore.profile.calibrationFactor, specifier: &quot;%.2f&quot;)&quot;)
411:         Button(&quot;Reset Calibration to 1.0&quot;) {
412:             dataStore.profile.calibrationFactor = 1.0
413:             dataStore.recalcSimulation() // Recalculate if factor changed
414:              dataStore.saveProfile() // Save change
415:         }
416:         ```
417:     *   Use `.onChange` or `.onDisappear` to trigger `dataStore.saveProfile()` when relevant profile properties change. Add `.navigationTitle(&quot;Profile Settings&quot;)`.
418:     *   *Note on Binding:* To bind directly to `dataStore.profile.name` etc., ensure `AppDataStore` publishes changes correctly when sub-properties of `profile` are modified. Wrapping setters in `objectWillChange.send()` might be needed if direct binding doesn&apos;t trigger saves, or trigger save `onDisappear`. A simple approach is adding explicit save calls.
419: 
420: ---
421: 
422: ### Story 5: UI – Protocol Detail &amp; Simulation Chart
423: 
424: *   [x] **Implement ProtocolDetailView Structure:**
425:     *   Create `ProtocolDetailView.swift` in the `Views` group.
426:     *   Add `@EnvironmentObject var dataStore: AppDataStore`.
427:     *   Add `let injectionProtocol: InjectionProtocol` property (passed via `NavigationLink`).
428:     *   Use a `ScrollView` containing a `VStack(alignment: .leading, spacing: 16)`.
429:     *   Add `Text` views to display the protocol summary (Dose, Ester, Frequency).
430:     *   Add a placeholder where the chart will go.
431:     *   Use `.padding()` on the `VStack`.
432:     *   Set `.navigationTitle(injectionProtocol.name)`.
433:     *   Add `.navigationBarTitleDisplayMode(.inline)` if preferred.
434: *   [x] **Implement Detail View Data Loading:**
435:     *   Add an `.onAppear` modifier to the main view inside `ProtocolDetailView`.
436:     *   Inside `.onAppear`, call `dataStore.selectProtocol(id: injectionProtocol.id)`. This ensures the `simulationData` in the store corresponds to *this* protocol when the view appears.
437: *   [x] **Implement Last Bloodwork Display:**
438:     *   Inside the `VStack`, add logic to display info about the latest blood sample:
439:     *   Find the latest sample: `let latestSample = injectionProtocol.bloodSamples.max(by: { $0.date &lt; $1.date })`.
440:     *   If `latestSample` exists:
441:         *   Calculate the model&apos;s prediction for that date: `let modelPrediction = dataStore.calculateLevel(at: latestSample.date, for: injectionProtocol, using: dataStore.profile.calibrationFactor)`
442:         *   Display `Text` showing the sample date, measured value (`formatValue`), and the model prediction (`formatValue`) using the profile&apos;s preferred unit (`dataStore.profile.unit`). Format the date clearly.
443: *   [x] **Implement Detail View Action Buttons:**
444:     *   Add an `HStack` below the chart area.
445:     *   Add a `Button` with `Label(&quot;Add Bloodwork&quot;, systemImage: &quot;drop.fill&quot;)`.
446:         *   Action: Set `@State private var showingAddBloodSheet = false` to `true`.
447:     *   Add a `Button` with `Label(&quot;Recalibrate Model&quot;, systemImage: &quot;slider.horizontal.3&quot;)`.
448:         *   Action: Call `dataStore.calibrateProtocol(injectionProtocol)` (implement logic in Story 6). Show confirmation alert: `@State private var showingCalibrateConfirm = false`. Set this state bool to true in the button action.
449:         *   Disable this button if `injectionProtocol.bloodSamples.isEmpty`. Use `.disabled(injectionProtocol.bloodSamples.isEmpty)`.
450: *   [x] **Implement Detail View Toolbar/Sheet:**
451:     *   Add a `.toolbar` modifier.
452:     *   Add `ToolbarItem(placement: .primaryAction)` with a `Button(&quot;Edit&quot;)`.
453:         *   Action: Set `dataStore.protocolToEdit = injectionProtocol` and `dataStore.isPresentingProtocolForm = true`.
454:     *   Add the `.sheet(isPresented: $showingAddBloodSheet)` modifier.
455:         *   Content: `AddBloodworkView(injectionProtocol: injectionProtocol)`. Pass environment object. (`AddBloodworkView` defined in Story 6).
456:     *   Add the `.alert(&quot;Calibration Updated&quot;, isPresented: $showingCalibrateConfirm)` modifier with a dismiss Button(&quot;OK&quot;).
457: *   [x] **Implement TestosteroneChart View:**
458:     *   Create `TestosteroneChart.swift` in the `Views` group (or embed code directly in `ProtocolDetailView`).
459:     *   Add `@EnvironmentObject var dataStore: AppDataStore`.
460:     *   Add `let protocol: InjectionProtocol`.
461:     *   Import `Charts`.
462:     *   The `body` should return a `Chart { ... }`.
463:     *   Set a frame, e.g., `.frame(height: 300)`.
464: *   [x] **Implement Chart: Simulation Curve:**
465:     *   Inside `Chart`, add `ForEach(dataStore.simulationData) { point in ... }`. (Ensure `DataPoint` is `Identifiable`).
466:     *   Inside the `ForEach`, add `LineMark(x: .value(&quot;Date&quot;, point.time), y: .value(&quot;Level&quot;, point.level))`. Style with `.foregroundStyle(.blue)`.
467:     *   Inside the `ForEach`, also add `AreaMark(x: .value(&quot;Date&quot;, point.time), y: .value(&quot;Level&quot;, point.level))`. Style with `.foregroundStyle(LinearGradient(...))` using blue opacity gradient from top (e.g., 0.3) to bottom (0.0).
468: *   [x] **Implement Chart: Injection Markers:**
469:     *   Calculate the simulation start/end dates needed for `injectionDates`. Use `dataStore.simulationData.first?.time` and `dataStore.simulationData.last?.time` if available, or calculate based on `protocol.startDate` and `simulationDurationDays`.
470:     *   Add `ForEach(protocol.injectionDates(from: simStartDate, upto: simEndDate), id: \.self) { injDate in ... }`.
471:     *   Inside, add `RuleMark(x: .value(&quot;Injection Date&quot;, injDate))`.
472:     *   Style it: `.lineStyle(StrokeStyle(lineWidth: 1, dash: [2, 4]))`, `.foregroundStyle(.gray)`.
473:     *   Add an annotation: `.annotation(position: .bottom, alignment: .center) { Image(systemName: &quot;syringe&quot;).font(.caption).foregroundColor(.gray) }`.
474: *   [x] **Implement Chart: Bloodwork Points:**
475:     *   Add `ForEach(protocol.bloodSamples) { sample in ... }`.
476:     *   Inside, add `PointMark(x: .value(&quot;Sample Date&quot;, sample.date), y: .value(&quot;Sample Level&quot;, sample.value))`.
477:     *   Style it: `.foregroundStyle(.red)`.
478:     *   Add annotation: `.annotation(position: .overlay, alignment: .top) { Text(formatValue(sample.value, unit: sample.unit)).font(.caption).foregroundColor(.red).padding(.bottom, 8) }`. Adjust position/padding as needed.
479:     *   *(Optional: Add `.symbol(by: .value(&quot;Data Type&quot;, &quot;Bloodwork&quot;))` if a legend distinguishing points is desired).*
480: *   [x] **Implement Chart Axes Customization:**
481:     *   Add `.chartXAxis { AxisMarks(values: .automatic(desiredCount: 8)) { AxisGridLine() AxisValueLabel(format: .dateTime.month().day(), centered: true) } }`. Adjust desiredCount and format as needed.
482:     *   Add `.chartYAxis { AxisMarks { AxisGridLine() AxisValueLabel() } }`.
483:     *   Add `.chartYAxisLabel(&quot;Level (\(dataStore.profile.unit))&quot;)`.
484:     *   Add `.chartXAxisLabel(&quot;Date&quot;)`.
485:     *   *(Optional: Hide legend if automatically generated and not needed: `.chartLegend(.hidden)`)*.
486: 
487: ---
488: 
489: ### Story 6: UI – Add Bloodwork and Calibration
490: 
491: *   [x] **Implement AddBloodworkView Structure:**
492:     *   Create `AddBloodworkView.swift` in the `Views` group.
493:     *   Add `@EnvironmentObject var dataStore: AppDataStore`.
494:     *   Add `@Environment(\.dismiss) var dismiss`.
495:     *   Add `let injectionProtocol: InjectionProtocol`.
496:     *   Add `@State private var date: Date = Date()`.
497:     *   Add `@State private var valueText: String = &quot;&quot;`.
498:     *   Add `@State private var selectedUnit: String = &quot;ng/dL&quot;`. // Default or initialize from profile.unit
499:     *   Use a `NavigationView` (to get a toolbar in the sheet). Inside, use a `Form`. Set a `.navigationTitle(&quot;Add Blood Test Result&quot;)`.
500: *   [x] **Implement AddBloodworkView Fields:**
501:     *   Inside the `Form`, add a `DatePicker(&quot;Date&quot;, selection: $date, in: injectionProtocol.startDate..., displayedComponents: [.date, .hourAndMinute])`. Limit the range from protocol start date onwards.
502:     *   Add a `TextField(&quot;Testosterone Level&quot;, text: $valueText)`. Use `.keyboardType(.decimalPad)`.
503:     *   Add a `Picker(&quot;Unit&quot;, selection: $selectedUnit)` with `Text(&quot;ng/dL&quot;).tag(&quot;ng/dL&quot;)` and `Text(&quot;nmol/L&quot;).tag(&quot;nmol/L&quot;)`.
504: *   [x] **Implement AddBloodworkView Save/Cancel Toolbar:**
505:     *   Add a `.toolbar` to the `NavigationView`.
506:     *   Add `ToolbarItem(placement: .navigationBarLeading)` with a `Button(&quot;Cancel&quot;) { dismiss() }`.
507:     *   Add `ToolbarItem(placement: .navigationBarTrailing)` with a `Button(&quot;Save&quot;) { saveBloodwork() }`. Disable the Save button if `valueText` is empty or not a valid number: `.disabled(Double(valueText) == nil)`.
508: *   [x] **Implement AddBloodworkView Save Logic:**
509:     *   Create `private func saveBloodwork()`.
510:     *   Inside the function:
511:         1.  Guard that `valueText` can be converted to a `Double`, else return. `guard let value = Double(valueText) else { return }`.
512:         2.  Create a `newSample = BloodSample(date: date, value: value, unit: selectedUnit)`.
513:         3.  Find the index of the current `injectionProtocol` in `dataStore.profile.protocols`.
514:         4.  If found, append `newSample` to `dataStore.profile.protocols[index].bloodSamples`.
515:         5.  Call `dataStore.saveProfile()`.
516:         6.  Call `dismiss()`.
517: *   [x] **Implement Calibration Logic Function:**
518:     *   Implement the `func calibrateProtocol(_ protocolToCalibrate: InjectionProtocol)` method in `AppDataStore`.
519:     *   Inside the function:
520:         1.  Find the protocol in the `profile.protocols` array using `protocolToCalibrate.id`. Ensure it exists.
521:         2.  Get the latest blood sample: `guard let latestSample = protocolToCalibrate.bloodSamples.max(by: { $0.date &lt; $1.date }) else { return }` (or handle error/message).
522:         3.  Calculate the model&apos;s prediction *at the sample date*, using the *current* calibration factor: `let modelPrediction = calculateLevel(at: latestSample.date, for: protocolToCalibrate, using: profile.calibrationFactor)`.
523:         4.  Guard against division by zero or near-zero: `guard modelPrediction &gt; 0.01 else { print(&quot;Model prediction too low, cannot calibrate.&quot;); return }`.
524:         5.  Calculate the required factor *relative to the current one*: `let adjustmentRatio = latestSample.value / modelPrediction`.
525:         6.  Update the profile&apos;s factor: `profile.calibrationFactor *= adjustmentRatio`.
526:         7.  Call `recalcSimulation()` to update the chart data with the new factor.
527:         8.  Call `saveProfile()` to persist the new factor.
528: *   [x] **Connect Calibration UI:**
529:     *   Verify the &quot;Recalibrate Model&quot; button in `ProtocolDetailView` correctly calls `dataStore.calibrateProtocol(injectionProtocol)` and sets the state variable to show the confirmation alert.
530: 
531: ---
532: 
533: ### Story 7: Polish and Testing
534: 
535: *   [ ] **UI Polish: Appearance:**
536:     *   Test the app in both **Light Mode** and **Dark Mode**. Ensure text is legible and colors (especially chart colors) look good. Adjust opacities or use adaptive colors if needed.
537:     *   Check font sizes and text wrapping. Ensure UI elements resize reasonably on different screen sizes (e.g., iPhone vs iPad if supported).
538:     *   Verify padding and spacing provide a clean layout.
539: *   [ ] **UI Polish: App Icon &amp; Launch Screen:**
540:     *   *(Optional)* Add a custom AppIcon asset set in `Resources`.
541:     *   *(Optional)* Configure a basic Launch Screen (e.g., using `Info.plist` settings or a Launch Screen storyboard - though SwiftUI prefers quick launch).
542: *   [ ] **UI Polish: Optional Animation:**
543:     *   *(Optional)* If Lottie was included, integrate a simple `LottieView` animation (e.g., a checkmark animation shown briefly after saving or calibration).
544: *   [ ] **Accessibility:**
545:     *   *(Basic Pass)* Ensure standard controls (Buttons, TextFields, Pickers) have default accessibility support. Add `.accessibilityLabel` or `.accessibilityHint` to custom controls or complex elements if time permits (especially chart elements).
546: *   [ ] **Testing: Simulation Accuracy:**
547:     *   Manually run simulations for known protocols (e.g., 100mg Cypionate weekly). Check if the plotted curve visually matches expected pharmacokinetics (e.g., reaches steady state, trough levels relative to peak look reasonable based on half-life). Print key values (peak, trough after X weeks) to console if needed for verification.
548:     *   Test with different esters (Propionate, Enanthate, Undecanoate) to ensure their different half-lives produce visibly different curve shapes.
549: *   [ ] **Testing: Calibration:**
550:     *   Add a blood sample manually. Note the model&apos;s prediction at that point.
551:     *   Press &quot;Recalibrate Model&quot;.
552:     *   Verify the chart curve shifts and now passes through (or very close to) the blood sample point used for calibration.
553:     *   Verify the `calibrationFactor` stored in `UserProfile` has changed.
554: *   [ ] **Testing: Bug Fixes &amp; Edge Cases:**
555:     *   Test deleting the last protocol. Does the UI update gracefully?
556:     *   Test adding the first protocol.
557:     *   Test editing a protocol (dose, frequency, ester). Does the chart update correctly when returning to the detail view?
558:     *   Attempt to add bloodwork with a date *before* the protocol start date (should be prevented by the `DatePicker` range).
559:     *   Attempt to save bloodwork with non-numeric input (Save button should be disabled).
560:     *   Test calibration with only one sample. Test recalibrating with a second, different sample.
561: *   [ ] **Documentation &amp; Preparation:**
562:     *   Create a basic `README.md` file in the project root explaining the app&apos;s purpose and how to build/run it.
563:     *   Add comments to complex code sections (especially `calculateLevel` and `calibrateProtocol`).
564:     *   Add a `LICENSE` file (e.g., MIT).
565: *   [ ] **Multi-Platform Testing (If Applicable):**
566:     *   If macOS target was enabled, run the app on macOS. Check for any layout issues or platform-specific behaviors that need adjustment (e.g., toolbar items, sheet presentation).
567: 
568: ---
569: 
570: This checklist should provide a clear, sequential path for the code assistant to implement the TestoSim application.

================
File: TestoSim/Models/ProtocolModel.swift
================
 1: import Foundation
 2: struct InjectionProtocol: Identifiable, Codable {
 3:     var id: UUID = UUID()
 4:     var name: String
 5:     var doseMg: Double
 6:     var frequencyDays: Double
 7:     var startDate: Date
 8:     var notes: String?
 9:     var bloodSamples: [BloodSample] = []
10:     // Properties for compound/blend support
11:     var compoundID: UUID?
12:     var blendID: UUID?
13:     var selectedRoute: String? // Stores Compound.Route.rawValue
14:     // Computed property to determine protocol type
15:     var protocolType: ProtocolType {
16:         if compoundID != nil {
17:             return .compound
18:         } else if blendID != nil {
19:             return .blend
20:         } else {
21:             // This should not happen in new protocols
22:             return .compound // Default to compound
23:         }
24:     }
25:     // MARK: - Injection dates calculation
26:     func injectionDates(from simulationStartDate: Date, upto endDate: Date) -&gt; [Date] {
27:         var dates: [Date] = []
28:         var current = startDate
29:         var injectionIndex = 0
30:         // Check for zero/negative frequency to avoid infinite loop
31:         guard frequencyDays &gt; 0 else {
32:             // For zero/negative frequency, just include the start date if it&apos;s in range
33:             if startDate &lt;= endDate &amp;&amp; startDate &gt;= simulationStartDate {
34:                 dates.append(startDate)
35:             }
36:             return dates
37:         }
38:         // Calculate how many injections would have occurred before the simulation start
39:         // by determining the injection index offset
40:         if simulationStartDate &gt; startDate {
41:             let daysSinceStart = simulationStartDate.timeIntervalSince(startDate) / (24 * 3600)
42:             injectionIndex = Int(floor(daysSinceStart / frequencyDays))
43:             // Set current to the first injection that&apos;s on or after simulationStartDate
44:             current = startDate.addingTimeInterval(Double(injectionIndex) * frequencyDays * 24 * 3600)
45:         }
46:         // Now add all injections from current date up to endDate
47:         while current &lt;= endDate {
48:             dates.append(current)
49:             injectionIndex += 1
50:             current = startDate.addingTimeInterval(Double(injectionIndex) * frequencyDays * 24 * 3600)
51:             // Safety break to prevent infinite loops
52:             if injectionIndex &gt; 10000 { 
53:                 print(&quot;Safety break in injection dates calculation&quot;)
54:                 break 
55:             }
56:         }
57:         return dates
58:     }
59: }
60: // MARK: - Protocol type enum
61: enum ProtocolType: String, Codable {
62:     case compound    // Using single Compound
63:     case blend       // Using VialBlend
64: }

================
File: TestoSim/TestoSim.xcdatamodeld/TestoSim.xcdatamodel/contents
================
 1: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
 2: &lt;model type=&quot;com.apple.IDECoreDataModeler.DataModel&quot; documentVersion=&quot;1.0&quot; lastSavedToolsVersion=&quot;23788&quot; systemVersion=&quot;24E263&quot; minimumToolsVersion=&quot;Automatic&quot; sourceLanguage=&quot;Swift&quot; userDefinedModelVersionIdentifier=&quot;&quot;&gt;
 3:     &lt;entity name=&quot;CDBloodSample&quot; representedClassName=&quot;CDBloodSample&quot; syncable=&quot;YES&quot; codeGenerationType=&quot;category&quot;&gt;
 4:         &lt;attribute name=&quot;date&quot; optional=&quot;YES&quot; attributeType=&quot;Date&quot; usesScalarValueType=&quot;NO&quot;/&gt;
 5:         &lt;attribute name=&quot;id&quot; optional=&quot;YES&quot; attributeType=&quot;UUID&quot; usesScalarValueType=&quot;NO&quot;/&gt;
 6:         &lt;attribute name=&quot;unit&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
 7:         &lt;attribute name=&quot;value&quot; optional=&quot;YES&quot; attributeType=&quot;Double&quot; defaultValueString=&quot;0.0&quot; usesScalarValueType=&quot;YES&quot;/&gt;
 8:         &lt;relationship name=&quot;injectionProtocol&quot; optional=&quot;YES&quot; maxCount=&quot;1&quot; deletionRule=&quot;Nullify&quot; destinationEntity=&quot;CDInjectionProtocol&quot; inverseName=&quot;bloodSamples&quot; inverseEntity=&quot;CDInjectionProtocol&quot;/&gt;
 9:         &lt;fetchedProperty name=&quot;fetchedProperty&quot; optional=&quot;YES&quot;&gt;
10:             &lt;fetchRequest name=&quot;fetchedPropertyFetchRequest&quot; entity=&quot;CDBloodSample&quot;/&gt;
11:         &lt;/fetchedProperty&gt;
12:     &lt;/entity&gt;
13:     &lt;entity name=&quot;CDCompound&quot; representedClassName=&quot;CDCompound&quot; syncable=&quot;YES&quot; codeGenerationType=&quot;category&quot;&gt;
14:         &lt;attribute name=&quot;classType&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
15:         &lt;attribute name=&quot;commonName&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
16:         &lt;attribute name=&quot;ester&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
17:         &lt;attribute name=&quot;halfLifeDays&quot; optional=&quot;YES&quot; attributeType=&quot;Double&quot; defaultValueString=&quot;0.0&quot; usesScalarValueType=&quot;YES&quot;/&gt;
18:         &lt;attribute name=&quot;id&quot; optional=&quot;YES&quot; attributeType=&quot;UUID&quot; usesScalarValueType=&quot;NO&quot;/&gt;
19:         &lt;attribute name=&quot;routeBioavailabilityData&quot; optional=&quot;YES&quot; attributeType=&quot;Binary&quot;/&gt;
20:         &lt;attribute name=&quot;routeKaData&quot; optional=&quot;YES&quot; attributeType=&quot;Binary&quot;/&gt;
21:         &lt;relationship name=&quot;components&quot; optional=&quot;YES&quot; toMany=&quot;YES&quot; deletionRule=&quot;Nullify&quot; destinationEntity=&quot;CDVialComponent&quot; inverseName=&quot;compound&quot; inverseEntity=&quot;CDVialComponent&quot;/&gt;
22:         &lt;relationship name=&quot;protocols&quot; optional=&quot;YES&quot; toMany=&quot;YES&quot; deletionRule=&quot;Nullify&quot; destinationEntity=&quot;CDInjectionProtocol&quot; inverseName=&quot;ester&quot; inverseEntity=&quot;CDInjectionProtocol&quot;/&gt;
23:     &lt;/entity&gt;
24:     &lt;entity name=&quot;CDCycle&quot; representedClassName=&quot;CDCycle&quot; syncable=&quot;YES&quot; codeGenerationType=&quot;category&quot;&gt;
25:         &lt;attribute name=&quot;id&quot; optional=&quot;YES&quot; attributeType=&quot;UUID&quot; usesScalarValueType=&quot;NO&quot;/&gt;
26:         &lt;attribute name=&quot;name&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
27:         &lt;attribute name=&quot;notes&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
28:         &lt;attribute name=&quot;startDate&quot; optional=&quot;YES&quot; attributeType=&quot;Date&quot; usesScalarValueType=&quot;NO&quot;/&gt;
29:         &lt;attribute name=&quot;totalWeeks&quot; optional=&quot;YES&quot; attributeType=&quot;Integer 32&quot; defaultValueString=&quot;0&quot; usesScalarValueType=&quot;YES&quot;/&gt;
30:         &lt;relationship name=&quot;stages&quot; optional=&quot;YES&quot; toMany=&quot;YES&quot; deletionRule=&quot;Cascade&quot; destinationEntity=&quot;CDCycleStage&quot; inverseName=&quot;cycle&quot; inverseEntity=&quot;CDCycleStage&quot;/&gt;
31:         &lt;relationship name=&quot;userProfile&quot; optional=&quot;YES&quot; maxCount=&quot;1&quot; deletionRule=&quot;Nullify&quot; destinationEntity=&quot;CDUserProfile&quot; inverseName=&quot;cycles&quot; inverseEntity=&quot;CDUserProfile&quot;/&gt;
32:     &lt;/entity&gt;
33:     &lt;entity name=&quot;CDCycleStage&quot; representedClassName=&quot;CDCycleStage&quot; syncable=&quot;YES&quot; codeGenerationType=&quot;category&quot;&gt;
34:         &lt;attribute name=&quot;blendsData&quot; optional=&quot;YES&quot; attributeType=&quot;Binary&quot;/&gt;
35:         &lt;attribute name=&quot;compoundsData&quot; optional=&quot;YES&quot; attributeType=&quot;Binary&quot;/&gt;
36:         &lt;attribute name=&quot;durationWeeks&quot; optional=&quot;YES&quot; attributeType=&quot;Integer 32&quot; defaultValueString=&quot;0&quot; usesScalarValueType=&quot;YES&quot;/&gt;
37:         &lt;attribute name=&quot;id&quot; optional=&quot;YES&quot; attributeType=&quot;UUID&quot; usesScalarValueType=&quot;NO&quot;/&gt;
38:         &lt;attribute name=&quot;name&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
39:         &lt;attribute name=&quot;startWeek&quot; optional=&quot;YES&quot; attributeType=&quot;Integer 32&quot; defaultValueString=&quot;0&quot; usesScalarValueType=&quot;YES&quot;/&gt;
40:         &lt;relationship name=&quot;cycle&quot; optional=&quot;YES&quot; maxCount=&quot;1&quot; deletionRule=&quot;Nullify&quot; destinationEntity=&quot;CDCycle&quot; inverseName=&quot;stages&quot; inverseEntity=&quot;CDCycle&quot;/&gt;
41:     &lt;/entity&gt;
42:     &lt;entity name=&quot;CDInjectionProtocol&quot; representedClassName=&quot;CDInjectionProtocol&quot; syncable=&quot;YES&quot; codeGenerationType=&quot;category&quot;&gt;
43:         &lt;attribute name=&quot;doseMg&quot; optional=&quot;YES&quot; attributeType=&quot;Double&quot; defaultValueString=&quot;0.0&quot; usesScalarValueType=&quot;YES&quot;/&gt;
44:         &lt;attribute name=&quot;frequencyDays&quot; optional=&quot;YES&quot; attributeType=&quot;Double&quot; defaultValueString=&quot;0.0&quot; usesScalarValueType=&quot;YES&quot;/&gt;
45:         &lt;attribute name=&quot;id&quot; optional=&quot;YES&quot; attributeType=&quot;UUID&quot; usesScalarValueType=&quot;NO&quot;/&gt;
46:         &lt;attribute name=&quot;name&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
47:         &lt;attribute name=&quot;notes&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
48:         &lt;attribute name=&quot;startDate&quot; optional=&quot;YES&quot; attributeType=&quot;Date&quot; usesScalarValueType=&quot;NO&quot;/&gt;
49:         &lt;relationship name=&quot;bloodSamples&quot; optional=&quot;YES&quot; toMany=&quot;YES&quot; deletionRule=&quot;Cascade&quot; destinationEntity=&quot;CDBloodSample&quot; inverseName=&quot;injectionProtocol&quot; inverseEntity=&quot;CDBloodSample&quot;/&gt;
50:         &lt;relationship name=&quot;ester&quot; optional=&quot;YES&quot; maxCount=&quot;1&quot; deletionRule=&quot;Nullify&quot; destinationEntity=&quot;CDCompound&quot; inverseName=&quot;protocols&quot; inverseEntity=&quot;CDCompound&quot;/&gt;
51:         &lt;relationship name=&quot;profile&quot; optional=&quot;YES&quot; maxCount=&quot;1&quot; deletionRule=&quot;Nullify&quot; destinationEntity=&quot;CDUserProfile&quot; inverseName=&quot;protocols&quot; inverseEntity=&quot;CDUserProfile&quot;/&gt;
52:     &lt;/entity&gt;
53:     &lt;entity name=&quot;CDUserProfile&quot; representedClassName=&quot;CDUserProfile&quot; syncable=&quot;YES&quot; codeGenerationType=&quot;category&quot;&gt;
54:         &lt;attribute name=&quot;biologicalSex&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
55:         &lt;attribute name=&quot;calibrationFactor&quot; optional=&quot;YES&quot; attributeType=&quot;Double&quot; defaultValueString=&quot;1.0&quot; usesScalarValueType=&quot;YES&quot;/&gt;
56:         &lt;attribute name=&quot;dateOfBirth&quot; optional=&quot;YES&quot; attributeType=&quot;Date&quot; usesScalarValueType=&quot;NO&quot;/&gt;
57:         &lt;attribute name=&quot;heightCm&quot; optional=&quot;YES&quot; attributeType=&quot;Double&quot; defaultValueString=&quot;0.0&quot; usesScalarValueType=&quot;YES&quot;/&gt;
58:         &lt;attribute name=&quot;id&quot; optional=&quot;YES&quot; attributeType=&quot;UUID&quot; usesScalarValueType=&quot;NO&quot;/&gt;
59:         &lt;attribute name=&quot;name&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
60:         &lt;attribute name=&quot;unit&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
61:         &lt;attribute name=&quot;usesICloudSync&quot; optional=&quot;YES&quot; attributeType=&quot;Boolean&quot; defaultValueString=&quot;NO&quot; usesScalarValueType=&quot;YES&quot;/&gt;
62:         &lt;attribute name=&quot;useTwoCompartmentModel&quot; optional=&quot;YES&quot; attributeType=&quot;Boolean&quot; defaultValueString=&quot;NO&quot; usesScalarValueType=&quot;YES&quot;/&gt;
63:         &lt;attribute name=&quot;weight&quot; optional=&quot;YES&quot; attributeType=&quot;Double&quot; defaultValueString=&quot;0.0&quot; usesScalarValueType=&quot;YES&quot;/&gt;
64:         &lt;relationship name=&quot;cycles&quot; optional=&quot;YES&quot; toMany=&quot;YES&quot; deletionRule=&quot;Cascade&quot; destinationEntity=&quot;CDCycle&quot; inverseName=&quot;userProfile&quot; inverseEntity=&quot;CDCycle&quot;/&gt;
65:         &lt;relationship name=&quot;protocols&quot; optional=&quot;YES&quot; toMany=&quot;YES&quot; deletionRule=&quot;Cascade&quot; destinationEntity=&quot;CDInjectionProtocol&quot; inverseName=&quot;profile&quot; inverseEntity=&quot;CDInjectionProtocol&quot;/&gt;
66:     &lt;/entity&gt;
67:     &lt;entity name=&quot;CDVialBlend&quot; representedClassName=&quot;CDVialBlend&quot; syncable=&quot;YES&quot; codeGenerationType=&quot;category&quot;&gt;
68:         &lt;attribute name=&quot;blendDescription&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
69:         &lt;attribute name=&quot;id&quot; optional=&quot;YES&quot; attributeType=&quot;UUID&quot; usesScalarValueType=&quot;NO&quot;/&gt;
70:         &lt;attribute name=&quot;manufacturer&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
71:         &lt;attribute name=&quot;name&quot; optional=&quot;YES&quot; attributeType=&quot;String&quot;/&gt;
72:         &lt;relationship name=&quot;components&quot; optional=&quot;YES&quot; toMany=&quot;YES&quot; deletionRule=&quot;Cascade&quot; destinationEntity=&quot;CDVialComponent&quot; inverseName=&quot;vialBlend&quot; inverseEntity=&quot;CDVialComponent&quot;/&gt;
73:     &lt;/entity&gt;
74:     &lt;entity name=&quot;CDVialComponent&quot; representedClassName=&quot;CDVialComponent&quot; syncable=&quot;YES&quot; codeGenerationType=&quot;category&quot;&gt;
75:         &lt;attribute name=&quot;mgPerML&quot; optional=&quot;YES&quot; attributeType=&quot;Double&quot; defaultValueString=&quot;0.0&quot; usesScalarValueType=&quot;YES&quot;/&gt;
76:         &lt;relationship name=&quot;compound&quot; optional=&quot;YES&quot; maxCount=&quot;1&quot; deletionRule=&quot;Nullify&quot; destinationEntity=&quot;CDCompound&quot; inverseName=&quot;components&quot; inverseEntity=&quot;CDCompound&quot;/&gt;
77:         &lt;relationship name=&quot;vialBlend&quot; optional=&quot;YES&quot; maxCount=&quot;1&quot; deletionRule=&quot;Nullify&quot; destinationEntity=&quot;CDVialBlend&quot; inverseName=&quot;components&quot; inverseEntity=&quot;CDVialBlend&quot;/&gt;
78:     &lt;/entity&gt;
79: &lt;/model&gt;

================
File: TestoSim/ViewModels/AIInsightsGenerator.swift
================
  1: import Foundation
  2: import SwiftUI
  3: /// Generates AI-powered insights for user&apos;s protocols and cycles
  4: class AIInsightsGenerator: ObservableObject {
  5:     // MARK: - Published Properties
  6:     /// Whether an insight request is currently in progress
  7:     @Published var isLoading = false
  8:     /// Latest generated insights
  9:     @Published var latestInsights: Insights?
 10:     /// Any error that occurred during the last insight generation
 11:     @Published var error: Error?
 12:     // MARK: - Private Properties
 13:     /// API Service for OpenAI
 14:     private let openAIService = OpenAIService.shared
 15:     /// Cache to store generated insights for each protocol
 16:     private var insightsCache: [UUID: Insights] = [:]
 17:     // MARK: - Initialization
 18:     init() {
 19:         // Initialization doesn&apos;t require anything specific
 20:     }
 21:     // MARK: - Public Methods
 22:     /// Generate insights for a specific protocol
 23:     /// - Parameters:
 24:     ///   - protocol: The protocol to analyze
 25:     ///   - profile: User profile data
 26:     ///   - simulationData: Simulation data points
 27:     ///   - compoundLibrary: Reference to compound library
 28:     ///   - forceRefresh: Whether to force a refresh instead of using cached insights
 29:     func generateInsights(
 30:         for treatmentProtocol: InjectionProtocol,
 31:         profile: UserProfile,
 32:         simulationData: [DataPoint],
 33:         compoundLibrary: CompoundLibrary,
 34:         forceRefresh: Bool = false
 35:     ) {
 36:         // Check cache first unless refresh is forced
 37:         if !forceRefresh, let cachedInsights = insightsCache[treatmentProtocol.id] {
 38:             self.latestInsights = cachedInsights
 39:             return
 40:         }
 41:         isLoading = true
 42:         error = nil
 43:         // Check if OpenAI API key is available
 44:         if openAIService.hasAPIKey() {
 45:             // Use OpenAI service for real insights
 46:             openAIService.generateProtocolInsights(
 47:                 treatmentProtocol: treatmentProtocol,
 48:                 profile: profile,
 49:                 simulationData: simulationData,
 50:                 compoundLibrary: compoundLibrary
 51:             ) { [weak self] result in
 52:                 DispatchQueue.main.async {
 53:                     guard let self = self else { return }
 54:                     self.isLoading = false
 55:                     switch result {
 56:                     case .success(let insights):
 57:                         // Cache the insights
 58:                         self.insightsCache[treatmentProtocol.id] = insights
 59:                         self.latestInsights = insights
 60:                     case .failure(let error):
 61:                         self.error = error
 62:                         // Fall back to mock insights if API call fails
 63:                         self.generateMockInsights(for: treatmentProtocol, profile: profile, simulationData: simulationData, compoundLibrary: compoundLibrary)
 64:                     }
 65:                 }
 66:             }
 67:         } else {
 68:             // Use mock implementation when API key is not available
 69:             generateMockInsights(for: treatmentProtocol, profile: profile, simulationData: simulationData, compoundLibrary: compoundLibrary)
 70:         }
 71:     }
 72:     /// Generate insights for a cycle
 73:     /// - Parameters:
 74:     ///   - cycle: The cycle to analyze
 75:     ///   - profile: User profile data
 76:     ///   - simulationData: Cycle simulation data points
 77:     ///   - compoundLibrary: Reference to compound library
 78:     ///   - forceRefresh: Whether to force a refresh instead of using cached insights
 79:     func generateCycleInsights(
 80:         for cycle: Cycle,
 81:         profile: UserProfile,
 82:         simulationData: [DataPoint],
 83:         compoundLibrary: CompoundLibrary,
 84:         forceRefresh: Bool = false
 85:     ) {
 86:         // Check cache first unless refresh is forced
 87:         if !forceRefresh, let cachedInsights = insightsCache[cycle.id] {
 88:             self.latestInsights = cachedInsights
 89:             return
 90:         }
 91:         isLoading = true
 92:         error = nil
 93:         // Check if OpenAI API key is available
 94:         if openAIService.hasAPIKey() {
 95:             // Use OpenAI service for real insights
 96:             openAIService.generateCycleInsights(
 97:                 cycle: cycle,
 98:                 profile: profile,
 99:                 simulationData: simulationData,
100:                 compoundLibrary: compoundLibrary
101:             ) { [weak self] result in
102:                 DispatchQueue.main.async {
103:                     guard let self = self else { return }
104:                     self.isLoading = false
105:                     switch result {
106:                     case .success(let insights):
107:                         // Cache the insights
108:                         self.insightsCache[cycle.id] = insights
109:                         self.latestInsights = insights
110:                     case .failure(let error):
111:                         self.error = error
112:                         // Fall back to mock insights if API call fails
113:                         self.generateMockCycleInsights(for: cycle, profile: profile, simulationData: simulationData, compoundLibrary: compoundLibrary)
114:                     }
115:                 }
116:             }
117:         } else {
118:             // Use mock implementation when API key is not available
119:             generateMockCycleInsights(for: cycle, profile: profile, simulationData: simulationData, compoundLibrary: compoundLibrary)
120:         }
121:     }
122:     /// Clear all cached insights
123:     func clearCache() {
124:         insightsCache.removeAll()
125:         latestInsights = nil
126:     }
127:     /// Refreshes insights after API key change
128:     func refreshAfterAPIKeyChange() {
129:         // Clear the cache to force a refresh on next request
130:         clearCache()
131:         // Reset any error state
132:         error = nil
133:         // Clear the latest insights to prompt a new request
134:         latestInsights = nil
135:     }
136:     // MARK: - Private Methods
137:     /// Mock implementation for generating insights
138:     private func generateMockInsights(
139:         for treatmentProtocol: InjectionProtocol,
140:         profile: UserProfile,
141:         simulationData: [DataPoint],
142:         compoundLibrary: CompoundLibrary
143:     ) {
144:         // Simulate network delay
145:         DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) { [weak self] in
146:             guard let self = self else { return }
147:             // Create mock insights based on protocol type
148:             let insights = self.createMockInsightsForProtocol(treatmentProtocol, profile: profile, simulationData: simulationData, compoundLibrary: compoundLibrary)
149:             // Cache the insights
150:             self.insightsCache[treatmentProtocol.id] = insights
151:             // Update published properties
152:             self.latestInsights = insights
153:             self.isLoading = false
154:         }
155:     }
156:     /// Mock implementation for generating cycle insights
157:     private func generateMockCycleInsights(
158:         for cycle: Cycle,
159:         profile: UserProfile,
160:         simulationData: [DataPoint],
161:         compoundLibrary: CompoundLibrary
162:     ) {
163:         // Simulate network delay
164:         DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) { [weak self] in
165:             guard let self = self else { return }
166:             // Create mock insights for the cycle
167:             let insights = self.createMockInsightsForCycle(cycle, profile: profile, simulationData: simulationData, compoundLibrary: compoundLibrary)
168:             // Cache the insights
169:             self.insightsCache[cycle.id] = insights
170:             // Update published properties
171:             self.latestInsights = insights
172:             self.isLoading = false
173:         }
174:     }
175:     /// Creates mock insights for a protocol
176:     private func createMockInsightsForProtocol(
177:         _ treatmentProtocol: InjectionProtocol,
178:         profile: UserProfile,
179:         simulationData: [DataPoint],
180:         compoundLibrary: CompoundLibrary
181:     ) -&gt; Insights {
182:         // Extract protocol details
183:         let protocolType = treatmentProtocol.protocolType
184:         let protocolName = treatmentProtocol.name
185:         var compoundOrBlendName = &quot;Unknown&quot;
186:         // Determine the compound or blend name
187:         if protocolType == .compound, let compoundID = treatmentProtocol.compoundID,
188:            let compound = compoundLibrary.compounds.first(where: { $0.id == compoundID }) {
189:             compoundOrBlendName = compound.commonName
190:             if let ester = compound.ester {
191:                 compoundOrBlendName += &quot; \(ester)&quot;
192:             }
193:         } else if protocolType == .blend, let blendID = treatmentProtocol.blendID,
194:                   let blend = compoundLibrary.blends.first(where: { $0.id == blendID }) {
195:             compoundOrBlendName = blend.name
196:         }
197:         // Get simulation statistics
198:         let maxLevel = simulationData.map { $0.level }.max() ?? 0
199:         let minLevel = simulationData.map { $0.level }.min() ?? 0
200:         let avgLevel = simulationData.map { $0.level }.reduce(0, +) / Double(max(1, simulationData.count))
201:         let fluctuation = maxLevel &gt; 0 ? (maxLevel - minLevel) / maxLevel * 100 : 0
202:         // Generate insights based on protocol characteristics
203:         var insights = Insights(
204:             title: &quot;Insights for \(protocolName)&quot;,
205:             summary: &quot;Analysis of your \(compoundOrBlendName) protocol.&quot;,
206:             keyPoints: []
207:         )
208:         // Add blend explanation if it&apos;s a blend
209:         if protocolType == .blend {
210:             insights.blendExplanation = createMockBlendExplanation(treatmentProtocol, compoundLibrary: compoundLibrary)
211:         }
212:         // Add key points based on protocol characteristics
213:         // 1. Frequency point
214:         if treatmentProtocol.frequencyDays &gt;= 7 {
215:             insights.keyPoints.append(
216:                 KeyPoint(
217:                     title: &quot;Consider splitting your dose&quot;,
218:                     description: &quot;Your current injection frequency of every \(treatmentProtocol.frequencyDays) days leads to significant hormone fluctuations. Consider splitting your total dose into smaller, more frequent injections to achieve more stable hormone levels.&quot;,
219:                     type: .suggestion
220:                 )
221:             )
222:         } else if treatmentProtocol.frequencyDays &lt;= 2 {
223:             insights.keyPoints.append(
224:                 KeyPoint(
225:                     title: &quot;Good injection frequency&quot;,
226:                     description: &quot;Your frequent injection schedule of every \(treatmentProtocol.frequencyDays) days helps maintain stable hormone levels with minimal fluctuations.&quot;,
227:                     type: .positive
228:                 )
229:             )
230:         }
231:         // 2. Fluctuation point
232:         if fluctuation &gt; 40 {
233:             insights.keyPoints.append(
234:                 KeyPoint(
235:                     title: &quot;High level fluctuation&quot;,
236:                     description: &quot;Your current protocol results in approximately \(fluctuation.isFinite ? Int(fluctuation) : 0)% fluctuation between peak and trough levels, which may lead to inconsistent symptoms and effects.&quot;,
237:                     type: .warning
238:                 )
239:             )
240:         } else if fluctuation &lt; 20 {
241:             insights.keyPoints.append(
242:                 KeyPoint(
243:                     title: &quot;Stable hormone levels&quot;,
244:                     description: &quot;Your protocol achieves excellent stability with only \(fluctuation.isFinite ? Int(fluctuation) : 0)% fluctuation between peak and trough levels.&quot;,
245:                     type: .positive
246:                 )
247:             )
248:         }
249:         // 3. Overall level point
250:         let targetMin = 400.0 // Example target minimum
251:         let targetMax = 1000.0 // Example target maximum
252:         if avgLevel &lt; targetMin {
253:             insights.keyPoints.append(
254:                 KeyPoint(
255:                     title: &quot;Levels below typical target range&quot;,
256:                     description: &quot;Your average level of \(avgLevel.isFinite ? Int(avgLevel) : 0) ng/dL is below the typical target range of \(targetMin.isFinite ? Int(targetMin) : 0)-\(targetMax.isFinite ? Int(targetMax) : 0) ng/dL. Consider discussing a dosage adjustment with your healthcare provider.&quot;,
257:                     type: .warning
258:                 )
259:             )
260:         } else if avgLevel &gt; targetMax {
261:             insights.keyPoints.append(
262:                 KeyPoint(
263:                     title: &quot;Levels above typical target range&quot;,
264:                     description: &quot;Your average level of \(avgLevel.isFinite ? Int(avgLevel) : 0) ng/dL is above the typical target range of \(targetMin.isFinite ? Int(targetMin) : 0)-\(targetMax.isFinite ? Int(targetMax) : 0) ng/dL. Consider discussing potential side effects and benefits with your healthcare provider.&quot;,
265:                     type: .warning
266:                 )
267:             )
268:         } else {
269:             insights.keyPoints.append(
270:                 KeyPoint(
271:                     title: &quot;Levels within typical target range&quot;,
272:                     description: &quot;Your average level of \(avgLevel.isFinite ? Int(avgLevel) : 0) ng/dL falls within the typical target range of \(targetMin.isFinite ? Int(targetMin) : 0)-\(targetMax.isFinite ? Int(targetMax) : 0) ng/dL.&quot;,
273:                     type: .positive
274:                 )
275:             )
276:         }
277:         return insights
278:     }
279:     /// Creates mock insights for a cycle
280:     private func createMockInsightsForCycle(
281:         _ cycle: Cycle,
282:         profile: UserProfile,
283:         simulationData: [DataPoint],
284:         compoundLibrary: CompoundLibrary
285:     ) -&gt; Insights {
286:         // Extract cycle details
287:         let cycleName = cycle.name
288:         let totalWeeks = cycle.totalWeeks
289:         let stageCount = cycle.stages.count
290:         // Generate summary of compounds and blends used in the cycle
291:         var compoundsUsed = Set&lt;String&gt;()
292:         var blendsUsed = Set&lt;String&gt;()
293:         for stage in cycle.stages {
294:             for compoundItem in stage.compounds {
295:                 if let compound = compoundLibrary.compounds.first(where: { $0.id == compoundItem.compoundID }) {
296:                     compoundsUsed.insert(compound.commonName)
297:                 }
298:             }
299:             for blendItem in stage.blends {
300:                 if let blend = compoundLibrary.blends.first(where: { $0.id == blendItem.blendID }) {
301:                     blendsUsed.insert(blend.name)
302:                 }
303:             }
304:         }
305:         // Get simulation statistics
306:         let maxLevel = simulationData.map { $0.level }.max() ?? 0
307:         let _ = simulationData.map { $0.level }.min() ?? 0
308:         let _ = simulationData.map { $0.level }.reduce(0, +) / Double(max(1, simulationData.count))
309:         // Generate insights for the cycle
310:         var insights = Insights(
311:             title: &quot;Cycle Analysis: \(cycleName)&quot;,
312:             summary: &quot;Analysis of your \(totalWeeks)-week cycle with \(stageCount) stages.&quot;,
313:             keyPoints: []
314:         )
315:         // 1. Cycle structure point
316:         insights.keyPoints.append(
317:             KeyPoint(
318:                 title: &quot;Cycle Structure&quot;,
319:                 description: &quot;Your cycle spans \(totalWeeks) weeks with \(stageCount) distinct stages, using \(compoundsUsed.count) compounds and \(blendsUsed.count) blends.&quot;,
320:                 type: .information
321:             )
322:         )
323:         // 2. Compound/blend usage point
324:         if !compoundsUsed.isEmpty || !blendsUsed.isEmpty {
325:             let compoundsList = compoundsUsed.joined(separator: &quot;, &quot;)
326:             let blendsList = blendsUsed.joined(separator: &quot;, &quot;)
327:             var description = &quot;This cycle utilizes &quot;
328:             if !compoundsUsed.isEmpty {
329:                 description += &quot;the following compounds: \(compoundsList)&quot;
330:             }
331:             if !compoundsUsed.isEmpty &amp;&amp; !blendsUsed.isEmpty {
332:                 description += &quot; and &quot;
333:             }
334:             if !blendsUsed.isEmpty {
335:                 description += &quot;the following blends: \(blendsList)&quot;
336:             }
337:             insights.keyPoints.append(
338:                 KeyPoint(
339:                     title: &quot;Compounds and Blends&quot;,
340:                     description: description,
341:                     type: .information
342:                 )
343:             )
344:         }
345:         // 3. Level analysis point
346:         let targetMax = 1000.0 // Example target maximum
347:         if maxLevel &gt; targetMax * 1.5 {
348:             insights.keyPoints.append(
349:                 KeyPoint(
350:                     title: &quot;Very high peak levels&quot;,
351:                     description: &quot;This cycle produces a maximum concentration of \(maxLevel.isFinite ? Int(maxLevel) : 0) ng/dL, which is significantly above the typical target range. Consider reducing dosages during peak periods.&quot;,
352:                     type: .warning
353:                 )
354:             )
355:         } else if maxLevel &gt; targetMax {
356:             insights.keyPoints.append(
357:                 KeyPoint(
358:                     title: &quot;Elevated peak levels&quot;,
359:                     description: &quot;This cycle produces a maximum concentration of \(maxLevel.isFinite ? Int(maxLevel) : 0) ng/dL, which is above the typical target maximum of \(targetMax.isFinite ? Int(targetMax) : 0) ng/dL.&quot;,
360:                     type: .warning
361:                 )
362:             )
363:         }
364:         // 4. Recovery suggestion if appropriate
365:         if totalWeeks &gt; 12 {
366:             insights.keyPoints.append(
367:                 KeyPoint(
368:                     title: &quot;Consider post-cycle recovery&quot;,
369:                     description: &quot;Your cycle duration of \(totalWeeks) weeks is relatively long. Consider implementing a proper post-cycle recovery protocol to help restore natural hormone production.&quot;,
370:                     type: .suggestion
371:                 )
372:             )
373:         }
374:         return insights
375:     }
376:     /// Creates a mock blend explanation
377:     private func createMockBlendExplanation(_ treatmentProtocol: InjectionProtocol, compoundLibrary: CompoundLibrary) -&gt; String? {
378:         guard treatmentProtocol.protocolType == .blend,
379:               let blendID = treatmentProtocol.blendID,
380:               let blend = compoundLibrary.blends.first(where: { $0.id == blendID }) else {
381:             return nil
382:         }
383:         // Get the components of the blend
384:         let components = blend.resolvedComponents(using: compoundLibrary)
385:         // Return nil if there are no components
386:         if components.isEmpty {
387:             return nil
388:         }
389:         // Create the explanation
390:         var explanation = &quot;\(blend.name) contains \(components.count) different compounds:\n\n&quot;
391:         // Sort components by half-life
392:         let sortedComponents = components.sorted { $0.compound.halfLifeDays &lt; $1.compound.halfLifeDays }
393:         // Add component descriptions
394:         for component in sortedComponents {
395:             let percentage = (component.mgPerML / blend.totalConcentration) * 100
396:             let halfLife = component.compound.halfLifeDays
397:             explanation += &quot;• \(component.compound.commonName)&quot;
398:             if let ester = component.compound.ester {
399:                 explanation += &quot; \(ester)&quot;
400:             }
401:             explanation += &quot; (\(component.mgPerML.isFinite ? Int(component.mgPerML) : 0) mg/ml, approx. \(percentage.isFinite ? Int(percentage) : 0)%) - &quot;
402:             // Describe the expected behavior
403:             if halfLife &lt; 1.0 {
404:                 explanation += &quot;Very fast-acting with a half-life of \(String(format: &quot;%.1f&quot;, halfLife)) days, providing an initial spike in hormone levels.\n&quot;
405:             } else if halfLife &lt; 3.0 {
406:                 explanation += &quot;Fast-acting with a half-life of \(String(format: &quot;%.1f&quot;, halfLife)) days, providing relatively quick effects.\n&quot;
407:             } else if halfLife &lt; 7.0 {
408:                 explanation += &quot;Medium-acting with a half-life of \(String(format: &quot;%.1f&quot;, halfLife)) days, providing balanced release.\n&quot;
409:             } else {
410:                 explanation += &quot;Long-acting with a half-life of \(String(format: &quot;%.1f&quot;, halfLife)) days, providing extended release of hormone levels.\n&quot;
411:             }
412:         }
413:         // Add overall blend characteristics
414:         let shortActingCount = sortedComponents.filter { $0.compound.halfLifeDays &lt; 3.0 }.count
415:         let longActingCount = sortedComponents.filter { $0.compound.halfLifeDays &gt;= 7.0 }.count
416:         explanation += &quot;\nOverall characteristics: &quot;
417:         if shortActingCount &gt; 0 &amp;&amp; longActingCount &gt; 0 {
418:             explanation += &quot;This blend is designed to provide both immediate effects (from the shorter-acting compounds) and sustained release (from the longer-acting compounds), creating a balanced hormone profile over time.&quot;
419:         } else if shortActingCount &gt; 0 {
420:             explanation += &quot;This blend is primarily designed for quick onset of action, with effects becoming noticeable rapidly after injection.&quot;
421:         } else if longActingCount &gt; 0 {
422:             explanation += &quot;This blend is designed for stable, long-term release with minimal fluctuations, requiring less frequent injections.&quot;
423:         } else {
424:             explanation += &quot;This blend provides a balanced release profile with moderate onset and duration of action.&quot;
425:         }
426:         return explanation
427:     }
428:     /// Real implementation would make an API call to OpenAI
429:     private func makeOpenAIAPICall(
430:         for treatmentProtocol: InjectionProtocol,
431:         profile: UserProfile,
432:         simulationData: [DataPoint],
433:         compoundLibrary: CompoundLibrary,
434:         completion: @escaping (Result&lt;Insights, Error&gt;) -&gt; Void
435:     ) {
436:         // This would be implemented with actual API calls in a production version
437:         // For now, this is just a placeholder
438:         // 1. Construct the request data
439:         // 2. Make API call to OpenAI
440:         // 3. Process the response
441:         // 4. Return the insights
442:     }
443: }
444: // MARK: - Insights Model
445: /// Represents AI-generated insights
446: struct Insights {
447:     /// Title of the insights
448:     var title: String
449:     /// Summary paragraph
450:     var summary: String
451:     /// Detailed explanation for blend protocols
452:     var blendExplanation: String?
453:     /// Key points of the insights
454:     var keyPoints: [KeyPoint]
455: }
456: /// Represents a key point in the insights
457: struct KeyPoint {
458:     /// Title of the key point
459:     var title: String
460:     /// Detailed description
461:     var description: String
462:     /// Type of key point
463:     var type: KeyPointType
464:     /// Type of key point
465:     enum KeyPointType {
466:         case information
467:         case positive
468:         case warning
469:         case suggestion
470:     }
471: }

================
File: TestoSim/ViewModels/CoreDataManager.swift
================
  1: import Foundation
  2: import CoreData
  3: import CloudKit
  4: class CoreDataManager {
  5:     static let shared = CoreDataManager()
  6:     // MARK: - Core Data stack
  7:     lazy var persistentContainer: NSPersistentContainer = {
  8:         // Set up the CloudKit container
  9:         let cloudKitContainerID = &quot;iCloud.flight505.TestoSim&quot;
 10:         // Check if iCloud sync is enabled via UserDefaults
 11:         let usesICloudSync = UserDefaults.standard.bool(forKey: &quot;usesICloudSync&quot;)
 12:         // Use NSPersistentCloudKitContainer if iCloud sync is enabled, otherwise use regular NSPersistentContainer
 13:         let container: NSPersistentContainer
 14:         if usesICloudSync {
 15:             container = NSPersistentCloudKitContainer(name: &quot;TestoSim&quot;)
 16:             print(&quot;Using CloudKit-enabled persistent container&quot;)
 17:             // Configure CloudKit integration
 18:             if let cloudStoreDescription = container.persistentStoreDescriptions.first {
 19:                 // Enable CloudKit
 20:                 cloudStoreDescription.cloudKitContainerOptions = NSPersistentCloudKitContainerOptions(containerIdentifier: cloudKitContainerID)
 21:                 // Enable history tracking (required for CloudKit sync)
 22:                 cloudStoreDescription.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)
 23:                 cloudStoreDescription.setOption(true as NSNumber, forKey: NSPersistentStoreRemoteChangeNotificationPostOptionKey)
 24:             }
 25:         } else {
 26:             container = NSPersistentContainer(name: &quot;TestoSim&quot;)
 27:             print(&quot;Using standard persistent container (CloudKit disabled)&quot;)
 28:         }
 29:         // Initialize the Core Data stack
 30:         container.loadPersistentStores(completionHandler: { (storeDescription, error) in
 31:             if let error = error as NSError? {
 32:                 // Replace this implementation with code to handle the error appropriately.
 33:                 print(&quot;Unresolved error loading persistent stores: \(error), \(error.userInfo)&quot;)
 34:                 // Log CloudKit specific issues if present
 35:                 if let cloudError = error.userInfo[NSUnderlyingErrorKey] as? NSError,
 36:                    cloudError.domain == CKErrorDomain {
 37:                     print(&quot;CloudKit error: \(cloudError.localizedDescription)&quot;)
 38:                 }
 39:             } else {
 40:                 print(&quot;Successfully loaded persistent store: \(storeDescription)&quot;)
 41:                 // Initialize CloudKit schema if CloudKit is enabled
 42:                 if let cloudKitOptions = storeDescription.cloudKitContainerOptions,
 43:                    let cloudKitContainer = container as? NSPersistentCloudKitContainer {
 44:                     do {
 45:                         try cloudKitContainer.initializeCloudKitSchema(options: [.printSchema])
 46:                         print(&quot;CloudKit schema initialized successfully&quot;)
 47:                     } catch {
 48:                         print(&quot;Error initializing CloudKit schema: \(error)&quot;)
 49:                     }
 50:                 }
 51:             }
 52:         })
 53:         // Enable automatic merging of changes from the parent context
 54:         container.viewContext.automaticallyMergesChangesFromParent = true
 55:         container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
 56:         return container
 57:     }()
 58:     // MARK: - Core Data operations
 59:     func saveContext() {
 60:         let context = persistentContainer.viewContext
 61:         if context.hasChanges {
 62:             do {
 63:                 try context.save()
 64:                 print(&quot;Context saved successfully&quot;)
 65:             } catch {
 66:                 let nserror = error as NSError
 67:                 print(&quot;Unresolved error saving context: \(nserror), \(nserror.userInfo)&quot;)
 68:             }
 69:         }
 70:     }
 71:     // MARK: - Background task
 72:     func performBackgroundTask(_ block: @escaping (NSManagedObjectContext) -&gt; Void) {
 73:         persistentContainer.performBackgroundTask(block)
 74:     }
 75:     // MARK: - iCloud Sync Control
 76:     func enableCloudSync(_ enable: Bool) {
 77:         let currentSetting = UserDefaults.standard.bool(forKey: &quot;usesICloudSync&quot;)
 78:         // Only update if the setting has changed
 79:         if currentSetting != enable {
 80:             UserDefaults.standard.set(enable, forKey: &quot;usesICloudSync&quot;)
 81:             // Notify the user that a restart is required
 82:             let notification = Notification(name: Notification.Name(&quot;CloudKitSyncSettingChanged&quot;), 
 83:                                            object: nil, 
 84:                                            userInfo: [&quot;enabled&quot;: enable])
 85:             NotificationCenter.default.post(notification)
 86:             print(&quot;CloudKit sync \(enable ? &quot;enabled&quot; : &quot;disabled&quot;) - app restart required for changes to take effect&quot;)
 87:         }
 88:     }
 89:     func isCloudSyncEnabled() -&gt; Bool {
 90:         return UserDefaults.standard.bool(forKey: &quot;usesICloudSync&quot;)
 91:     }
 92:     // MARK: - Migration
 93:     func migrateUserProfileFromJSON() {
 94:         // Check if we&apos;ve already migrated
 95:         if UserDefaults.standard.bool(forKey: &quot;migrated&quot;) {
 96:             return
 97:         }
 98:         // Get the profile data from UserDefaults
 99:         guard let profileData = UserDefaults.standard.data(forKey: &quot;userProfileData&quot;) else {
100:             // No data to migrate
101:             UserDefaults.standard.set(true, forKey: &quot;migrated&quot;)
102:             return
103:         }
104:         let decoder = JSONDecoder()
105:         do {
106:             // Decode the JSON data into our model struct
107:             let profile = try decoder.decode(UserProfile.self, from: profileData)
108:             // Create Core Data versions of the entities
109:             let context = persistentContainer.viewContext
110:             // Create CDUserProfile
111:             let cdProfile = CDUserProfile(context: context)
112:             cdProfile.id = profile.id
113:             cdProfile.name = profile.name
114:             cdProfile.unit = profile.unit
115:             cdProfile.calibrationFactor = profile.calibrationFactor
116:             cdProfile.dateOfBirth = profile.dateOfBirth
117:             cdProfile.heightCm = profile.heightCm ?? 0
118:             cdProfile.weight = profile.weight ?? 0
119:             cdProfile.biologicalSex = profile.biologicalSex.rawValue
120:             cdProfile.usesICloudSync = profile.usesICloudSync
121:             // Create CDInjectionProtocol entries
122:             for p in profile.protocols {
123:                 let cdProtocol = CDInjectionProtocol(context: context)
124:                 cdProtocol.id = p.id
125:                 cdProtocol.name = p.name
126:                 cdProtocol.doseMg = p.doseMg
127:                 cdProtocol.frequencyDays = p.frequencyDays
128:                 cdProtocol.startDate = p.startDate
129:                 cdProtocol.notes = p.notes
130:                 // TODO: The Core Data model needs to be updated to include these properties:
131:                 // - compoundID (UUID)
132:                 // - blendID (UUID)
133:                 // - selectedRoute (String)
134:                 // Once added, uncomment the following lines:
135:                 /*
136:                 cdProtocol.compoundID = p.compoundID
137:                 cdProtocol.blendID = p.blendID
138:                 cdProtocol.selectedRoute = p.selectedRoute
139:                 */
140:                 // For now, store this information in the notes field
141:                 var extendedInfo = &quot;&quot;
142:                 if let compoundID = p.compoundID {
143:                     extendedInfo += &quot;CompoundID: \(compoundID.uuidString)\n&quot;
144:                 }
145:                 if let blendID = p.blendID {
146:                     extendedInfo += &quot;BlendID: \(blendID.uuidString)\n&quot;
147:                 }
148:                 if let route = p.selectedRoute {
149:                     extendedInfo += &quot;Route: \(route)\n&quot;
150:                 }
151:                 if !extendedInfo.isEmpty {
152:                     if cdProtocol.notes != nil {
153:                         cdProtocol.notes = cdProtocol.notes! + &quot;\n\n---EXTENDED_DATA---\n&quot; + extendedInfo
154:                     } else {
155:                         cdProtocol.notes = &quot;---EXTENDED_DATA---\n&quot; + extendedInfo
156:                     }
157:                 }
158:                 // Create blood samples
159:                 for sample in p.bloodSamples {
160:                     let cdSample = CDBloodSample(context: context)
161:                     cdSample.id = sample.id
162:                     cdSample.date = sample.date
163:                     cdSample.value = sample.value
164:                     cdSample.unit = sample.unit
165:                     cdProtocol.addToBloodSamples(cdSample)
166:                 }
167:                 cdProfile.addToProtocols(cdProtocol)
168:             }
169:             // Save to Core Data
170:             try context.save()
171:             // Mark as migrated
172:             UserDefaults.standard.set(true, forKey: &quot;migrated&quot;)
173:             print(&quot;Successfully migrated user profile from JSON to Core Data&quot;)
174:         } catch {
175:             print(&quot;Error migrating from JSON: \(error)&quot;)
176:         }
177:     }
178: }

================
File: TestoSim/Views/AIInsightsView.swift
================
  1: import SwiftUI
  2: /// View for displaying AI-generated insights
  3: struct AIInsightsView: View {
  4:     @EnvironmentObject var dataStore: AppDataStore
  5:     @StateObject private var insightsGenerator = AIInsightsGenerator()
  6:     @ObservedObject private var openAIService = OpenAIService.shared
  7:     var protocolID: UUID?
  8:     var cycleID: UUID?
  9:     @State private var isLoading = false
 10:     @State private var expandedPoints: Set&lt;String&gt; = []
 11:     @State private var showSettings = false
 12:     @State private var errorMessage: String?
 13:     var body: some View {
 14:         ScrollView {
 15:             VStack(alignment: .leading, spacing: 16) {
 16:                 // Test API key indicator
 17:                 if openAIService.isUsingTestKey {
 18:                     testKeyIndicator
 19:                 }
 20:                 // API key warning if no key is set
 21:                 if !OpenAIService.shared.hasAPIKey() {
 22:                     noApiKeyView
 23:                 }
 24:                 // Error message if present
 25:                 if let message = errorMessage {
 26:                     errorView(message)
 27:                 }
 28:                 if isLoading {
 29:                     loadingView
 30:                 } else if let insights = insightsGenerator.latestInsights {
 31:                     insightsContent(insights)
 32:                 } else {
 33:                     noInsightsView
 34:                 }
 35:             }
 36:             .padding()
 37:         }
 38:         .navigationTitle(&quot;AI Insights&quot;)
 39:         .toolbar {
 40:             ToolbarItem(placement: .primaryAction) {
 41:                 Button {
 42:                     generateInsights(forceRefresh: true)
 43:                 } label: {
 44:                     Label(&quot;Refresh&quot;, systemImage: &quot;arrow.clockwise&quot;)
 45:                 }
 46:                 .disabled(isLoading)
 47:             }
 48:             ToolbarItem(placement: .topBarTrailing) {
 49:                 Button {
 50:                     showSettings = true
 51:                 } label: {
 52:                     Label(&quot;Settings&quot;, systemImage: &quot;gear&quot;)
 53:                 }
 54:             }
 55:         }
 56:         .onAppear {
 57:             generateInsights()
 58:             // Set up error handling monitoring
 59:             updateErrorMessage()
 60:         }
 61:         .sheet(isPresented: $showSettings) {
 62:             AISettingsView(insightsGenerator: insightsGenerator)
 63:         }
 64:         // Use a task to monitor error state changes instead of onChange
 65:         .task {
 66:             for await _ in insightsGenerator.$error.values {
 67:                 updateErrorMessage()
 68:             }
 69:         }
 70:     }
 71:     // MARK: - Private Views
 72:     private var testKeyIndicator: some View {
 73:         HStack {
 74:             Image(systemName: &quot;checkmark.seal.fill&quot;)
 75:                 .foregroundColor(.green)
 76:             Text(&quot;Using Test API Key&quot;)
 77:                 .font(.caption)
 78:                 .foregroundColor(.green)
 79:             Spacer()
 80:         }
 81:         .padding(.horizontal, 10)
 82:         .padding(.vertical, 5)
 83:         .background(Color.green.opacity(0.1))
 84:         .cornerRadius(5)
 85:     }
 86:     private var noApiKeyView: some View {
 87:         VStack(alignment: .leading, spacing: 10) {
 88:             HStack {
 89:                 Image(systemName: &quot;key.slash&quot;)
 90:                     .foregroundColor(.yellow)
 91:                 Text(&quot;OpenAI API Key Required&quot;)
 92:                     .font(.headline)
 93:                     .foregroundColor(.yellow)
 94:             }
 95:             Text(&quot;To use AI-powered insights, you need to set up your OpenAI API key in settings.&quot;)
 96:                 .font(.subheadline)
 97:             Button(&quot;Set API Key&quot;) {
 98:                 showSettings = true
 99:             }
100:             .buttonStyle(.borderedProminent)
101:             .padding(.top, 4)
102:         }
103:         .padding()
104:         .background(Color.yellow.opacity(0.1))
105:         .cornerRadius(10)
106:     }
107:     private func errorView(_ message: String) -&gt; some View {
108:         VStack(alignment: .leading, spacing: 10) {
109:             HStack {
110:                 Image(systemName: &quot;exclamationmark.triangle&quot;)
111:                     .foregroundColor(.red)
112:                 Text(&quot;Error&quot;)
113:                     .font(.headline)
114:                     .foregroundColor(.red)
115:             }
116:             Text(message)
117:                 .font(.subheadline)
118:             Button(&quot;Try Again&quot;) {
119:                 errorMessage = nil
120:                 generateInsights(forceRefresh: true)
121:             }
122:             .buttonStyle(.borderedProminent)
123:             .padding(.top, 4)
124:         }
125:         .padding()
126:         .background(Color.red.opacity(0.1))
127:         .cornerRadius(10)
128:     }
129:     private var loadingView: some View {
130:         VStack(spacing: 20) {
131:             ProgressView()
132:                 .scaleEffect(1.5)
133:             Text(&quot;Analyzing data and generating insights...&quot;)
134:                 .font(.headline)
135:             Text(&quot;This may take a moment&quot;)
136:                 .foregroundColor(.secondary)
137:         }
138:         .frame(maxWidth: .infinity, minHeight: 300)
139:     }
140:     private var noInsightsView: some View {
141:         VStack(spacing: 20) {
142:             Image(systemName: &quot;lightbulb&quot;)
143:                 .font(.system(size: 40))
144:                 .foregroundColor(.orange)
145:             if dataStore.selectedProtocolID == nil &amp;&amp; dataStore.selectedCycleID == nil {
146:                 Text(&quot;No protocol or cycle selected&quot;)
147:                     .font(.headline)
148:                 Text(&quot;Select a protocol or cycle from the Protocols or Cycles tab to generate insights.&quot;)
149:                     .multilineTextAlignment(.center)
150:                     .foregroundColor(.secondary)
151:             } else {
152:                 Text(&quot;No insights available&quot;)
153:                     .font(.headline)
154:                 Text(&quot;Tap the refresh button to generate insights based on your current protocol or cycle data.&quot;)
155:                     .multilineTextAlignment(.center)
156:                     .foregroundColor(.secondary)
157:             }
158:             Button(&quot;Generate Insights&quot;) {
159:                 generateInsights(forceRefresh: true)
160:             }
161:             .buttonStyle(.borderedProminent)
162:             .padding(.top)
163:         }
164:         .frame(maxWidth: .infinity, minHeight: 300)
165:         .padding()
166:     }
167:     private func insightsContent(_ insights: Insights) -&gt; some View {
168:         VStack(alignment: .leading, spacing: 16) {
169:             // Title
170:             Text(insights.title)
171:                 .font(.title)
172:                 .fontWeight(.bold)
173:             // Summary
174:             Text(insights.summary)
175:                 .font(.headline)
176:                 .padding(.bottom, 8)
177:             // Disclaimer
178:             Text(&quot;Note: These insights are generated by AI and should not replace medical advice.&quot;)
179:                 .font(.caption)
180:                 .foregroundColor(.secondary)
181:                 .padding(.bottom, 8)
182:             // Blend explanation if available
183:             if let blendExplanation = insights.blendExplanation {
184:                 blendExplanationView(blendExplanation)
185:             }
186:             // Key points
187:             if !insights.keyPoints.isEmpty {
188:                 Text(&quot;Key Points&quot;)
189:                     .font(.title2)
190:                     .fontWeight(.bold)
191:                     .padding(.top, 8)
192:                 ForEach(insights.keyPoints, id: \.title) { point in
193:                     keyPointView(point)
194:                 }
195:             }
196:         }
197:     }
198:     private func blendExplanationView(_ explanation: String) -&gt; some View {
199:         VStack(alignment: .leading, spacing: 10) {
200:             Text(&quot;Blend Analysis&quot;)
201:                 .font(.title2)
202:                 .fontWeight(.bold)
203:             Text(explanation)
204:                 .font(.body)
205:                 .lineSpacing(4)
206:         }
207:         .padding()
208:         .background(Color.blue.opacity(0.1))
209:         .cornerRadius(10)
210:     }
211:     private func keyPointView(_ point: KeyPoint) -&gt; some View {
212:         let pointId = point.title
213:         let isExpanded = expandedPoints.contains(pointId)
214:         return VStack(alignment: .leading, spacing: 8) {
215:             // Header row with icon, title, and expand/collapse button
216:             HStack {
217:                 iconForKeyPoint(point.type)
218:                     .font(.headline)
219:                     .foregroundColor(colorForKeyPoint(point.type))
220:                     .frame(width: 24, height: 24)
221:                 Text(point.title)
222:                     .font(.headline)
223:                     .foregroundColor(colorForKeyPoint(point.type))
224:                 Spacer()
225:                 Button {
226:                     withAnimation {
227:                         if isExpanded {
228:                             expandedPoints.remove(pointId)
229:                         } else {
230:                             expandedPoints.insert(pointId)
231:                         }
232:                     }
233:                 } label: {
234:                     Image(systemName: isExpanded ? &quot;chevron.up&quot; : &quot;chevron.down&quot;)
235:                         .foregroundColor(.secondary)
236:                 }
237:             }
238:             // Description (visible when expanded)
239:             if isExpanded {
240:                 Text(point.description)
241:                     .font(.body)
242:                     .foregroundColor(.primary)
243:                     .padding(.leading, 32)
244:                     .padding(.top, 4)
245:             }
246:         }
247:         .padding()
248:         .background(backgroundForKeyPoint(point.type).opacity(0.1))
249:         .cornerRadius(10)
250:         .contentShape(Rectangle()) // Make the entire row tappable
251:         .onTapGesture {
252:             withAnimation {
253:                 if isExpanded {
254:                     expandedPoints.remove(pointId)
255:                 } else {
256:                     expandedPoints.insert(pointId)
257:                 }
258:             }
259:         }
260:     }
261:     // MARK: - Helper Methods
262:     private func generateInsights(forceRefresh: Bool = false) {
263:         self.isLoading = true
264:         if let protocolID = protocolID, let treatmentProtocol = dataStore.profile.protocols.first(where: { $0.id == protocolID }) {
265:             // Generate insights for a specific protocol
266:             insightsGenerator.generateInsights(
267:                 for: treatmentProtocol,
268:                 profile: dataStore.profile,
269:                 simulationData: dataStore.simulationData,
270:                 compoundLibrary: dataStore.compoundLibrary,
271:                 forceRefresh: forceRefresh
272:             )
273:         } else if let cycleID = cycleID, let cycle = dataStore.cycles.first(where: { $0.id == cycleID }) {
274:             // Generate insights for a specific cycle
275:             insightsGenerator.generateCycleInsights(
276:                 for: cycle,
277:                 profile: dataStore.profile,
278:                 simulationData: dataStore.cycleSimulationData,
279:                 compoundLibrary: dataStore.compoundLibrary,
280:                 forceRefresh: forceRefresh
281:             )
282:         } else if let selectedProtocolID = dataStore.selectedProtocolID,
283:                   let selectedProtocol = dataStore.profile.protocols.first(where: { $0.id == selectedProtocolID }) {
284:             // Use the selected protocol as fallback
285:             insightsGenerator.generateInsights(
286:                 for: selectedProtocol,
287:                 profile: dataStore.profile,
288:                 simulationData: dataStore.simulationData,
289:                 compoundLibrary: dataStore.compoundLibrary,
290:                 forceRefresh: forceRefresh
291:             )
292:         } else if let selectedCycleID = dataStore.selectedCycleID,
293:                   let selectedCycle = dataStore.cycles.first(where: { $0.id == selectedCycleID }) {
294:             // Use the selected cycle as fallback
295:             insightsGenerator.generateCycleInsights(
296:                 for: selectedCycle,
297:                 profile: dataStore.profile,
298:                 simulationData: dataStore.cycleSimulationData,
299:                 compoundLibrary: dataStore.compoundLibrary,
300:                 forceRefresh: forceRefresh
301:             )
302:         } else {
303:             // If no protocol or cycle is found, show no insights available
304:             self.isLoading = false
305:             return
306:         }
307:         // Update loading state based on the generator&apos;s state
308:         DispatchQueue.main.async {
309:             self.isLoading = self.insightsGenerator.isLoading
310:         }
311:     }
312:     private func iconForKeyPoint(_ type: KeyPoint.KeyPointType) -&gt; some View {
313:         switch type {
314:         case .information:
315:             return Image(systemName: &quot;info.circle.fill&quot;)
316:         case .positive:
317:             return Image(systemName: &quot;checkmark.circle.fill&quot;)
318:         case .warning:
319:             return Image(systemName: &quot;exclamationmark.triangle.fill&quot;)
320:         case .suggestion:
321:             return Image(systemName: &quot;lightbulb.fill&quot;)
322:         }
323:     }
324:     private func colorForKeyPoint(_ type: KeyPoint.KeyPointType) -&gt; Color {
325:         switch type {
326:         case .information:
327:             return .blue
328:         case .positive:
329:             return .green
330:         case .warning:
331:             return .orange
332:         case .suggestion:
333:             return .purple
334:         }
335:     }
336:     private func backgroundForKeyPoint(_ type: KeyPoint.KeyPointType) -&gt; Color {
337:         switch type {
338:         case .information:
339:             return .blue
340:         case .positive:
341:             return .green
342:         case .warning:
343:             return .orange
344:         case .suggestion:
345:             return .purple
346:         }
347:     }
348:     private func updateErrorMessage() {
349:         if let error = insightsGenerator.error {
350:             errorMessage = error.localizedDescription
351:         } else {
352:             errorMessage = nil
353:         }
354:     }
355: }
356: // MARK: - AISettingsView
357: /// View for managing AI settings, including API key
358: struct AISettingsView: View {
359:     @Environment(\.dismiss) private var dismiss
360:     @State private var apiKey: String = UserDefaults.standard.string(forKey: &quot;openai_api_key&quot;) ?? &quot;&quot;
361:     @State private var showingSuccessMessage = false
362:     @State private var useTestKey: Bool = UserDefaults.standard.bool(forKey: &quot;use_test_api_key&quot;)
363:     @EnvironmentObject var dataStore: AppDataStore
364:     // Reference to the shared insights generator
365:     private let insightsGenerator: AIInsightsGenerator
366:     init(insightsGenerator: AIInsightsGenerator = AIInsightsGenerator()) {
367:         self.insightsGenerator = insightsGenerator
368:     }
369:     var body: some View {
370:         NavigationStack {
371:             Form {
372:                 Section(header: Text(&quot;API Key Options&quot;)) {
373:                     Toggle(&quot;Use Free Test API Key&quot;, isOn: $useTestKey)
374:                         .onChange(of: useTestKey) { oldValue, newValue in
375:                             OpenAIService.shared.toggleTestApiKey(newValue)
376:                             insightsGenerator.refreshAfterAPIKeyChange()
377:                         }
378:                     if useTestKey {
379:                         Text(&quot;Using the free test API key with a $20 spending limit for all test users.&quot;)
380:                             .font(.caption)
381:                             .foregroundColor(.green)
382:                     } else {
383:                         Text(&quot;Using your personal API key.&quot;)
384:                             .font(.caption)
385:                             .foregroundColor(.secondary)
386:                     }
387:                 }
388:                 if !useTestKey {
389:                     Section(header: Text(&quot;Personal OpenAI API Key&quot;)) {
390:                         SecureField(&quot;Enter API Key&quot;, text: $apiKey)
391:                             .autocorrectionDisabled()
392:                             .textInputAutocapitalization(.never)
393:                         Text(&quot;Your API key is stored securely in your device&apos;s UserDefaults and is never shared.&quot;)
394:                             .font(.caption)
395:                             .foregroundColor(.secondary)
396:                     }
397:                     Section {
398:                         Button(&quot;Save API Key&quot;) {
399:                             OpenAIService.shared.saveAPIKey(apiKey)
400:                             insightsGenerator.refreshAfterAPIKeyChange()
401:                             showingSuccessMessage = true
402:                         }
403:                         .disabled(apiKey.isEmpty)
404:                         if !apiKey.isEmpty {
405:                             Button(&quot;Clear API Key&quot;) {
406:                                 apiKey = &quot;&quot;
407:                                 OpenAIService.shared.clearAPIKey()
408:                                 insightsGenerator.refreshAfterAPIKeyChange()
409:                                 showingSuccessMessage = true
410:                             }
411:                             .foregroundColor(.red)
412:                         }
413:                     }
414:                 }
415:                 Section(header: Text(&quot;About AI Insights&quot;)) {
416:                     VStack(alignment: .leading, spacing: 8) {
417:                         Text(&quot;How it works&quot;)
418:                             .font(.headline)
419:                         Text(&quot;The AI Insights feature uses OpenAI&apos;s API to analyze your hormone protocols and cycles. It provides personalized feedback, optimization suggestions, and educational content based on your specific therapy details.&quot;)
420:                             .font(.caption)
421:                             .foregroundColor(.secondary)
422:                     }
423:                     .padding(.vertical, 8)
424:                     VStack(alignment: .leading, spacing: 8) {
425:                         Text(&quot;Privacy&quot;)
426:                             .font(.headline)
427:                         Text(&quot;Only anonymized therapy data is sent to OpenAI for analysis. No personally identifiable information is shared. All API calls are made directly from your device.&quot;)
428:                             .font(.caption)
429:                             .foregroundColor(.secondary)
430:                     }
431:                     .padding(.vertical, 8)
432:                     VStack(alignment: .leading, spacing: 8) {
433:                         Text(&quot;Test API Key&quot;)
434:                             .font(.headline)
435:                         Text(&quot;A free test API key is provided for evaluation purposes with a $20 spending limit across all users. For continued use after testing, we recommend using your own API key.&quot;)
436:                             .font(.caption)
437:                             .foregroundColor(.secondary)
438:                     }
439:                     .padding(.vertical, 8)
440:                 }
441:             }
442:             .navigationTitle(&quot;AI Settings&quot;)
443:             .navigationBarTitleDisplayMode(.inline)
444:             .toolbar {
445:                 ToolbarItem(placement: .confirmationAction) {
446:                     Button(&quot;Done&quot;) {
447:                         dismiss()
448:                     }
449:                 }
450:             }
451:             .alert(&quot;Settings Saved&quot;, isPresented: $showingSuccessMessage) {
452:                 Button(&quot;OK&quot;) { }
453:             } message: {
454:                 Text(apiKey.isEmpty ? 
455:                      &quot;API key has been cleared. The app will use mock data for insights.&quot; : 
456:                      &quot;API key has been saved. The app will now use OpenAI for generating insights.&quot;)
457:             }
458:         }
459:     }
460: }
461: #Preview {
462:     NavigationStack {
463:         AIInsightsView()
464:             .environmentObject(AppDataStore())
465:     }
466: }

================
File: TestoSim/Views/CyclePlannerView.swift
================
  1: import SwiftUI
  2: import Charts
  3: struct CyclePlannerView: View {
  4:     @EnvironmentObject var dataStore: AppDataStore
  5:     @State private var isPresentingNewCycleForm = false
  6:     @State private var isPresentingStageForm = false
  7:     @State private var selectedCycle: Cycle?
  8:     @State private var selectedStageID: UUID?
  9:     @State private var zoomLevel: Double = 1.0
 10:     @State private var weekViewWidth: CGFloat = 70
 11:     var body: some View {
 12:         VStack {
 13:             if dataStore.cycles.isEmpty {
 14:                 emptyCyclesView
 15:             } else {
 16:                 cycleListView
 17:             }
 18:         }
 19:         .navigationTitle(&quot;Cycle Planner&quot;)
 20:         .toolbar {
 21:             ToolbarItem(placement: .primaryAction) {
 22:                 Button(action: {
 23:                     isPresentingNewCycleForm = true
 24:                 }) {
 25:                     Label(&quot;Add Cycle&quot;, systemImage: &quot;plus&quot;)
 26:                 }
 27:             }
 28:         }
 29:         .sheet(isPresented: $isPresentingNewCycleForm) {
 30:             CycleFormView(isPresented: $isPresentingNewCycleForm)
 31:         }
 32:         .sheet(item: $selectedCycle) { cycle in
 33:             CycleDetailView(cycle: cycle)
 34:         }
 35:     }
 36:     private var emptyCyclesView: some View {
 37:         VStack(spacing: 16) {
 38:             Image(systemName: &quot;calendar.badge.plus&quot;)
 39:                 .font(.system(size: 60))
 40:                 .foregroundColor(.secondary)
 41:             Text(&quot;No Cycles Yet&quot;)
 42:                 .font(.title2)
 43:                 .bold()
 44:             Text(&quot;Create your first cycle to plan and visualize multi-compound treatments.&quot;)
 45:                 .font(.body)
 46:                 .multilineTextAlignment(.center)
 47:                 .padding(.horizontal)
 48:                 .foregroundColor(.secondary)
 49:             Button(action: {
 50:                 isPresentingNewCycleForm = true
 51:             }) {
 52:                 Text(&quot;Create Cycle&quot;)
 53:                     .font(.headline)
 54:                     .padding()
 55:                     .background(Color.accentColor)
 56:                     .foregroundColor(.white)
 57:                     .cornerRadius(10)
 58:             }
 59:             .padding()
 60:         }
 61:         .padding()
 62:     }
 63:     private var cycleListView: some View {
 64:         List {
 65:             cycleListSection
 66:             simulationResultsSection
 67:         }
 68:     }
 69:     private var cycleListSection: some View {
 70:         Section(header: Text(&quot;My Cycles&quot;)) {
 71:             cycleRows
 72:         }
 73:     }
 74:     private var cycleRows: some View {
 75:         ForEach(dataStore.cycles) { cycle in
 76:             cycleRow(for: cycle)
 77:         }
 78:         .onDelete(perform: handleDelete)
 79:     }
 80:     private func cycleRow(for cycle: Cycle) -&gt; some View {
 81:         CycleRowView(cycle: cycle)
 82:             .contentShape(Rectangle())
 83:             .onTapGesture {
 84:                 dataStore.selectedCycleID = cycle.id
 85:                 if dataStore.isCycleSimulationActive == false {
 86:                     dataStore.simulateCycle(id: cycle.id)
 87:                 }
 88:                 selectedCycle = cycle
 89:             }
 90:             .background(
 91:                 RoundedRectangle(cornerRadius: 8)
 92:                     .fill(dataStore.selectedCycleID == cycle.id ? Color.accentColor.opacity(0.1) : Color.clear)
 93:             )
 94:     }
 95:     private func handleDelete(at indexSet: IndexSet) {
 96:         for index in indexSet {
 97:             if index &lt; dataStore.cycles.count {
 98:                 dataStore.deleteCycle(with: dataStore.cycles[index].id)
 99:             }
100:         }
101:     }
102:     private var simulationResultsSection: some View {
103:         Group {
104:             if dataStore.isCycleSimulationActive, !dataStore.cycleSimulationData.isEmpty {
105:                 Section(header: Text(&quot;Simulation Results&quot;)) {
106:                     VStack(alignment: .leading) {
107:                         Text(&quot;Combined Concentration Curve&quot;)
108:                             .font(.headline)
109:                             .padding(.bottom, 5)
110:                         CycleChartView(simulationData: dataStore.cycleSimulationData)
111:                             .frame(height: 200)
112:                     }
113:                     .padding(.vertical)
114:                 }
115:             }
116:         }
117:     }
118: }
119: struct CycleRowView: View {
120:     let cycle: Cycle
121:     var body: some View {
122:         VStack(alignment: .leading, spacing: 8) {
123:             Text(cycle.name)
124:                 .font(.headline)
125:             HStack {
126:                 Text(&quot;Start: \(formatDate(cycle.startDate))&quot;)
127:                 Spacer()
128:                 Text(&quot;\(cycle.totalWeeks) weeks&quot;)
129:             }
130:             .font(.subheadline)
131:             .foregroundColor(.secondary)
132:             Text(&quot;\(cycle.stages.count) stages&quot;)
133:                 .font(.caption)
134:                 .foregroundColor(.secondary)
135:         }
136:         .padding(.vertical, 4)
137:     }
138:     private func formatDate(_ date: Date) -&gt; String {
139:         let formatter = DateFormatter()
140:         formatter.dateStyle = .medium
141:         formatter.timeStyle = .none
142:         return formatter.string(from: date)
143:     }
144: }
145: struct CycleChartView: View {
146:     let simulationData: [DataPoint]
147:     var body: some View {
148:         Chart {
149:             ForEach(simulationData, id: \.time) { dataPoint in
150:                 LineMark(
151:                     x: .value(&quot;Date&quot;, dataPoint.time),
152:                     y: .value(&quot;Level&quot;, dataPoint.level)
153:                 )
154:                 .interpolationMethod(.catmullRom)
155:                 .foregroundStyle(Color.blue.gradient)
156:             }
157:         }
158:         .chartXAxis {
159:             AxisMarks(values: .stride(by: .day, count: 7)) { _ in
160:                 AxisGridLine()
161:                 AxisTick()
162:                 AxisValueLabel(format: .dateTime.day().month())
163:             }
164:         }
165:         .chartYAxis {
166:             AxisMarks(position: .leading)
167:         }
168:     }
169: }
170: // Placeholder for Cycle Form View - to be implemented
171: struct CycleFormView: View {
172:     @EnvironmentObject var dataStore: AppDataStore
173:     @Binding var isPresented: Bool
174:     @State private var cycleName: String = &quot;&quot;
175:     @State private var startDate: Date = Date()
176:     @State private var totalWeeks: Int = 12
177:     @State private var notes: String = &quot;&quot;
178:     var body: some View {
179:         NavigationView {
180:             Form {
181:                 Section(header: Text(&quot;Cycle Details&quot;)) {
182:                     TextField(&quot;Cycle Name&quot;, text: $cycleName)
183:                     DatePicker(&quot;Start Date&quot;, selection: $startDate, displayedComponents: .date)
184:                     Stepper(&quot;Duration: \(totalWeeks) weeks&quot;, value: $totalWeeks, in: 1...52)
185:                     VStack(alignment: .leading) {
186:                         Text(&quot;Notes&quot;)
187:                         TextEditor(text: $notes)
188:                             .frame(minHeight: 100)
189:                     }
190:                 }
191:             }
192:             .navigationTitle(&quot;New Cycle&quot;)
193:             .toolbar {
194:                 ToolbarItem(placement: .cancellationAction) {
195:                     Button(&quot;Cancel&quot;) {
196:                         isPresented = false
197:                     }
198:                 }
199:                 ToolbarItem(placement: .confirmationAction) {
200:                     Button(&quot;Save&quot;) {
201:                         saveCycle()
202:                         isPresented = false
203:                     }
204:                     .disabled(cycleName.isEmpty)
205:                 }
206:             }
207:         }
208:     }
209:     private func saveCycle() {
210:         let newCycle = Cycle(
211:             name: cycleName,
212:             startDate: startDate,
213:             totalWeeks: totalWeeks,
214:             notes: notes.isEmpty ? nil : notes
215:         )
216:         dataStore.saveCycle(newCycle)
217:     }
218: }
219: // Placeholder for Cycle Detail View - to be implemented
220: struct CycleDetailView: View {
221:     let cycle: Cycle
222:     @EnvironmentObject var dataStore: AppDataStore
223:     @State private var isPresentingEditForm = false
224:     @State private var isPresentingStageForm = false
225:     var body: some View {
226:         NavigationView {
227:             ScrollView {
228:                 VStack(alignment: .leading, spacing: 16) {
229:                     // Cycle information
230:                     VStack(alignment: .leading, spacing: 8) {
231:                         Text(cycle.name)
232:                             .font(.title)
233:                             .bold()
234:                         HStack {
235:                             Text(&quot;Start: \(formatDate(cycle.startDate))&quot;)
236:                             Spacer()
237:                             Text(&quot;End: \(formatDate(cycle.endDate))&quot;)
238:                         }
239:                         .font(.subheadline)
240:                         .foregroundColor(.secondary)
241:                         if let notes = cycle.notes, !notes.isEmpty {
242:                             Text(notes)
243:                                 .font(.body)
244:                                 .padding(.top, 4)
245:                         }
246:                     }
247:                     .padding()
248:                     .background(
249:                         RoundedRectangle(cornerRadius: 12)
250:                             .fill(Color(.secondarySystemBackground))
251:                     )
252:                     .padding(.horizontal)
253:                     // Stages Timeline
254:                     if cycle.stages.isEmpty {
255:                         emptyStagesView
256:                     } else {
257:                         stagesTimelineView
258:                     }
259:                     // Simulation Results
260:                     if dataStore.isCycleSimulationActive, !dataStore.cycleSimulationData.isEmpty {
261:                         VStack(alignment: .leading, spacing: 8) {
262:                             Text(&quot;Simulation Results&quot;)
263:                                 .font(.headline)
264:                                 .padding(.bottom, 5)
265:                             CycleChartView(simulationData: dataStore.cycleSimulationData)
266:                                 .frame(height: 200)
267:                         }
268:                         .padding()
269:                         .background(
270:                             RoundedRectangle(cornerRadius: 12)
271:                                 .fill(Color(.secondarySystemBackground))
272:                         )
273:                         .padding(.horizontal)
274:                     }
275:                     Spacer()
276:                 }
277:                 .padding(.vertical)
278:             }
279:             .navigationBarTitleDisplayMode(.inline)
280:             .toolbar {
281:                 ToolbarItem(placement: .primaryAction) {
282:                     Button(action: {
283:                         isPresentingEditForm = true
284:                     }) {
285:                         Text(&quot;Edit&quot;)
286:                     }
287:                 }
288:                 ToolbarItem(placement: .primaryAction) {
289:                     Button(action: {
290:                         isPresentingStageForm = true
291:                     }) {
292:                         Label(&quot;Add Stage&quot;, systemImage: &quot;plus&quot;)
293:                     }
294:                 }
295:             }
296:             .sheet(isPresented: $isPresentingStageForm) {
297:                 CycleStageFormView(isPresented: $isPresentingStageForm, cycle: cycle)
298:                     .environmentObject(dataStore)
299:             }
300:             .sheet(isPresented: $isPresentingEditForm) {
301:                 // TODO: Add edit cycle form here
302:                 Text(&quot;Edit Cycle&quot;)
303:             }
304:         }
305:     }
306:     private var emptyStagesView: some View {
307:         VStack(spacing: 16) {
308:             Image(systemName: &quot;calendar.badge.plus&quot;)
309:                 .font(.system(size: 40))
310:                 .foregroundColor(.secondary)
311:             Text(&quot;No Stages Yet&quot;)
312:                 .font(.headline)
313:             Text(&quot;Add stages to build your cycle timeline&quot;)
314:                 .font(.subheadline)
315:                 .multilineTextAlignment(.center)
316:                 .foregroundColor(.secondary)
317:             Button(action: {
318:                 isPresentingStageForm = true
319:             }) {
320:                 Text(&quot;Add Stage&quot;)
321:                     .font(.headline)
322:                     .padding()
323:                     .background(Color.accentColor)
324:                     .foregroundColor(.white)
325:                     .cornerRadius(10)
326:             }
327:         }
328:         .padding()
329:         .frame(maxWidth: .infinity)
330:         .background(
331:             RoundedRectangle(cornerRadius: 12)
332:                 .fill(Color(.secondarySystemBackground))
333:         )
334:         .padding(.horizontal)
335:     }
336:     private var stagesTimelineView: some View {
337:         VStack(alignment: .leading, spacing: 8) {
338:             Text(&quot;Timeline&quot;)
339:                 .font(.headline)
340:                 .padding(.bottom, 5)
341:             // Timeline visualization will go here
342:             Text(&quot;Timeline visualization placeholder&quot;)
343:                 .frame(height: 100)
344:                 .frame(maxWidth: .infinity)
345:                 .background(Color.gray.opacity(0.1))
346:                 .cornerRadius(8)
347:         }
348:         .padding()
349:         .background(
350:             RoundedRectangle(cornerRadius: 12)
351:                 .fill(Color(.secondarySystemBackground))
352:         )
353:         .padding(.horizontal)
354:     }
355:     private func formatDate(_ date: Date) -&gt; String {
356:         let formatter = DateFormatter()
357:         formatter.dateStyle = .medium
358:         formatter.timeStyle = .none
359:         return formatter.string(from: date)
360:     }
361: }
362: struct CyclePlannerView_Previews: PreviewProvider {
363:     static var previews: some View {
364:         CyclePlannerView()
365:             .environmentObject(AppDataStore())
366:     }
367: }

================
File: TestoSim/ContentView.swift
================
 1: //
 2: //  ContentView.swift
 3: //  TestoSim
 4: //
 5: //  Created by Jesper Vang on 01/05/2025.
 6: //
 7: import SwiftUI
 8: struct ContentView: View {
 9:     @EnvironmentObject var dataStore: AppDataStore
10:     var body: some View {
11:         TabView {
12:             NavigationStack {
13:                 ProtocolListView()
14:             }
15:             .tabItem {
16:                 Label(&quot;Protocols&quot;, systemImage: &quot;list.bullet&quot;)
17:             }
18:             NavigationStack {
19:                 CyclePlannerView()
20:             }
21:             .tabItem {
22:                 Label(&quot;Cycles&quot;, systemImage: &quot;calendar&quot;)
23:             }
24:             NavigationStack {
25:                 AIInsightsView()
26:             }
27:             .tabItem {
28:                 Label(&quot;Insights&quot;, systemImage: &quot;lightbulb&quot;)
29:             }
30:             NavigationStack {
31:                 ProfileView()
32:             }
33:             .tabItem {
34:                 Label(&quot;Profile&quot;, systemImage: &quot;person&quot;)
35:             }
36:         }
37:     }
38: }
39: #Preview {
40:     ContentView()
41:         .environmentObject(AppDataStore())
42: }

================
File: TestoSim/TestoSim.entitlements
================
 1: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 2: &lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
 3: &lt;plist version=&quot;1.0&quot;&gt;
 4: &lt;dict&gt;
 5:     &lt;key&gt;com.apple.security.app-sandbox&lt;/key&gt;
 6:     &lt;true/&gt;
 7:     &lt;key&gt;com.apple.security.files.user-selected.read-only&lt;/key&gt;
 8:     &lt;true/&gt;
 9:     &lt;key&gt;com.apple.developer.icloud-container-identifiers&lt;/key&gt;
10:     &lt;array&gt;
11:         &lt;string&gt;iCloud.flight505.TestoSim&lt;/string&gt;
12:     &lt;/array&gt;
13:     &lt;key&gt;com.apple.developer.icloud-services&lt;/key&gt;
14:     &lt;array&gt;
15:         &lt;string&gt;CloudKit&lt;/string&gt;
16:     &lt;/array&gt;
17: &lt;/dict&gt;
18: &lt;/plist&gt;

================
File: copy-config.sh
================
 1: #!/bin/bash
 2: # Copy xcconfig file if needed
 3: CONFIG_XCCONFIG_PATH=&quot;$SRCROOT/TestoSim/Config.xcconfig&quot;
 4: SAMPLE_XCCONFIG_PATH=&quot;$SRCROOT/TestoSim/Config-Sample.xcconfig&quot;
 5: if [ -f &quot;$CONFIG_XCCONFIG_PATH&quot; ]; then
 6:   echo &quot;$CONFIG_XCCONFIG_PATH exists.&quot;
 7: else
 8:   echo &quot;$CONFIG_XCCONFIG_PATH does not exist, copying sample&quot;
 9:   cp -v &quot;${SAMPLE_XCCONFIG_PATH}&quot; &quot;${CONFIG_XCCONFIG_PATH}&quot;
10: fi
11: # Copy plist file if needed
12: CONFIG_PLIST_PATH=&quot;$SRCROOT/TestoSim/Config.plist&quot;
13: SAMPLE_PLIST_PATH=&quot;$SRCROOT/TestoSim/Config-Sample.plist&quot;
14: if [ -f &quot;$CONFIG_PLIST_PATH&quot; ]; then
15:   echo &quot;$CONFIG_PLIST_PATH exists.&quot;
16: else
17:   echo &quot;$CONFIG_PLIST_PATH does not exist, copying sample&quot;
18:   cp -v &quot;${SAMPLE_PLIST_PATH}&quot; &quot;${CONFIG_PLIST_PATH}&quot;
19: fi

================
File: TestoSim/Models/ProfileModel.swift
================
 1: import Foundation
 2: struct UserProfile: Codable {
 3:     var id: UUID = UUID()
 4:     var name: String = &quot;My Profile&quot;
 5:     var unit: String = &quot;ng/dL&quot; // Default unit
 6:     var calibrationFactor: Double = 1.0 // Default calibration
 7:     var protocols: [InjectionProtocol] = []
 8:     // New parameters for Story 9 and 10
 9:     var dateOfBirth: Date?
10:     var heightCm: Double?
11:     var weight: Double? = 70.0 // Default weight in kg
12:     enum BiologicalSex: String, Codable, CaseIterable {
13:         case male, female
14:     }
15:     var biologicalSex: BiologicalSex = .male
16:     var usesICloudSync: Bool = false
17:     // PK Model settings - always use the more accurate two-compartment model
18:     var useTwoCompartmentModel: Bool = true
19:     // Computed property for body surface area (DuBois formula)
20:     var bodySurfaceArea: Double? {
21:         guard let weight = weight, let heightCm = heightCm else {
22:             return nil
23:         }
24:         // DuBois formula: BSA (m²) = 0.007184 × height(cm)^0.725 × weight(kg)^0.425
25:         return 0.007184 * pow(heightCm, 0.725) * pow(weight, 0.425)
26:     }
27:     // Computed property for age
28:     var age: Int? {
29:         guard let dob = dateOfBirth else {
30:             return nil
31:         }
32:         let calendar = Calendar.current
33:         let ageComponents = calendar.dateComponents([.year], from: dob, to: Date())
34:         return ageComponents.year
35:     }
36: }

================
File: TestoSim/Views/AddBloodworkView.swift
================
 1: import SwiftUI
 2: struct AddBloodworkView: View {
 3:     @EnvironmentObject var dataStore: AppDataStore
 4:     @Environment(\.dismiss) var dismiss
 5:     var injectionProtocol: InjectionProtocol
 6:     @State private var bloodValue: String = &quot;&quot;
 7:     @State private var bloodDate: Date = Date()
 8:     @State private var notes: String = &quot;&quot;
 9:     @State private var showingAlert = false
10:     @State private var alertMessage = &quot;&quot;
11:     var body: some View {
12:         NavigationStack {
13:             Form {
14:                 Section(&quot;Sample Details&quot;) {
15:                     TextField(&quot;Blood Level Value (\(dataStore.profile.unit))&quot;, text: $bloodValue)
16:                         .keyboardType(.numbersAndPunctuation)
17:                     DatePicker(&quot;Sample Date&quot;, selection: $bloodDate, displayedComponents: [.date, .hourAndMinute])
18:                 }
19:                 Section(&quot;Notes&quot;) {
20:                     TextEditor(text: $notes)
21:                         .frame(minHeight: 100)
22:                 }
23:                 Section(&quot;Actions&quot;) {
24:                     Button(&quot;Add Sample and Calibrate&quot;) {
25:                         saveBloodwork(andCalibrate: true)
26:                     }
27:                     .frame(maxWidth: .infinity)
28:                     .foregroundColor(.white)
29:                     .padding()
30:                     .background(Color.blue)
31:                     .cornerRadius(10)
32:                     Button(&quot;Add Sample Only&quot;) {
33:                         saveBloodwork(andCalibrate: false)
34:                     }
35:                     .frame(maxWidth: .infinity)
36:                     .foregroundColor(.white)
37:                     .padding()
38:                     .background(Color.green)
39:                     .cornerRadius(10)
40:                 }
41:             }
42:             .navigationTitle(&quot;Add Blood Sample&quot;)
43:             .navigationBarTitleDisplayMode(.inline)
44:             .toolbar {
45:                 ToolbarItem(placement: .navigationBarLeading) {
46:                     Button(&quot;Cancel&quot;) {
47:                         dismiss()
48:                     }
49:                 }
50:             }
51:             .alert(alertMessage, isPresented: $showingAlert) {
52:                 Button(&quot;OK&quot;, role: .cancel) { }
53:             }
54:         }
55:     }
56:     private func saveBloodwork(andCalibrate: Bool) {
57:         guard let valueDouble = Double(bloodValue) else {
58:             alertMessage = &quot;Please enter a valid number for the blood level&quot;
59:             showingAlert = true
60:             return
61:         }
62:         // Create a new sample
63:         let newSample = BloodSample(
64:             date: bloodDate,
65:             value: valueDouble,
66:             unit: dataStore.profile.unit
67:         )
68:         // Add to the protocol
69:         var updatedProtocol = injectionProtocol
70:         updatedProtocol.bloodSamples.append(newSample)
71:         // Save back to the data store
72:         dataStore.updateProtocol(updatedProtocol)
73:         // If requested, perform calibration
74:         if andCalibrate {
75:             dataStore.calibrateProtocol(updatedProtocol)
76:         }
77:         dismiss()
78:     }
79: }
80: #Preview {
81:     AddBloodworkView(injectionProtocol: InjectionProtocol(
82:         name: &quot;Test Protocol&quot;,
83:         doseMg: 100,
84:         frequencyDays: 7,
85:         startDate: Date().addingTimeInterval(-30 * 24 * 3600) // 30 days ago
86:     ))
87:     .environmentObject(AppDataStore())
88: }

================
File: TestoSim/Views/ProtocolListView.swift
================
 1: import SwiftUI
 2: struct ProtocolListView: View {
 3:     @EnvironmentObject var dataStore: AppDataStore
 4:     var body: some View {
 5:         List {
 6:             if dataStore.profile.protocols.isEmpty {
 7:                 Text(&quot;No protocols yet. Tap + to add one.&quot;)
 8:                     .foregroundColor(.secondary)
 9:             } else {
10:                 ForEach(dataStore.profile.protocols) { injectionProtocol in
11:                     NavigationLink(destination: ProtocolDetailView(injectionProtocol: injectionProtocol)) {
12:                         protocolRowContent(for: injectionProtocol)
13:                     }
14:                 }
15:                 .onDelete(perform: deleteItems)
16:             }
17:         }
18:         .navigationTitle(&quot;Protocols&quot;)
19:         .toolbar {
20:             toolbarContent
21:         }
22:         .sheet(isPresented: $dataStore.isPresentingProtocolForm) {
23:             ProtocolFormView(protocolToEdit: dataStore.protocolToEdit)
24:                 .environmentObject(dataStore)
25:         }
26:     }
27:     // Extracted toolbar content
28:     private var toolbarContent: some ToolbarContent {
29:         Group {
30:             ToolbarItem(placement: .automatic) {
31:                 NavigationLink(destination: ProfileView()) {
32:                     Label(&quot;Profile&quot;, systemImage: &quot;person.circle&quot;)
33:                 }
34:             }
35:             ToolbarItem(placement: .primaryAction) {
36:                 Button {
37:                     dataStore.protocolToEdit = nil
38:                     dataStore.isPresentingProtocolForm = true
39:                 } label: {
40:                     Label(&quot;Add Protocol&quot;, systemImage: &quot;plus&quot;)
41:                 }
42:             }
43:         }
44:     }
45:     // Extracted protocol row content
46:     private func protocolRowContent(for injectionProtocol: InjectionProtocol) -&gt; some View {
47:         VStack(alignment: .leading) {
48:             Text(injectionProtocol.name)
49:                 .font(.headline)
50:             // Summary text based on protocol type
51:             Group {
52:                 switch injectionProtocol.protocolType {
53:                 case .compound:
54:                     if let compoundID = injectionProtocol.compoundID,
55:                        let compound = dataStore.compoundLibrary.compound(withID: compoundID) {
56:                         Text(&quot;\(injectionProtocol.doseMg, format: .number.precision(.fractionLength(0))) mg \(compound.fullDisplayName) every \(injectionProtocol.frequencyDays, format: .number.precision(.fractionLength(1))) days&quot;)
57:                     } else {
58:                         Text(&quot;\(injectionProtocol.doseMg, format: .number.precision(.fractionLength(0))) mg every \(injectionProtocol.frequencyDays, format: .number.precision(.fractionLength(1))) days&quot;)
59:                     }
60:                 case .blend:
61:                     if let blendID = injectionProtocol.blendID,
62:                        let blend = dataStore.compoundLibrary.blend(withID: blendID) {
63:                         Text(&quot;\(injectionProtocol.doseMg, format: .number.precision(.fractionLength(0))) mg \(blend.name) every \(injectionProtocol.frequencyDays, format: .number.precision(.fractionLength(1))) days&quot;)
64:                     } else {
65:                         Text(&quot;\(injectionProtocol.doseMg, format: .number.precision(.fractionLength(0))) mg every \(injectionProtocol.frequencyDays, format: .number.precision(.fractionLength(1))) days&quot;)
66:                     }
67:                 }
68:             }
69:             .font(.subheadline)
70:             .foregroundColor(.secondary)
71:         }
72:     }
73:     private func deleteItems(at offsets: IndexSet) {
74:         dataStore.removeProtocol(at: offsets)
75:     }
76: }
77: #Preview {
78:     NavigationStack {
79:         ProtocolListView()
80:             .environmentObject(AppDataStore())
81:     }
82: }

================
File: TestoSim/Views/TestosteroneChart.swift
================
  1: import SwiftUI
  2: import Charts
  3: struct TestosteroneChart: View {
  4:     @EnvironmentObject var dataStore: AppDataStore
  5:     let treatmentProtocol: InjectionProtocol
  6:     @State private var selectedDataPoint: DataPoint?
  7:     @State private var selectedDate: Date?
  8:     // Find reasonable min/max for Y axis
  9:     private var yAxisRange: ClosedRange&lt;Double&gt; {
 10:         if dataStore.simulationData.isEmpty {
 11:             return 0...1000
 12:         }
 13:         let levels = dataStore.simulationData.map { $0.level }
 14:         let minLevel = max(0, levels.min() ?? 0)
 15:         let maxLevel = max(1000, levels.max() ?? 1000)
 16:         // Add 20% padding at top
 17:         return minLevel...(maxLevel * 1.2)
 18:     }
 19:     // Find dates for X axis to avoid super tiny display
 20:     private var dateRange: ClosedRange&lt;Date&gt; {
 21:         guard !dataStore.simulationData.isEmpty else {
 22:             return Date()...(Date().addingTimeInterval(30*24*3600))
 23:         }
 24:         if let firstDate = dataStore.simulationData.first?.time,
 25:            let lastDate = dataStore.simulationData.last?.time {
 26:             return firstDate...lastDate
 27:         }
 28:         return Date()...(Date().addingTimeInterval(30*24*3600))
 29:     }
 30:     var body: some View {
 31:         VStack(alignment: .leading, spacing: 8) {
 32:             // Header
 33:             HStack {
 34:                 Text(&quot;Concentration Chart&quot;)
 35:                     .font(.headline)
 36:                 Spacer()
 37:                 Text(dataStore.profile.unit)
 38:                     .foregroundColor(.secondary)
 39:             }
 40:             ZStack(alignment: .topLeading) {
 41:                 // Chart
 42:                 Chart {
 43:                     // Main concentration line
 44:                     ForEach(dataStore.simulationData) { dataPoint in
 45:                         LineMark(
 46:                             x: .value(&quot;Date&quot;, dataPoint.time),
 47:                             y: .value(&quot;Level&quot;, dataPoint.level)
 48:                         )
 49:                         .foregroundStyle(Color.blue.gradient)
 50:                         .interpolationMethod(.catmullRom)
 51:                         .lineStyle(StrokeStyle(lineWidth: 2.5))
 52:                     }
 53:                     // Highlight selected point
 54:                     if let selectedPoint = selectedDataPoint {
 55:                         PointMark(
 56:                             x: .value(&quot;Date&quot;, selectedPoint.time),
 57:                             y: .value(&quot;Level&quot;, selectedPoint.level)
 58:                         )
 59:                         .symbolSize(100)
 60:                         .foregroundStyle(Color.blue.opacity(0.3))
 61:                     }
 62:                     // Injection dates markers
 63:                     let injectionDates = treatmentProtocol.injectionDates(
 64:                         from: dateRange.lowerBound,
 65:                         upto: dateRange.upperBound
 66:                     )
 67:                     ForEach(injectionDates, id: \.self) { date in
 68:                         // Add point markers for injections
 69:                         PointMark(
 70:                             x: .value(&quot;Injection&quot;, date),
 71:                             y: .value(&quot;Level&quot;, findLevelAt(date: date))
 72:                         )
 73:                         .foregroundStyle(Color.green)
 74:                         .symbolSize(30)
 75:                         // Add vertical lines
 76:                         RuleMark(
 77:                             x: .value(&quot;Injection&quot;, date)
 78:                         )
 79:                         .foregroundStyle(Color.green.opacity(0.2))
 80:                         .lineStyle(StrokeStyle(lineWidth: 1, dash: [4, 4]))
 81:                     }
 82:                     // Show selected date vertical line
 83:                     if let date = selectedDate {
 84:                         RuleMark(
 85:                             x: .value(&quot;Selected&quot;, date)
 86:                         )
 87:                         .foregroundStyle(Color.secondary.opacity(0.5))
 88:                     }
 89:                 }
 90:                 .chartYScale(domain: yAxisRange)
 91:                 .chartXScale(domain: dateRange)
 92:                 .chartXAxis {
 93:                     AxisMarks(values: .stride(by: .day, count: 7)) { _ in
 94:                         AxisValueLabel(format: .dateTime.month().day())
 95:                         AxisGridLine()
 96:                     }
 97:                 }
 98:                 .chartYAxis {
 99:                     AxisMarks(position: .leading, values: .automatic(desiredCount: 5)) { value in
100:                         let level = value.as(Double.self) ?? 0
101:                         AxisValueLabel(&quot;\(level.isFinite ? Int(level) : 0)&quot;)
102:                         AxisGridLine()
103:                     }
104:                 }
105:                 .frame(height: 250)
106:                 .chartOverlay { proxy in
107:                     GeometryReader { geo in
108:                         Rectangle()
109:                             .fill(Color.clear)
110:                             .contentShape(Rectangle())
111:                             .gesture(
112:                                 DragGesture(minimumDistance: 0)
113:                                     .onChanged { value in
114:                                         let x = value.location.x - geo.frame(in: .local).origin.x
115:                                         guard let date = proxy.value(atX: x, as: Date.self) else { return }
116:                                         selectedDate = date
117:                                         if let closestPoint = findClosestDataPoint(to: date) {
118:                                             selectedDataPoint = closestPoint
119:                                         }
120:                                     }
121:                                     .onEnded { _ in
122:                                         selectedDate = nil
123:                                         selectedDataPoint = nil
124:                                     }
125:                             )
126:                     }
127:                 }
128:                 // If no data, show message
129:                 if dataStore.simulationData.isEmpty {
130:                     Text(&quot;No data available for chart&quot;)
131:                         .foregroundColor(.secondary)
132:                         .frame(maxWidth: .infinity, maxHeight: .infinity)
133:                         .background(Color(.systemGray6).opacity(0.5))
134:                 }
135:             }
136:             // Display selected point info
137:             if let selected = selectedDataPoint {
138:                 HStack {
139:                     VStack(alignment: .leading) {
140:                         Text(selected.time, style: .date)
141:                             .font(.caption)
142:                         Text(selected.time, style: .time)
143:                             .font(.caption)
144:                     }
145:                     Spacer()
146:                     Text(&quot;\(selected.level.isFinite ? Int(selected.level) : 0) \(dataStore.profile.unit)&quot;)
147:                         .font(.headline)
148:                         .foregroundColor(.blue)
149:                 }
150:                 .padding(.vertical, 4)
151:             }
152:         }
153:         .padding()
154:         .background(Color(.systemGray6))
155:         .cornerRadius(10)
156:     }
157:     private func findClosestDataPoint(to date: Date) -&gt; DataPoint? {
158:         guard !dataStore.simulationData.isEmpty else { return nil }
159:         return dataStore.simulationData.min(by: { abs($0.time.timeIntervalSince(date)) &lt; abs($1.time.timeIntervalSince(date)) })
160:     }
161:     private func findLevelAt(date: Date) -&gt; Double {
162:         guard !dataStore.simulationData.isEmpty else { return 0 }
163:         if let closestPoint = findClosestDataPoint(to: date) {
164:             return closestPoint.level
165:         }
166:         // If no close point found, try to calculate directly
167:         return dataStore.predictedLevel(on: date, for: treatmentProtocol)
168:     }
169: }

================
File: TestoSim/Models/CoreDataExtensions.swift
================
  1: import Foundation
  2: import CoreData
  3: // MARK: - UserProfile Extensions
  4: extension UserProfile {
  5:     // Create a UserProfile from a Core Data CDUserProfile
  6:     init(from cdProfile: CDUserProfile) {
  7:         self.id = cdProfile.id ?? UUID()
  8:         self.name = cdProfile.name ?? &quot;My Profile&quot;
  9:         self.unit = cdProfile.unit ?? &quot;ng/dL&quot;
 10:         self.calibrationFactor = cdProfile.calibrationFactor
 11:         self.dateOfBirth = cdProfile.dateOfBirth
 12:         self.heightCm = cdProfile.heightCm
 13:         self.weight = cdProfile.weight
 14:         // Convert string biologicalSex to enum
 15:         if let sexString = cdProfile.biologicalSex,
 16:            let sex = BiologicalSex(rawValue: sexString) {
 17:             self.biologicalSex = sex
 18:         } else {
 19:             self.biologicalSex = .male
 20:         }
 21:         self.usesICloudSync = cdProfile.usesICloudSync
 22:         self.useTwoCompartmentModel = cdProfile.useTwoCompartmentModel
 23:         // Extract protocols
 24:         if let cdProtocols = cdProfile.protocols as? Set&lt;CDInjectionProtocol&gt; {
 25:             self.protocols = cdProtocols.compactMap { InjectionProtocol(from: $0) }
 26:         } else {
 27:             self.protocols = []
 28:         }
 29:     }
 30:     // Save/update UserProfile to Core Data
 31:     func saveToCD(context: NSManagedObjectContext) -&gt; CDUserProfile {
 32:         // Check if profile already exists
 33:         let fetchRequest: NSFetchRequest&lt;CDUserProfile&gt; = CDUserProfile.fetchRequest()
 34:         fetchRequest.predicate = NSPredicate(format: &quot;id == %@&quot;, self.id as CVarArg)
 35:         var cdProfile: CDUserProfile
 36:         do {
 37:             let results = try context.fetch(fetchRequest)
 38:             if let existingProfile = results.first {
 39:                 cdProfile = existingProfile
 40:             } else {
 41:                 cdProfile = CDUserProfile(context: context)
 42:                 cdProfile.id = self.id
 43:             }
 44:             // Update properties
 45:             cdProfile.name = self.name
 46:             cdProfile.unit = self.unit
 47:             cdProfile.calibrationFactor = self.calibrationFactor
 48:             cdProfile.dateOfBirth = self.dateOfBirth
 49:             cdProfile.heightCm = self.heightCm ?? 0
 50:             cdProfile.weight = self.weight ?? 0
 51:             cdProfile.biologicalSex = self.biologicalSex.rawValue
 52:             cdProfile.usesICloudSync = self.usesICloudSync
 53:             cdProfile.useTwoCompartmentModel = self.useTwoCompartmentModel
 54:             // Handle protocols (this will be more complex due to relationships)
 55:             // We&apos;d need to compare existing protocols with new ones
 56:             // For now, we&apos;ll just replace them all
 57:             // First, remove all existing protocols
 58:             if let existingProtocols = cdProfile.protocols as? Set&lt;CDInjectionProtocol&gt; {
 59:                 for p in existingProtocols {
 60:                     context.delete(p)
 61:                 }
 62:             }
 63:             // Then add all current protocols
 64:             for p in self.protocols {
 65:                 let cdProtocol = p.saveToCD(context: context)
 66:                 cdProfile.addToProtocols(cdProtocol)
 67:             }
 68:             // Save the context
 69:             try context.save()
 70:         } catch {
 71:             print(&quot;Error saving UserProfile to CoreData: \(error)&quot;)
 72:             cdProfile = CDUserProfile(context: context)
 73:             cdProfile.id = self.id
 74:             cdProfile.name = self.name
 75:         }
 76:         return cdProfile
 77:     }
 78: }
 79: // MARK: - InjectionProtocol Extensions
 80: extension InjectionProtocol {
 81:     // Create an InjectionProtocol from a Core Data CDInjectionProtocol
 82:     init?(from cdProtocol: CDInjectionProtocol) {
 83:         guard let id = cdProtocol.id,
 84:               let name = cdProtocol.name,
 85:               let startDate = cdProtocol.startDate else {
 86:             return nil
 87:         }
 88:         self.id = id
 89:         self.name = name
 90:         self.doseMg = cdProtocol.doseMg
 91:         self.frequencyDays = cdProtocol.frequencyDays
 92:         self.startDate = startDate
 93:         self.notes = cdProtocol.notes
 94:         // Try to extract extended properties from notes
 95:         if let notes = cdProtocol.notes, notes.contains(&quot;---EXTENDED_DATA---&quot;) {
 96:             if let range = notes.range(of: &quot;---EXTENDED_DATA---&quot;) {
 97:                 let startIndex = range.upperBound
 98:                 let jsonString = String(notes[startIndex...]).trimmingCharacters(in: .whitespacesAndNewlines)
 99:                 if !jsonString.isEmpty, let jsonData = jsonString.data(using: .utf8) {
100:                     do {
101:                         if let extendedData = try JSONSerialization.jsonObject(with: jsonData, options: []) as? [String: String] {
102:                             // Extract properties
103:                             if let protocolTypeStr = extendedData[&quot;protocolType&quot;], 
104:                                let _ = ProtocolType(rawValue: protocolTypeStr) {
105:                                 // Protocol type will be set via computed property
106:                             }
107:                             if let compoundIDStr = extendedData[&quot;compoundID&quot;], !compoundIDStr.isEmpty {
108:                                 self.compoundID = UUID(uuidString: compoundIDStr)
109:                             }
110:                             if let blendIDStr = extendedData[&quot;blendID&quot;], !blendIDStr.isEmpty {
111:                                 self.blendID = UUID(uuidString: blendIDStr)
112:                             }
113:                             if let routeStr = extendedData[&quot;selectedRoute&quot;], !routeStr.isEmpty {
114:                                 self.selectedRoute = routeStr
115:                             }
116:                         }
117:                     } catch {
118:                         print(&quot;Error parsing extended data JSON: \(error)&quot;)
119:                     }
120:                 }
121:             }
122:         }
123:         // Extract blood samples
124:         if let cdSamples = cdProtocol.bloodSamples as? Set&lt;CDBloodSample&gt; {
125:             self.bloodSamples = cdSamples.compactMap { BloodSample(from: $0) }
126:         } else {
127:             self.bloodSamples = []
128:         }
129:     }
130:     // Save/update InjectionProtocol to Core Data
131:     func saveToCD(context: NSManagedObjectContext) -&gt; CDInjectionProtocol {
132:         // Check if protocol already exists
133:         let fetchRequest: NSFetchRequest&lt;CDInjectionProtocol&gt; = CDInjectionProtocol.fetchRequest()
134:         fetchRequest.predicate = NSPredicate(format: &quot;id == %@&quot;, self.id as CVarArg)
135:         var cdProtocol: CDInjectionProtocol
136:         do {
137:             let results = try context.fetch(fetchRequest)
138:             if let existingProtocol = results.first {
139:                 cdProtocol = existingProtocol
140:             } else {
141:                 cdProtocol = CDInjectionProtocol(context: context)
142:                 cdProtocol.id = self.id
143:             }
144:             // Update properties
145:             cdProtocol.name = self.name
146:             cdProtocol.doseMg = self.doseMg
147:             cdProtocol.frequencyDays = self.frequencyDays
148:             cdProtocol.startDate = self.startDate
149:             // Store extended properties in notes field as JSON
150:             var userNotes = self.notes ?? &quot;&quot;
151:             // Remove existing extended data section if present
152:             if let range = userNotes.range(of: &quot;---EXTENDED_DATA---&quot;) {
153:                 userNotes = String(userNotes[..&lt;range.lowerBound]).trimmingCharacters(in: .whitespacesAndNewlines)
154:             }
155:             // Create the extended data dictionary
156:             let extendedData: [String: String] = [
157:                 &quot;protocolType&quot;: self.protocolType.rawValue,
158:                 &quot;compoundID&quot;: self.compoundID?.uuidString ?? &quot;&quot;,
159:                 &quot;blendID&quot;: self.blendID?.uuidString ?? &quot;&quot;,
160:                 &quot;selectedRoute&quot;: self.selectedRoute ?? &quot;&quot;
161:             ]
162:             if let extendedJSON = try? JSONEncoder().encode(extendedData),
163:                let jsonString = String(data: extendedJSON, encoding: .utf8) {
164:                 // Append to notes
165:                 if !userNotes.isEmpty {
166:                     cdProtocol.notes = userNotes + &quot;\n\n---EXTENDED_DATA---\n&quot; + jsonString
167:                 } else {
168:                     cdProtocol.notes = &quot;---EXTENDED_DATA---\n&quot; + jsonString
169:                 }
170:             } else {
171:                 cdProtocol.notes = userNotes
172:             }
173:             // Handle blood samples
174:             // First, remove all existing samples
175:             if let existingSamples = cdProtocol.bloodSamples as? Set&lt;CDBloodSample&gt; {
176:                 for sample in existingSamples {
177:                     context.delete(sample)
178:                 }
179:             }
180:             // Then add all current samples
181:             for sample in self.bloodSamples {
182:                 let cdSample = sample.saveToCD(context: context)
183:                 cdProtocol.addToBloodSamples(cdSample)
184:             }
185:         } catch {
186:             print(&quot;Error saving InjectionProtocol to CoreData: \(error)&quot;)
187:             cdProtocol = CDInjectionProtocol(context: context)
188:             cdProtocol.id = self.id
189:             cdProtocol.name = self.name
190:         }
191:         return cdProtocol
192:     }
193: }
194: // MARK: - BloodSample Extensions
195: extension BloodSample {
196:     // Create a BloodSample from a Core Data CDBloodSample
197:     init?(from cdSample: CDBloodSample) {
198:         guard let id = cdSample.id,
199:               let date = cdSample.date,
200:               let unit = cdSample.unit else {
201:             return nil
202:         }
203:         self.id = id
204:         self.date = date
205:         self.value = cdSample.value
206:         self.unit = unit
207:     }
208:     // Save/update BloodSample to Core Data
209:     func saveToCD(context: NSManagedObjectContext) -&gt; CDBloodSample {
210:         // Check if sample already exists
211:         let fetchRequest: NSFetchRequest&lt;CDBloodSample&gt; = CDBloodSample.fetchRequest()
212:         fetchRequest.predicate = NSPredicate(format: &quot;id == %@&quot;, self.id as CVarArg)
213:         var cdSample: CDBloodSample
214:         do {
215:             let results = try context.fetch(fetchRequest)
216:             if let existingSample = results.first {
217:                 cdSample = existingSample
218:             } else {
219:                 cdSample = CDBloodSample(context: context)
220:                 cdSample.id = self.id
221:             }
222:             // Update properties
223:             cdSample.date = self.date
224:             cdSample.value = self.value
225:             cdSample.unit = self.unit
226:         } catch {
227:             print(&quot;Error saving BloodSample to CoreData: \(error)&quot;)
228:             cdSample = CDBloodSample(context: context)
229:             cdSample.id = self.id
230:         }
231:         return cdSample
232:     }
233: }
234: // MARK: - Compound Extensions
235: extension Compound {
236:     // Create a Compound from a Core Data CDCompound
237:     init?(from cdCompound: CDCompound) {
238:         guard let id = cdCompound.id,
239:               let commonName = cdCompound.commonName,
240:               let classTypeString = cdCompound.classType,
241:               let classType = Class(rawValue: classTypeString) else {
242:             return nil
243:         }
244:         // Default values for dictionaries if serialized data not available
245:         let bioavailability: [Route: Double] = [.intramuscular: 1.0]
246:         let absorptionRates: [Route: Double] = [.intramuscular: 0.7]
247:         // Deserialize the dictionary data if available
248:         if cdCompound.routeBioavailabilityData != nil {
249:             // We would implement proper deserialization here
250:             // For now, using default values
251:         }
252:         if cdCompound.routeKaData != nil {
253:             // We would implement proper deserialization here
254:             // For now, using default values
255:         }
256:         self.id = id
257:         self.commonName = commonName
258:         self.classType = classType
259:         self.ester = cdCompound.ester
260:         self.halfLifeDays = cdCompound.halfLifeDays
261:         self.defaultBioavailability = bioavailability
262:         self.defaultAbsorptionRateKa = absorptionRates
263:     }
264:     // Save/update Compound to Core Data
265:     func saveToCD(context: NSManagedObjectContext) -&gt; CDCompound {
266:         // Check if compound already exists
267:         let fetchRequest: NSFetchRequest&lt;CDCompound&gt; = CDCompound.fetchRequest()
268:         fetchRequest.predicate = NSPredicate(format: &quot;id == %@&quot;, self.id as CVarArg)
269:         var cdCompound: CDCompound
270:         do {
271:             let results = try context.fetch(fetchRequest)
272:             if let existingCompound = results.first {
273:                 cdCompound = existingCompound
274:             } else {
275:                 cdCompound = CDCompound(context: context)
276:                 cdCompound.id = self.id
277:             }
278:             // Update properties
279:             cdCompound.commonName = self.commonName
280:             cdCompound.classType = self.classType.rawValue
281:             cdCompound.ester = self.ester
282:             cdCompound.halfLifeDays = self.halfLifeDays
283:             // Serialize the dictionaries
284:             // This is just a placeholder - we would need proper serialization
285:             // cdCompound.routeBioavailabilityData = serializeDictionary(self.defaultBioavailability)
286:             // cdCompound.routeKaData = serializeDictionary(self.defaultAbsorptionRateKa)
287:         } catch {
288:             print(&quot;Error saving Compound to CoreData: \(error)&quot;)
289:             cdCompound = CDCompound(context: context)
290:             cdCompound.id = self.id
291:         }
292:         return cdCompound
293:     }
294: }
295: // MARK: - VialBlend Extensions
296: extension VialBlend {
297:     // Create a VialBlend from a Core Data CDVialBlend
298:     init?(from cdBlend: CDVialBlend) {
299:         guard let id = cdBlend.id,
300:               let name = cdBlend.name else {
301:             return nil
302:         }
303:         self.id = id
304:         self.name = name
305:         self.manufacturer = cdBlend.manufacturer
306:         self.description = cdBlend.blendDescription
307:         // Extract components
308:         if let cdComponents = cdBlend.components as? Set&lt;CDVialComponent&gt; {
309:             self.components = cdComponents.compactMap { Component(from: $0) }
310:         } else {
311:             self.components = []
312:         }
313:     }
314:     // Save/update VialBlend to Core Data
315:     func saveToCD(context: NSManagedObjectContext) -&gt; CDVialBlend {
316:         // Check if blend already exists
317:         let fetchRequest: NSFetchRequest&lt;CDVialBlend&gt; = CDVialBlend.fetchRequest()
318:         fetchRequest.predicate = NSPredicate(format: &quot;id == %@&quot;, self.id as CVarArg)
319:         var cdBlend: CDVialBlend
320:         do {
321:             let results = try context.fetch(fetchRequest)
322:             if let existingBlend = results.first {
323:                 cdBlend = existingBlend
324:             } else {
325:                 cdBlend = CDVialBlend(context: context)
326:                 cdBlend.id = self.id
327:             }
328:             // Update properties
329:             cdBlend.name = self.name
330:             cdBlend.manufacturer = self.manufacturer
331:             cdBlend.blendDescription = self.description
332:             // Handle components
333:             // First, remove all existing components
334:             if let existingComponents = cdBlend.components as? Set&lt;CDVialComponent&gt; {
335:                 for component in existingComponents {
336:                     context.delete(component)
337:                 }
338:             }
339:             // Then add all current components
340:             for component in self.components {
341:                 let cdComponent = CDVialComponent(context: context)
342:                 cdComponent.mgPerML = component.mgPerML
343:                 // Find the compound
344:                 let compoundFetchRequest: NSFetchRequest&lt;CDCompound&gt; = CDCompound.fetchRequest()
345:                 compoundFetchRequest.predicate = NSPredicate(format: &quot;id == %@&quot;, component.compoundID as CVarArg)
346:                 let compoundResults = try context.fetch(compoundFetchRequest)
347:                 if let cdCompound = compoundResults.first {
348:                     cdComponent.compound = cdCompound
349:                 } else {
350:                     // Compound not found - this is an error condition
351:                     print(&quot;Error: Compound with ID \(component.compoundID) not found in Core Data&quot;)
352:                     continue
353:                 }
354:                 cdBlend.addToComponents(cdComponent)
355:             }
356:         } catch {
357:             print(&quot;Error saving VialBlend to CoreData: \(error)&quot;)
358:             cdBlend = CDVialBlend(context: context)
359:             cdBlend.id = self.id
360:         }
361:         return cdBlend
362:     }
363: }
364: // MARK: - VialBlend.Component Extensions
365: extension VialBlend.Component {
366:     init?(from cdComponent: CDVialComponent) {
367:         guard let compound = cdComponent.compound,
368:               let compoundID = compound.id else {
369:             return nil
370:         }
371:         self.compoundID = compoundID
372:         self.mgPerML = cdComponent.mgPerML
373:     }
374: }
375: // MARK: - Cycle Extensions
376: extension Cycle {
377:     init(from cdCycle: CDCycle, context: NSManagedObjectContext) {
378:         self.id = cdCycle.id ?? UUID()
379:         self.name = cdCycle.name ?? &quot;Unnamed Cycle&quot;
380:         self.startDate = cdCycle.startDate ?? Date()
381:         self.totalWeeks = Int(cdCycle.totalWeeks)
382:         self.notes = cdCycle.notes
383:         // Load stages if they exist
384:         if let cdStages = cdCycle.stages as? Set&lt;CDCycleStage&gt;, !cdStages.isEmpty {
385:             self.stages = cdStages.map { CycleStage(from: $0) }.sorted { $0.startWeek &lt; $1.startWeek }
386:         }
387:     }
388:     func save(to context: NSManagedObjectContext) -&gt; CDCycle {
389:         let cdCycle: CDCycle
390:         // Try to find existing entity first
391:         let fetchRequest: NSFetchRequest&lt;CDCycle&gt; = CDCycle.fetchRequest()
392:         fetchRequest.predicate = NSPredicate(format: &quot;id == %@&quot;, self.id as CVarArg)
393:         if let existingCycle = try? context.fetch(fetchRequest).first {
394:             cdCycle = existingCycle
395:         } else {
396:             cdCycle = CDCycle(context: context)
397:             cdCycle.id = self.id
398:         }
399:         // Update properties
400:         cdCycle.name = self.name
401:         cdCycle.startDate = self.startDate
402:         cdCycle.totalWeeks = Int32(self.totalWeeks)
403:         cdCycle.notes = self.notes
404:         // Remove old stages
405:         if let existingStages = cdCycle.stages as? Set&lt;CDCycleStage&gt; {
406:             for stage in existingStages {
407:                 context.delete(stage)
408:             }
409:         }
410:         // Add new stages
411:         for stage in self.stages {
412:             let cdStage = stage.save(to: context)
413:             cdStage.cycle = cdCycle
414:         }
415:         return cdCycle
416:     }
417: }
418: extension CycleStage {
419:     init(from cdStage: CDCycleStage) {
420:         self.id = cdStage.id ?? UUID()
421:         self.name = cdStage.name ?? &quot;Unnamed Stage&quot;
422:         self.startWeek = Int(cdStage.startWeek)
423:         self.durationWeeks = Int(cdStage.durationWeeks)
424:         // Parse compounds and blends from JSON
425:         if let compoundsData = cdStage.compoundsData, 
426:            let compoundsArray = try? JSONDecoder().decode([CompoundStageItem].self, from: compoundsData) {
427:             self.compounds = compoundsArray
428:         }
429:         if let blendsData = cdStage.blendsData,
430:            let blendsArray = try? JSONDecoder().decode([BlendStageItem].self, from: blendsData) {
431:             self.blends = blendsArray
432:         }
433:     }
434:     func save(to context: NSManagedObjectContext) -&gt; CDCycleStage {
435:         let cdStage: CDCycleStage
436:         // Try to find existing entity first
437:         let fetchRequest: NSFetchRequest&lt;CDCycleStage&gt; = CDCycleStage.fetchRequest()
438:         fetchRequest.predicate = NSPredicate(format: &quot;id == %@&quot;, self.id as CVarArg)
439:         if let existingStage = try? context.fetch(fetchRequest).first {
440:             cdStage = existingStage
441:         } else {
442:             cdStage = CDCycleStage(context: context)
443:             cdStage.id = self.id
444:         }
445:         // Update properties
446:         cdStage.name = self.name
447:         cdStage.startWeek = Int32(self.startWeek)
448:         cdStage.durationWeeks = Int32(self.durationWeeks)
449:         // Save compounds and blends as JSON
450:         do {
451:             cdStage.compoundsData = try JSONEncoder().encode(self.compounds)
452:             cdStage.blendsData = try JSONEncoder().encode(self.blends)
453:         } catch {
454:             print(&quot;Error encoding stage items: \(error)&quot;)
455:         }
456:         return cdStage
457:     }
458: }

================
File: TestoSim/Models/PKModel.swift
================
  1: import Foundation
  2: /// Pharmacokinetic model for calculating hormone concentrations
  3: struct PKModel {
  4:     // MARK: - Constants
  5:     /// Typical volume of distribution for a 70kg person in liters
  6:     static let defaultVolumeOfDistribution70kg: Double = 70.0 // L (corrected from 4.0)
  7:     /// Default clearance for a 70kg person in L/day
  8:     static let defaultClearance70kg: Double = 0.8 // L/day
  9:     // MARK: - Properties
 10:     /// Using two-compartment model (more accurate but more computationally intensive)
 11:     /// Modern devices can handle this computation without issues
 12:     var useTwoCompartmentModel: Bool = true
 13:     /// Fixed compartment transfer rates for two-compartment model
 14:     let k12: Double = 0.3 // d⁻¹
 15:     let k21: Double = 0.15 // d⁻¹
 16:     // MARK: - Initialization
 17:     init(useTwoCompartmentModel: Bool = true) {
 18:         // Always use two-compartment model, parameter kept for backward compatibility
 19:         self.useTwoCompartmentModel = true
 20:     }
 21:     // MARK: - Concentration Calculations
 22:     /// Calculate concentration for a single dose administration
 23:     /// - Parameters:
 24:     ///   - time: Time in days since administration
 25:     ///   - dose: Dose in mg
 26:     ///   - halfLifeDays: Half-life in days
 27:     ///   - absorptionRateKa: Absorption rate constant (ka) in d⁻¹
 28:     ///   - bioavailability: Fraction of drug absorbed (0-1)
 29:     ///   - weight: Patient weight in kg (for allometric scaling)
 30:     ///   - calibrationFactor: User-specific calibration factor
 31:     /// - Returns: Concentration in the appropriate units
 32:     func concentration(
 33:         at time: Double,
 34:         dose: Double,
 35:         halfLifeDays: Double,
 36:         absorptionRateKa: Double,
 37:         bioavailability: Double,
 38:         weight: Double = 70.0,
 39:         calibrationFactor: Double = 1.0
 40:     ) -&gt; Double {
 41:         // Skip calculation if time is negative or zero
 42:         guard time &gt; 0 &amp;&amp; halfLifeDays &gt; 0 else { 
 43:             return 0 
 44:         }
 45:         // Elimination rate constant (ke) = ln(2)/t_1/2
 46:         let ke = log(2) / halfLifeDays
 47:         // Skip calculation if ka ≤ ke (avoid division by zero or negative value)
 48:         // Also skip two-compartment when ka is close to ke to avoid numerical instability
 49:         if absorptionRateKa &lt;= (ke * 1.05) {
 50:             return oneCompartmentBolus(
 51:                 time: time,
 52:                 dose: dose,
 53:                 ke: ke,
 54:                 bioavailability: bioavailability,
 55:                 weight: weight,
 56:                 calibrationFactor: calibrationFactor
 57:             )
 58:         }
 59:         // Calculate volume of distribution with allometric scaling
 60:         let vd = PKModel.defaultVolumeOfDistribution70kg * pow(weight / 70.0, 1.0)
 61:         // Two-compartment model parameters
 62:         // Using standard Bateman equation for PK with first-order absorption
 63:         let scaledDose = dose * bioavailability
 64:         // Calculate hybrid rate constants for two-compartment model
 65:         // α and β are the hybrid first-order rate constants
 66:         let sum = k12 + k21 + ke
 67:         let product = k21 * ke
 68:         let discriminant = sqrt(sum * sum - 4 * product)
 69:         let alpha = 0.5 * (sum + discriminant)
 70:         let beta = 0.5 * (sum - discriminant)
 71:         // Prevent potential division by zero or very small denominators
 72:         // This can happen when rate constants are very close to each other
 73:         if abs(absorptionRateKa - alpha) &lt; 0.001 || abs(absorptionRateKa - beta) &lt; 0.001 || abs(alpha - beta) &lt; 0.001 {
 74:             // Fall back to one-compartment model if the rate constants are too close
 75:             return oneCompartmentBolus(
 76:                 time: time,
 77:                 dose: dose,
 78:                 ke: ke,
 79:                 bioavailability: bioavailability,
 80:                 weight: weight,
 81:                 calibrationFactor: calibrationFactor
 82:             )
 83:         }
 84:         // Calculate coefficients for the triexponential equation
 85:         let A = (alpha - k21) * absorptionRateKa / (vd * (alpha - beta) * (absorptionRateKa - alpha))
 86:         let B = (beta - k21) * absorptionRateKa / (vd * (beta - alpha) * (absorptionRateKa - beta))
 87:         let C = k21 * absorptionRateKa / (vd * (absorptionRateKa - alpha) * (absorptionRateKa - beta))
 88:         // Calculate concentration using the standard triexponential equation
 89:         let result = scaledDose * (
 90:             A * (exp(-alpha * time)) +
 91:             B * (exp(-beta * time)) +
 92:             C * (exp(-absorptionRateKa * time))
 93:         )
 94:         // Apply calibration factor
 95:         return max(0, result * calibrationFactor) // Ensure non-negative result
 96:     }
 97:     /// Calculate concentration for a bolus injection (immediate absorption)
 98:     /// This is a fallback for when ka ≤ ke or as direct calculation when needed
 99:     private func oneCompartmentBolus(
100:         time: Double,
101:         dose: Double,
102:         ke: Double,
103:         bioavailability: Double,
104:         weight: Double,
105:         calibrationFactor: Double
106:     ) -&gt; Double {
107:         // Calculate volume of distribution with allometric scaling
108:         let vd = PKModel.defaultVolumeOfDistribution70kg * pow(weight / 70.0, 1.0)
109:         // Simple one-compartment bolus model: C(t) = (F·D/Vd)·e^(-ke·t)
110:         let initialConcentration = (dose * bioavailability) / vd
111:         let result = initialConcentration * exp(-ke * time)
112:         return max(0, result * calibrationFactor) // Ensure non-negative result
113:     }
114:     /// Calculate the total concentration for a blend at a specific time
115:     /// - Parameters:
116:     ///   - time: Time in days since administration
117:     ///   - components: Array of tuples containing (compound, dose)
118:     ///   - route: Administration route
119:     ///   - weight: Patient weight in kg
120:     ///   - calibrationFactor: User-specific calibration factor
121:     /// - Returns: Total concentration
122:     func blendConcentration(
123:         at time: Double,
124:         components: [(compound: Compound, doseMg: Double)],
125:         route: Compound.Route,
126:         weight: Double = 70.0,
127:         calibrationFactor: Double = 1.0
128:     ) -&gt; Double {
129:         // Sum the concentrations of all components
130:         return components.reduce(0.0) { totalConcentration, component in
131:             let bioavailability = component.compound.defaultBioavailability[route] ?? 1.0
132:             let absorptionRate = component.compound.defaultAbsorptionRateKa[route] ?? 0.7 // Default ka if not specified
133:             let componentConcentration = concentration(
134:                 at: time,
135:                 dose: component.doseMg,
136:                 halfLifeDays: component.compound.halfLifeDays,
137:                 absorptionRateKa: absorptionRate,
138:                 bioavailability: bioavailability,
139:                 weight: weight,
140:                 calibrationFactor: calibrationFactor
141:             )
142:             return totalConcentration + componentConcentration
143:         }
144:     }
145:     /// Calculate the concentration over time for a protocol with multiple injections
146:     /// - Parameters:
147:     ///   - times: Array of time points in days to calculate concentrations for
148:     ///   - injectionDates: Dates of all injections
149:     ///   - compounds: Array of tuples containing (compound, dose per injection)
150:     ///   - route: Administration route
151:     ///   - weight: Patient weight in kg
152:     ///   - calibrationFactor: User-specific calibration factor
153:     /// - Returns: Array of concentrations at specified time points
154:     func protocolConcentrations(
155:         at times: [Date],
156:         injectionDates: [Date],
157:         compounds: [(compound: Compound, dosePerInjectionMg: Double)],
158:         route: Compound.Route,
159:         weight: Double = 70.0,
160:         calibrationFactor: Double = 1.0
161:     ) -&gt; [Double] {
162:         // Basic validation check
163:         if times.isEmpty || injectionDates.isEmpty || compounds.isEmpty {
164:             return Array(repeating: 0.0, count: times.count)
165:         }
166:         // Calculate concentration at each time point
167:         let results = times.map { timePoint in
168:             // Sum contributions from all injections
169:             let totalConcentration = injectionDates.reduce(0.0) { totalConc, injectionDate in
170:                 // Skip future injections
171:                 guard injectionDate &lt;= timePoint else { return totalConc }
172:                 // Calculate time difference in days
173:                 let timeDiffDays = timePoint.timeIntervalSince(injectionDate) / (24 * 3600)
174:                 // Sum contributions from all compounds in this injection
175:                 let injectionContribution = compounds.reduce(0.0) { compoundSum, compound in
176:                     let bioavailability = compound.compound.defaultBioavailability[route] ?? 1.0
177:                     let absorptionRate = compound.compound.defaultAbsorptionRateKa[route] ?? 0.7
178:                     let contribution = concentration(
179:                         at: timeDiffDays,
180:                         dose: compound.dosePerInjectionMg,
181:                         halfLifeDays: compound.compound.halfLifeDays,
182:                         absorptionRateKa: absorptionRate,
183:                         bioavailability: bioavailability,
184:                         weight: weight,
185:                         calibrationFactor: calibrationFactor
186:                     )
187:                     return compoundSum + contribution
188:                 }
189:                 return totalConc + injectionContribution
190:             }
191:             return totalConcentration
192:         }
193:         return results
194:     }
195:     // MARK: - Bayesian Calibration
196:     /// Struct to represent a blood sample with timestamp and lab value
197:     struct SamplePoint {
198:         let timestamp: Date
199:         let labValue: Double
200:     }
201:     /// Result of Bayesian calibration
202:     struct CalibrationResult {
203:         let adjustedKe: Double
204:         let adjustedKa: Double
205:         let originalKe: Double
206:         let originalKa: Double
207:         let halfLifeDays: Double
208:         let correlation: Double
209:         let samples: [SamplePoint]
210:         var halfLifeChangePercent: Double {
211:             let originalHalfLife = log(2) / originalKe
212:             let newHalfLife = log(2) / adjustedKe
213:             return ((newHalfLife / originalHalfLife) - 1.0) * 100.0
214:         }
215:     }
216:     /// Perform Bayesian calibration to refine ke and ka based on lab values
217:     /// - Parameters:
218:     ///   - samples: Dictionary of timestamps and lab values
219:     ///   - injectionDates: Dates of all injections
220:     ///   - compound: Compound being used
221:     ///   - dose: Dose in mg
222:     ///   - route: Administration route
223:     ///   - weight: Patient weight in kg
224:     /// - Returns: Calibration result with adjusted parameters
225:     func bayesianCalibration(
226:         samples: [SamplePoint],
227:         injectionDates: [Date],
228:         compound: Compound,
229:         dose: Double,
230:         route: Compound.Route,
231:         weight: Double = 70.0
232:     ) -&gt; CalibrationResult? {
233:         // Need at least 2 samples for meaningful calibration
234:         guard samples.count &gt;= 2, let defaultKa = compound.defaultAbsorptionRateKa[route] else {
235:             return nil
236:         }
237:         // Original parameters
238:         let originalKe = log(2) / compound.halfLifeDays
239:         let originalKa = defaultKa
240:         // Bioavailability for this route
241:         let bioavailability = compound.defaultBioavailability[route] ?? 1.0
242:         // Set up parameter bounds (ke and ka can&apos;t vary too much from literature values)
243:         let keMin = originalKe * 0.5  // Allow halving the elimination rate
244:         let keMax = originalKe * 2.0  // Allow doubling the elimination rate
245:         let kaMin = originalKa * 0.5  // Allow halving the absorption rate
246:         let kaMax = originalKa * 2.0  // Allow doubling the absorption rate
247:         // Initial parameter guesses
248:         var currentKe = originalKe
249:         var currentKa = originalKa
250:         var bestKe = originalKe
251:         var bestKa = originalKa
252:         var bestError = Double.greatestFiniteMagnitude
253:         // Function to calculate sum of squared errors for given parameters
254:         func calculateError(ke: Double, ka: Double) -&gt; Double {
255:             var sumSquaredError = 0.0
256:             for sample in samples {
257:                 // Calculate predicted concentration at this sample time
258:                 var predictedLevel = 0.0
259:                 for injectionDate in injectionDates {
260:                     // Skip future injections
261:                     guard injectionDate &lt;= sample.timestamp else { continue }
262:                     // Calculate time difference in days
263:                     let timeDiffDays = sample.timestamp.timeIntervalSince(injectionDate) / (24 * 3600)
264:                     guard timeDiffDays &gt;= 0 else { continue }
265:                     // Calculate concentration for this injection
266:                     let vd = PKModel.defaultVolumeOfDistribution70kg * pow(weight / 70.0, 1.0)
267:                     // Skip if ka and ke are too close (would cause division by zero)
268:                     if abs(ka - ke) &lt; 0.001 {
269:                         continue
270:                     }
271:                     // One-compartment model with first-order absorption formula
272:                     let factor = (dose * bioavailability * ka) / (vd * (ka - ke))
273:                     let contribution = factor * (exp(-ke * timeDiffDays) - exp(-ka * timeDiffDays))
274:                     predictedLevel += contribution
275:                 }
276:                 // Calculate squared error for this sample
277:                 let error = sample.labValue - predictedLevel
278:                 sumSquaredError += error * error
279:             }
280:             return sumSquaredError
281:         }
282:         // Gradient descent parameters
283:         let learningRate = 0.01
284:         let iterations = 100
285:         let earlyStopThreshold = 0.0001
286:         // Perform gradient descent optimization
287:         for _ in 0..&lt;iterations {
288:             let baseError = calculateError(ke: currentKe, ka: currentKa)
289:             // Calculate gradient for ke
290:             let keStep = currentKe * 0.01
291:             let keGradient = (calculateError(ke: currentKe + keStep, ka: currentKa) - baseError) / keStep
292:             // Calculate gradient for ka
293:             let kaStep = currentKa * 0.01
294:             let kaGradient = (calculateError(ke: currentKe, ka: currentKa + kaStep) - baseError) / kaStep
295:             // Update parameters
296:             currentKe -= learningRate * keGradient
297:             currentKa -= learningRate * kaGradient
298:             // Keep parameters within bounds
299:             currentKe = max(keMin, min(keMax, currentKe))
300:             currentKa = max(kaMin, min(kaMax, currentKa))
301:             // Check if this is the best result so far
302:             let currentError = calculateError(ke: currentKe, ka: currentKa)
303:             if currentError &lt; bestError {
304:                 bestError = currentError
305:                 bestKe = currentKe
306:                 bestKa = currentKa
307:             }
308:             // Early stopping if improvement is minimal
309:             if abs(baseError - currentError) &lt; earlyStopThreshold {
310:                 break
311:             }
312:         }
313:         // Calculate correlation coefficient
314:         let correlation = calculateCorrelation(
315:             ke: bestKe,
316:             ka: bestKa,
317:             samples: samples,
318:             injectionDates: injectionDates,
319:             dose: dose,
320:             bioavailability: bioavailability,
321:             weight: weight
322:         )
323:         return CalibrationResult(
324:             adjustedKe: bestKe,
325:             adjustedKa: bestKa,
326:             originalKe: originalKe,
327:             originalKa: originalKa,
328:             halfLifeDays: log(2) / bestKe,
329:             correlation: correlation,
330:             samples: samples
331:         )
332:     }
333:     /// Calculate correlation between observed and predicted values
334:     private func calculateCorrelation(
335:         ke: Double,
336:         ka: Double,
337:         samples: [SamplePoint],
338:         injectionDates: [Date],
339:         dose: Double,
340:         bioavailability: Double,
341:         weight: Double
342:     ) -&gt; Double {
343:         // Calculate predicted values
344:         var observed: [Double] = []
345:         var predicted: [Double] = []
346:         for sample in samples {
347:             observed.append(sample.labValue)
348:             var predictedLevel = 0.0
349:             for injectionDate in injectionDates {
350:                 guard injectionDate &lt;= sample.timestamp else { continue }
351:                 let timeDiffDays = sample.timestamp.timeIntervalSince(injectionDate) / (24 * 3600)
352:                 guard timeDiffDays &gt;= 0 else { continue }
353:                 let vd = PKModel.defaultVolumeOfDistribution70kg * pow(weight / 70.0, 1.0)
354:                 if abs(ka - ke) &lt; 0.001 {
355:                     // For very close ka and ke, use bolus approximation
356:                     let initialConcentration = (dose * bioavailability) / vd
357:                     predictedLevel += initialConcentration * exp(-ke * timeDiffDays)
358:                 } else {
359:                     let factor = (dose * bioavailability * ka) / (vd * (ka - ke))
360:                     predictedLevel += factor * (exp(-ke * timeDiffDays) - exp(-ka * timeDiffDays))
361:                 }
362:             }
363:             predicted.append(predictedLevel)
364:         }
365:         // Calculate means
366:         let observedMean = observed.reduce(0.0, +) / Double(observed.count)
367:         let predictedMean = predicted.reduce(0.0, +) / Double(predicted.count)
368:         // Calculate Pearson correlation coefficient
369:         var numerator = 0.0
370:         var observedDenominator = 0.0
371:         var predictedDenominator = 0.0
372:         for i in 0..&lt;observed.count {
373:             let observedDiff = observed[i] - observedMean
374:             let predictedDiff = predicted[i] - predictedMean
375:             numerator += observedDiff * predictedDiff
376:             observedDenominator += observedDiff * observedDiff
377:             predictedDenominator += predictedDiff * predictedDiff
378:         }
379:         let denominator = sqrt(observedDenominator * predictedDenominator)
380:         // Protect against division by zero
381:         guard denominator &gt; 0 else { return 0.0 }
382:         return numerator / denominator
383:     }
384:     // MARK: - Time to Peak and Maximum Concentration
385:     /// Calculate the time to peak concentration for a given dose
386:     /// - Parameters:
387:     ///   - dose: Dose in mg
388:     ///   - halfLifeDays: Half-life in days
389:     ///   - absorptionRateKa: Absorption rate constant (ka) in d⁻¹
390:     ///   - bioavailability: Fraction of drug absorbed (0-1)
391:     ///   - weight: Patient weight in kg (for allometric scaling)
392:     ///   - calibrationFactor: User-specific calibration factor
393:     /// - Returns: Time to peak concentration in days
394:     func calculateTimeToMaxConcentration(
395:         dose: Double,
396:         halfLifeDays: Double,
397:         absorptionRateKa: Double,
398:         bioavailability: Double = 1.0,
399:         weight: Double = 70.0,
400:         calibrationFactor: Double = 1.0
401:     ) -&gt; Double {
402:         // Skip calculation if impossible parameters
403:         guard halfLifeDays &gt; 0 &amp;&amp; absorptionRateKa &gt; 0 else { return 0 }
404:         // Elimination rate constant (ke) = ln(2)/t_1/2
405:         let ke = log(2) / halfLifeDays
406:         // For one-compartment model with first-order absorption,
407:         // Tp = ln(ka/ke) / (ka - ke)
408:         // This is derived by setting the derivative of the concentration equation to zero
409:         guard absorptionRateKa &gt; ke else {
410:             // If ka &lt;= ke, then Tp is effectively 0 (immediate peak for IV bolus)
411:             return 0
412:         }
413:         // For two-compartment model, need numerical approach to find Tp
414:         // This is a simplified approximation - would use a more sophisticated
415:         // numerical method in a full implementation
416:         // Calculate alpha and beta for two-compartment model
417:         let beta = 0.5 * ((k12 + k21 + ke) - sqrt(pow(k12 + k21 + ke, 2) - 4 * k21 * ke))
418:         let _ = (k21 * ke) / beta
419:         // Approximate Tp using numerical search (rough estimate)
420:         var bestTime = 0.0
421:         var maxConc = 0.0
422:         // Search from 0 to about 5 half-lives with small steps
423:         let searchEnd = 5 * halfLifeDays
424:         let step = halfLifeDays / 50.0
425:         for t in stride(from: 0, through: searchEnd, by: step) {
426:             let conc = concentration(
427:                 at: t,
428:                 dose: dose,
429:                 halfLifeDays: halfLifeDays,
430:                 absorptionRateKa: absorptionRateKa,
431:                 bioavailability: bioavailability,
432:                 weight: weight,
433:                 calibrationFactor: calibrationFactor
434:             )
435:             if conc &gt; maxConc {
436:                 maxConc = conc
437:                 bestTime = t
438:             }
439:         }
440:         return bestTime
441:     }
442:     /// Calculate the maximum concentration for a given dose
443:     /// - Parameters:
444:     ///   - dose: Dose in mg
445:     ///   - halfLifeDays: Half-life in days
446:     ///   - absorptionRateKa: Absorption rate constant (ka) in d⁻¹
447:     ///   - bioavailability: Fraction of drug absorbed (0-1)
448:     ///   - weight: Patient weight in kg (for allometric scaling)
449:     ///   - calibrationFactor: User-specific calibration factor
450:     /// - Returns: Maximum concentration
451:     func calculateMaxConcentration(
452:         dose: Double,
453:         halfLifeDays: Double,
454:         absorptionRateKa: Double,
455:         bioavailability: Double = 1.0,
456:         weight: Double = 70.0,
457:         calibrationFactor: Double = 1.0
458:     ) -&gt; Double {
459:         // Calculate time to peak
460:         let tp = calculateTimeToMaxConcentration(
461:             dose: dose,
462:             halfLifeDays: halfLifeDays,
463:             absorptionRateKa: absorptionRateKa,
464:             bioavailability: bioavailability,
465:             weight: weight,
466:             calibrationFactor: calibrationFactor
467:         )
468:         // Calculate concentration at time to peak
469:         return concentration(
470:             at: tp,
471:             dose: dose,
472:             halfLifeDays: halfLifeDays,
473:             absorptionRateKa: absorptionRateKa,
474:             bioavailability: bioavailability,
475:             weight: weight,
476:             calibrationFactor: calibrationFactor
477:         )
478:     }
479:     /// Calculate the time to peak and maximum concentration for a blend
480:     /// - Parameters:
481:     ///   - components: Array of tuples containing (compound, dose)
482:     ///   - route: Administration route
483:     ///   - weight: Patient weight in kg
484:     ///   - calibrationFactor: User-specific calibration factor
485:     /// - Returns: Tuple containing (time to peak in days, max concentration)
486:     func calculateBlendPeakDetails(
487:         components: [(compound: Compound, doseMg: Double)],
488:         route: Compound.Route,
489:         weight: Double = 70.0,
490:         calibrationFactor: Double = 1.0
491:     ) -&gt; (timeToMaxDays: Double, maxConcentration: Double) {
492:         // For blends, we need to do a numerical search to find overall Tp and Cmax
493:         // as different components will peak at different times
494:         // Search time range (0 to 30 days should cover most scenarios)
495:         let searchEnd = 30.0
496:         let step = 0.1 // Refine step size for better precision
497:         var maxConc = 0.0
498:         var maxTime = 0.0
499:         for t in stride(from: 0, through: searchEnd, by: step) {
500:             let conc = blendConcentration(
501:                 at: t,
502:                 components: components,
503:                 route: route,
504:                 weight: weight,
505:                 calibrationFactor: calibrationFactor
506:             )
507:             if conc &gt; maxConc {
508:                 maxConc = conc
509:                 maxTime = t
510:             }
511:         }
512:         return (timeToMaxDays: maxTime, maxConcentration: maxConc)
513:     }
514:     /// Calculate peak details for a protocol (multiple injections)
515:     /// - Parameters:
516:     ///   - injectionDates: Dates of all injections
517:     ///   - compounds: Array of tuples containing (compound, dose per injection)
518:     ///   - route: Administration route
519:     ///   - timeWindow: Date range to search for peak
520:     ///   - weight: Patient weight in kg
521:     ///   - calibrationFactor: User-specific calibration factor
522:     /// - Returns: Tuple containing (peak date, max concentration)
523:     func calculateProtocolPeakDetails(
524:         injectionDates: [Date],
525:         compounds: [(compound: Compound, dosePerInjectionMg: Double)],
526:         route: Compound.Route,
527:         timeWindow: (start: Date, end: Date),
528:         weight: Double = 70.0,
529:         calibrationFactor: Double = 1.0
530:     ) -&gt; (peakDate: Date, maxConcentration: Double) {
531:         // For multiple injections, we need to search the entire time window
532:         let totalHours = timeWindow.end.timeIntervalSince(timeWindow.start) / 3600
533:         let step = 6.0 // 6-hour steps for reasonable precision
534:         var maxConc = 0.0
535:         var maxDate = timeWindow.start
536:         // Generate timepoints to evaluate
537:         var timePoints: [Date] = []
538:         for hour in stride(from: 0, through: totalHours, by: step) {
539:             let date = timeWindow.start.addingTimeInterval(hour * 3600)
540:             timePoints.append(date)
541:         }
542:         // Calculate concentrations at each timepoint
543:         let concentrations = protocolConcentrations(
544:             at: timePoints,
545:             injectionDates: injectionDates,
546:             compounds: compounds,
547:             route: route,
548:             weight: weight,
549:             calibrationFactor: calibrationFactor
550:         )
551:         // Find the maximum
552:         for (index, conc) in concentrations.enumerated() {
553:             if conc &gt; maxConc {
554:                 maxConc = conc
555:                 maxDate = timePoints[index]
556:             }
557:         }
558:         return (peakDate: maxDate, maxConcentration: maxConc)
559:     }
560: }

================
File: TestoSim/Views/ProfileView.swift
================
  1: import SwiftUI
  2: struct ProfileView: View {
  3:     @EnvironmentObject var dataStore: AppDataStore
  4:     @State private var dobString: String = &quot;&quot;
  5:     @State private var showingNotificationSettings = false
  6:     @State private var showingInjectionHistory = false
  7:     @State private var showingModelInfo = false
  8:     @State private var showingAllometricInfo = false
  9:     var body: some View {
 10:         Form {
 11:             Section(&quot;User&quot;) {
 12:                 TextField(&quot;Name&quot;, text: $dataStore.profile.name)
 13:                 Picker(&quot;Biological Sex&quot;, selection: $dataStore.profile.biologicalSex) {
 14:                     Text(&quot;Male&quot;).tag(UserProfile.BiologicalSex.male)
 15:                     Text(&quot;Female&quot;).tag(UserProfile.BiologicalSex.female)
 16:                 }
 17:                 DatePicker(
 18:                     &quot;Date of Birth&quot;,
 19:                     selection: Binding(
 20:                         get: { dataStore.profile.dateOfBirth ?? Date() },
 21:                         set: { dataStore.profile.dateOfBirth = $0 }
 22:                     ),
 23:                     displayedComponents: .date
 24:                 )
 25:                 if let age = dataStore.profile.age {
 26:                     Text(&quot;Age: \(age) years&quot;)
 27:                         .foregroundColor(.secondary)
 28:                 }
 29:             }
 30:             Section(&quot;Physical Measurements&quot;) {
 31:                 HStack {
 32:                     Text(&quot;Height&quot;)
 33:                     Spacer()
 34:                     TextField(&quot;Height&quot;, value: Binding(
 35:                         get: { dataStore.profile.heightCm ?? 0 },
 36:                         set: { dataStore.profile.heightCm = $0 &gt; 0 ? $0 : nil }
 37:                     ), format: .number)
 38:                     .keyboardType(.decimalPad)
 39:                     .multilineTextAlignment(.trailing)
 40:                     .frame(width: 80)
 41:                     Text(&quot;cm&quot;)
 42:                         .foregroundColor(.secondary)
 43:                 }
 44:                 HStack {
 45:                     Text(&quot;Weight&quot;)
 46:                     Spacer()
 47:                     TextField(&quot;Weight&quot;, value: Binding(
 48:                         get: { dataStore.profile.weight ?? 0 },
 49:                         set: { dataStore.profile.weight = $0 &gt; 0 ? $0 : nil }
 50:                     ), format: .number)
 51:                     .keyboardType(.decimalPad)
 52:                     .multilineTextAlignment(.trailing)
 53:                     .frame(width: 80)
 54:                     Text(&quot;kg&quot;)
 55:                         .foregroundColor(.secondary)
 56:                 }
 57:                 if let bsa = dataStore.profile.bodySurfaceArea {
 58:                     Text(&quot;Body Surface Area: \(bsa, specifier: &quot;%.2f&quot;) m²&quot;)
 59:                         .foregroundColor(.secondary)
 60:                 }
 61:                 Button {
 62:                     showingAllometricInfo = true
 63:                 } label: {
 64:                     HStack {
 65:                         Image(systemName: &quot;scalemass&quot;)
 66:                             .frame(width: 25, height: 25)
 67:                             .foregroundColor(.blue)
 68:                         Text(&quot;How physical measurements improve accuracy&quot;)
 69:                         Spacer()
 70:                         Image(systemName: &quot;chevron.right&quot;)
 71:                             .foregroundColor(.gray)
 72:                     }
 73:                 }
 74:                 .sheet(isPresented: $showingAllometricInfo) {
 75:                     AllometricInfoView()
 76:                 }
 77:             }
 78:             Section(&quot;Notifications &amp; Adherence&quot;) {
 79:                 Button {
 80:                     showingNotificationSettings = true
 81:                 } label: {
 82:                     HStack {
 83:                         Image(systemName: &quot;bell&quot;)
 84:                             .frame(width: 25, height: 25)
 85:                             .foregroundColor(.blue)
 86:                         Text(&quot;Notification Settings&quot;)
 87:                         Spacer()
 88:                         Image(systemName: &quot;chevron.right&quot;)
 89:                             .foregroundColor(.gray)
 90:                     }
 91:                 }
 92:                 Button {
 93:                     showingInjectionHistory = true
 94:                 } label: {
 95:                     HStack {
 96:                         Image(systemName: &quot;list.clipboard&quot;)
 97:                             .frame(width: 25, height: 25)
 98:                             .foregroundColor(.blue)
 99:                         Text(&quot;Injection History&quot;)
100:                         Spacer()
101:                         Image(systemName: &quot;chevron.right&quot;)
102:                             .foregroundColor(.gray)
103:                     }
104:                 }
105:                 // Show adherence rate if we have any data
106:                 if dataStore.adherenceStats().total &gt; 0 {
107:                     HStack {
108:                         Text(&quot;Adherence Rate:&quot;)
109:                         Spacer()
110:                         Text(String(format: &quot;%.1f%%&quot;, dataStore.adherencePercentage()))
111:                             .fontWeight(.bold)
112:                     }
113:                 }
114:             }
115:             Section(&quot;Settings&quot;) {
116:                 Picker(&quot;Preferred Unit&quot;, selection: $dataStore.profile.unit) {
117:                     Text(&quot;ng/dL&quot;).tag(&quot;ng/dL&quot;)
118:                     Text(&quot;nmol/L&quot;).tag(&quot;nmol/L&quot;)
119:                 }
120:                 Toggle(&quot;Use iCloud Sync&quot;, isOn: $dataStore.profile.usesICloudSync)
121:                 HStack {
122:                     Text(&quot;Advanced PK Model&quot;)
123:                     Spacer()
124:                     Text(&quot;Enabled&quot;)
125:                         .foregroundColor(.secondary)
126:                     Button {
127:                         showingModelInfo = true
128:                     } label: {
129:                         Image(systemName: &quot;info.circle&quot;)
130:                             .foregroundColor(.blue)
131:                     }
132:                     .buttonStyle(BorderlessButtonStyle())
133:                 }
134:                 .alert(&quot;Advanced PK Model&quot;, isPresented: $showingModelInfo) {
135:                     Button(&quot;OK&quot;, role: .cancel) { }
136:                 } message: {
137:                     Text(&quot;The app uses a two-compartment pharmacokinetic model that provides accurate concentration predictions, especially for long-acting compounds. Modern devices can easily handle this advanced calculation model.&quot;)
138:                 }
139:             }
140:             Section(&quot;Calibration&quot;) {
141:                 Text(&quot;Model Calibration Factor: \(dataStore.profile.calibrationFactor.formatted(.number.precision(.fractionLength(2))))&quot;)
142:                 Button(&quot;Reset Calibration to 1.0&quot;) {
143:                     dataStore.profile.calibrationFactor = 1.0
144:                     dataStore.recalcSimulation()
145:                     dataStore.saveProfile()
146:                 }
147:             }
148:         }
149:         .navigationTitle(&quot;Profile Settings&quot;)
150:         .onDisappear {
151:             dataStore.saveProfile()
152:         }
153:         .sheet(isPresented: $showingNotificationSettings) {
154:             NotificationSettingsView()
155:                 .environmentObject(dataStore)
156:         }
157:         .sheet(isPresented: $showingInjectionHistory) {
158:             InjectionHistoryView()
159:                 .environmentObject(dataStore)
160:         }
161:     }
162: }
163: struct AllometricInfoView: View {
164:     @Environment(\.dismiss) private var dismiss
165:     var body: some View {
166:         NavigationStack {
167:             ScrollView {
168:                 VStack(alignment: .leading, spacing: 16) {
169:                     Group {
170:                         Text(&quot;How Your Measurements Improve Accuracy&quot;)
171:                             .font(.title)
172:                             .fontWeight(.bold)
173:                             .padding(.bottom, 6)
174:                         Text(&quot;TestoSim uses allometric scaling to personalize pharmacokinetic predictions based on your physical measurements.&quot;)
175:                             .font(.headline)
176:                             .padding(.bottom, 6)
177:                         Text(&quot;What is Allometric Scaling?&quot;)
178:                             .font(.title2)
179:                             .fontWeight(.bold)
180:                         Text(&quot;Allometric scaling is a scientific approach that accounts for how drug metabolism and distribution scales with body size. People with different body sizes process medications differently.&quot;)
181:                         HStack {
182:                             Image(systemName: &quot;chart.line.uptrend.xyaxis&quot;)
183:                                 .font(.largeTitle)
184:                                 .foregroundColor(.blue)
185:                                 .padding()
186:                             VStack(alignment: .leading) {
187:                                 Text(&quot;Volume of Distribution&quot;)
188:                                     .fontWeight(.bold)
189:                                 Text(&quot;Vd(user) = Vd(70kg) × (Weight/70)¹·⁰&quot;)
190:                                 Text(&quot;How your bodyweight affects how widely the compound distributes throughout your body.&quot;)
191:                                     .font(.caption)
192:                                     .foregroundColor(.secondary)
193:                             }
194:                         }
195:                         .padding()
196:                         .background(Color.gray.opacity(0.1))
197:                         .cornerRadius(8)
198:                         HStack {
199:                             Image(systemName: &quot;waveform.path.ecg&quot;)
200:                                 .font(.largeTitle)
201:                                 .foregroundColor(.blue)
202:                                 .padding()
203:                             VStack(alignment: .leading) {
204:                                 Text(&quot;Clearance Rate&quot;)
205:                                     .fontWeight(.bold)
206:                                 Text(&quot;CL(user) = CL(70kg) × (Weight/70)⁰·⁷⁵&quot;)
207:                                 Text(&quot;How your bodyweight affects how quickly your body eliminates the compound.&quot;)
208:                                     .font(.caption)
209:                                     .foregroundColor(.secondary)
210:                             }
211:                         }
212:                         .padding()
213:                         .background(Color.gray.opacity(0.1))
214:                         .cornerRadius(8)
215:                     }
216:                     Group {
217:                         Text(&quot;Benefits of Providing Your Measurements&quot;)
218:                             .font(.title2)
219:                             .fontWeight(.bold)
220:                             .padding(.top)
221:                         VStack(alignment: .leading, spacing: 8) {
222:                             Label(&quot;More accurate peak and trough predictions&quot;, systemImage: &quot;checkmark.circle&quot;)
223:                             Label(&quot;Better timing recommendations for blood tests&quot;, systemImage: &quot;checkmark.circle&quot;)
224:                             Label(&quot;More precise dosing guidance&quot;, systemImage: &quot;checkmark.circle&quot;)
225:                             Label(&quot;Personalized pharmacokinetic calculations&quot;, systemImage: &quot;checkmark.circle&quot;)
226:                         }
227:                         .padding(.leading)
228:                         Text(&quot;Scientific Basis&quot;)
229:                             .font(.title2)
230:                             .fontWeight(.bold)
231:                             .padding(.top)
232:                         Text(&quot;This approach is based on peer-reviewed research on how testosterone pharmacokinetics vary with body size. The scaling exponents (1.0 for volume, 0.75 for clearance) are derived from population studies.&quot;)
233:                         Text(&quot;TestoSim applies these principles to all compounds in the library to provide you with the most accurate predictions possible.&quot;)
234:                     }
235:                 }
236:                 .padding()
237:             }
238:             .toolbar {
239:                 ToolbarItem(placement: .navigationBarTrailing) {
240:                     Button(&quot;Done&quot;) {
241:                         dismiss()
242:                     }
243:                 }
244:             }
245:             .navigationBarTitleDisplayMode(.inline)
246:         }
247:     }
248: }
249: #Preview {
250:     NavigationStack {
251:         ProfileView()
252:             .environmentObject(AppDataStore())
253:     }
254: }

================
File: TestoSim/Views/ProtocolFormView.swift
================
  1: import SwiftUI
  2: struct ProtocolFormView: View {
  3:     @EnvironmentObject var dataStore: AppDataStore
  4:     @Environment(\.dismiss) var dismiss
  5:     var protocolToEdit: InjectionProtocol?
  6:     // MARK: - State variables
  7:     @State private var name: String = &quot;&quot;
  8:     @State private var doseMg: String = &quot;&quot;
  9:     @State private var frequencyDays: String = &quot;&quot;
 10:     @State private var startDate: Date = Date()
 11:     @State private var notes: String = &quot;&quot;
 12:     // Protocol type and selection variables
 13:     @State private var protocolType: ProtocolType = .compound
 14:     @State private var selectedCompoundID: UUID?
 15:     @State private var selectedBlendID: UUID?
 16:     @State private var selectedRoute: Compound.Route = .intramuscular
 17:     // Sheet presentation flags
 18:     @State private var showingCompoundPicker = false
 19:     @State private var showingBlendPicker = false
 20:     var isEditing: Bool {
 21:         protocolToEdit != nil
 22:     }
 23:     var selectedCompoundName: String {
 24:         if let id = selectedCompoundID,
 25:            let compound = dataStore.compoundLibrary.compound(withID: id) {
 26:             return compound.fullDisplayName
 27:         }
 28:         return &quot;Select Compound&quot;
 29:     }
 30:     var selectedBlendName: String {
 31:         if let id = selectedBlendID,
 32:            let blend = dataStore.compoundLibrary.blend(withID: id) {
 33:             return blend.name
 34:         }
 35:         return &quot;Select Blend&quot;
 36:     }
 37:     var body: some View {
 38:         NavigationView {
 39:             Form {
 40:                 Section(header: Text(&quot;Protocol Details&quot;)) {
 41:                     TextField(&quot;Name&quot;, text: $name)
 42:                     // Protocol Type Selector
 43:                     Picker(&quot;Type&quot;, selection: $protocolType) {
 44:                         Text(&quot;Compound&quot;).tag(ProtocolType.compound)
 45:                         Text(&quot;Blend&quot;).tag(ProtocolType.blend)
 46:                     }
 47:                     .pickerStyle(SegmentedPickerStyle())
 48:                     .onChange(of: protocolType) { oldValue, newValue in
 49:                         // Reset selection when changing type
 50:                         if protocolType != .compound {
 51:                             selectedCompoundID = nil
 52:                         }
 53:                         if protocolType != .blend {
 54:                             selectedBlendID = nil
 55:                         }
 56:                     }
 57:                     // Dynamically show the appropriate selection UI based on protocol type
 58:                     switch protocolType {
 59:                     case .compound:
 60:                         Button(action: {
 61:                             showingCompoundPicker = true
 62:                         }) {
 63:                             HStack {
 64:                                 Text(&quot;Compound&quot;)
 65:                                 Spacer()
 66:                                 Text(selectedCompoundName)
 67:                                     .foregroundColor(.secondary)
 68:                                 Image(systemName: &quot;chevron.right&quot;)
 69:                                     .foregroundColor(.secondary)
 70:                                     .font(.caption)
 71:                             }
 72:                         }
 73:                         // Show route picker if compound is selected
 74:                         if selectedCompoundID != nil,
 75:                            let compound = dataStore.compoundLibrary.compound(withID: selectedCompoundID!) {
 76:                             // Filter routes to only those supported by the compound
 77:                             let supportedRoutes = compound.defaultBioavailability.keys.filter { 
 78:                                 (compound.defaultBioavailability[$0] ?? 0) &gt; 0 
 79:                             }
 80:                             if !supportedRoutes.isEmpty {
 81:                                 Picker(&quot;Administration Route&quot;, selection: $selectedRoute) {
 82:                                     ForEach(supportedRoutes.sorted(by: { $0.rawValue &lt; $1.rawValue }), id: \.self) { route in
 83:                                         Text(route.displayName).tag(route)
 84:                                     }
 85:                                 }
 86:                                 .onChange(of: selectedRoute) { oldValue, newRoute in
 87:                                     // Ensure the route is valid for this compound
 88:                                     if let compound = dataStore.compoundLibrary.compound(withID: selectedCompoundID!),
 89:                                        (compound.defaultBioavailability[newRoute] ?? 0) &lt;= 0 {
 90:                                         // If invalid, pick the first supported route
 91:                                         if let firstValid = compound.defaultBioavailability.keys.first {
 92:                                             selectedRoute = firstValid
 93:                                         }
 94:                                     }
 95:                                 }
 96:                             }
 97:                         }
 98:                     case .blend:
 99:                         Button(action: {
100:                             showingBlendPicker = true
101:                         }) {
102:                             HStack {
103:                                 Text(&quot;Vial Blend&quot;)
104:                                 Spacer()
105:                                 Text(selectedBlendName)
106:                                     .foregroundColor(.secondary)
107:                                 Image(systemName: &quot;chevron.right&quot;)
108:                                     .foregroundColor(.secondary)
109:                                     .font(.caption)
110:                             }
111:                         }
112:                         // For blends, always default to intramuscular
113:                         Picker(&quot;Administration Route&quot;, selection: $selectedRoute) {
114:                             Text(&quot;Intramuscular (IM)&quot;).tag(Compound.Route.intramuscular)
115:                         }
116:                     }
117:                     #if os(iOS)
118:                     TextField(&quot;Dose (mg)&quot;, text: $doseMg)
119:                         .keyboardType(.decimalPad)
120:                     #else
121:                     TextField(&quot;Dose (mg)&quot;, text: $doseMg)
122:                     #endif
123:                     #if os(iOS)
124:                     TextField(&quot;Frequency (days)&quot;, text: $frequencyDays)
125:                         .keyboardType(.decimalPad)
126:                     #else
127:                     TextField(&quot;Frequency (days)&quot;, text: $frequencyDays)
128:                     #endif
129:                     DatePicker(&quot;Start Date&quot;, selection: $startDate, displayedComponents: [.date])
130:                 }
131:                 Section(header: Text(&quot;Notes&quot;)) {
132:                     TextEditor(text: $notes)
133:                         .frame(height: 100)
134:                 }
135:             }
136:             .navigationTitle(isEditing ? &quot;Edit Protocol&quot; : &quot;New Protocol&quot;)
137:             .toolbar {
138:                 ToolbarItem(placement: .cancellationAction) {
139:                     Button(&quot;Cancel&quot;) {
140:                         dismiss()
141:                     }
142:                 }
143:                 ToolbarItem(placement: .confirmationAction) {
144:                     Button(isEditing ? &quot;Update&quot; : &quot;Add&quot;) {
145:                         saveProtocol()
146:                     }
147:                     .disabled(!isValid)
148:                 }
149:             }
150:             .onAppear {
151:                 if let protocolToEdit = protocolToEdit {
152:                     // Fill form with existing protocol data
153:                     name = protocolToEdit.name
154:                     // Determine which protocol type we&apos;re editing
155:                     protocolType = protocolToEdit.protocolType
156:                     selectedCompoundID = protocolToEdit.compoundID
157:                     selectedBlendID = protocolToEdit.blendID
158:                     // Set route if available
159:                     if let routeString = protocolToEdit.selectedRoute,
160:                        let route = Compound.Route(rawValue: routeString) {
161:                         selectedRoute = route
162:                     } else {
163:                         selectedRoute = .intramuscular // Default
164:                     }
165:                     doseMg = String(format: &quot;%.1f&quot;, protocolToEdit.doseMg)
166:                     frequencyDays = String(format: &quot;%.1f&quot;, protocolToEdit.frequencyDays)
167:                     startDate = protocolToEdit.startDate
168:                     notes = protocolToEdit.notes ?? &quot;&quot;
169:                 }
170:             }
171:             .sheet(isPresented: $showingCompoundPicker) {
172:                 CompoundListView(selectedCompoundID: $selectedCompoundID)
173:                     .environmentObject(dataStore)
174:             }
175:             .sheet(isPresented: $showingBlendPicker) {
176:                 VialBlendListView(selectedBlendID: $selectedBlendID)
177:                     .environmentObject(dataStore)
178:             }
179:         }
180:     }
181:     private var isValid: Bool {
182:         // Basic validation
183:         guard !name.isEmpty &amp;&amp; Double(doseMg) != nil &amp;&amp; Double(frequencyDays) != nil else {
184:             return false
185:         }
186:         // Type-specific validation
187:         switch protocolType {
188:         case .compound:
189:             return selectedCompoundID != nil
190:         case .blend:
191:             return selectedBlendID != nil
192:         }
193:     }
194:     private func saveProtocol() {
195:         guard let doseValue = Double(doseMg),
196:               let frequencyValue = Double(frequencyDays) else {
197:             return
198:         }
199:         if isEditing, let protocolToEdit = protocolToEdit {
200:             var updatedProtocol = protocolToEdit
201:             updatedProtocol.name = name
202:             updatedProtocol.doseMg = doseValue
203:             updatedProtocol.frequencyDays = frequencyValue
204:             updatedProtocol.startDate = startDate
205:             updatedProtocol.notes = notes.isEmpty ? nil : notes
206:             // Update the protocol type-specific properties
207:             switch protocolType {
208:             case .compound:
209:                 updatedProtocol.compoundID = selectedCompoundID
210:                 updatedProtocol.blendID = nil
211:                 updatedProtocol.selectedRoute = selectedRoute.rawValue
212:             case .blend:
213:                 updatedProtocol.compoundID = nil
214:                 updatedProtocol.blendID = selectedBlendID
215:                 updatedProtocol.selectedRoute = selectedRoute.rawValue
216:             }
217:             dataStore.updateProtocol(updatedProtocol)
218:         } else {
219:             var newProtocol = InjectionProtocol(
220:                 name: name,
221:                 doseMg: doseValue,
222:                 frequencyDays: frequencyValue,
223:                 startDate: startDate,
224:                 notes: notes.isEmpty ? nil : notes
225:             )
226:             // Set the protocol type-specific properties
227:             switch protocolType {
228:             case .compound:
229:                 newProtocol.compoundID = selectedCompoundID
230:                 newProtocol.selectedRoute = selectedRoute.rawValue
231:             case .blend:
232:                 newProtocol.blendID = selectedBlendID
233:                 newProtocol.selectedRoute = selectedRoute.rawValue
234:             }
235:             dataStore.addProtocol(newProtocol)
236:         }
237:         dismiss()
238:     }
239: }
240: #Preview {
241:     ProtocolFormView()
242:         .environmentObject(AppDataStore())
243: }

================
File: TestoSim/TestoSimApp.swift
================
 1: //
 2: //  TestoSimApp.swift
 3: //  TestoSim
 4: //
 5: //  Created by Jesper Vang on 01/05/2025.
 6: //
 7: import SwiftUI
 8: import CoreData
 9: #if os(iOS)
10: import UIKit
11: #elseif os(macOS)
12: import AppKit
13: #endif
14: @main
15: struct TestoSimApp: App {
16:     @StateObject private var dataStore = AppDataStore()
17:     // Create a reference to the Core Data manager
18:     private let coreDataManager = CoreDataManager.shared
19:     init() {
20:         print(&quot;TestoSim is starting up...&quot;)
21:         // Set up default API key settings if not already set
22:         if UserDefaults.standard.object(forKey: &quot;use_test_api_key&quot;) == nil {
23:             // Enable test API key by default for all users
24:             UserDefaults.standard.set(true, forKey: &quot;use_test_api_key&quot;)
25:             print(&quot;Default API key settings initialized: Using test key&quot;)
26:         }
27:     }
28:     var body: some Scene {
29:         WindowGroup {
30:             ContentView()
31:                 .environmentObject(dataStore)
32:                 .environment(\.managedObjectContext, coreDataManager.persistentContainer.viewContext)
33:                 #if os(iOS)
34:                 .onReceive(NotificationCenter.default.publisher(for: UIApplication.willResignActiveNotification)) { _ in
35:                     // Save when app moves to background
36:                     coreDataManager.saveContext()
37:                 }
38:                 #elseif os(macOS)
39:                 .onReceive(NotificationCenter.default.publisher(for: NSApplication.willResignActiveNotification)) { _ in
40:                     // Save when app moves to background
41:                     coreDataManager.saveContext()
42:                 }
43:                 #endif
44:         }
45:     }
46: }

================
File: .gitignore
================
  1: # Xcode
  2: #
  3: # gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore &amp; Swift.gitignore
  4: 
  5: ## User settings
  6: xcuserdata/
  7: 
  8: ## Compatibility with Xcode
  9: *.moved-aside
 10: *.xccheckout
 11: *.xcscmblueprint
 12: 
 13: ## Build generated
 14: build/
 15: DerivedData/
 16: 
 17: ## Various settings
 18: *.pbxuser
 19: !default.pbxuser
 20: *.mode1v3
 21: !default.mode1v3
 22: *.mode2v3
 23: !default.mode2v3
 24: *.perspectivev3
 25: !default.perspectivev3
 26: 
 27: ## Other
 28: *.moved-aside
 29: *.xcuserdata
 30: *.xcscmblueprint
 31: 
 32: ## Obj-C/Swift specific
 33: *.hmap
 34: *.ipa
 35: *.dSYM.zip
 36: *.dSYM
 37: 
 38: ## Playgrounds
 39: timeline.xctimeline
 40: playground.xcworkspace
 41: 
 42: # Swift Package Manager
 43: #
 44: # Add this line if you want to avoid checking in source code from Swift Package Manager dependencies.
 45: # Packages/
 46: # Package.pins
 47: # Package.resolved
 48: # *.xcodeproj
 49: #
 50: # Xcode automatically generates this directory with a .xcworkspacedata file and xcuserdata
 51: # hence it is not needed unless you have added a package configuration file to your project
 52: # .swiftpm
 53: 
 54: # CocoaPods
 55: #
 56: # We recommend against adding the Pods directory to your .gitignore. However
 57: # you should judge for yourself, the pros and cons are mentioned at:
 58: # https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control
 59: #
 60: # Pods/
 61: #
 62: # Add this line if you want to avoid checking in source code from the Xcode workspace
 63: # *.xcworkspace
 64: 
 65: # Carthage
 66: #
 67: # Add this line if you want to avoid checking in source code from Carthage dependencies.
 68: # Carthage/Checkouts
 69: 
 70: Carthage/Build/
 71: 
 72: # Accio dependency management
 73: Dependencies/
 74: .accio/
 75: 
 76: # fastlane
 77: #
 78: # It is recommended to not store the screenshots in the git repo.
 79: # Instead, use fastlane to re-generate the screenshots whenever they are needed.
 80: # For more information about the recommended setup visit:
 81: # https://docs.fastlane.tools/best-practices/source-control/#source-control
 82: 
 83: fastlane/report.xml
 84: fastlane/Preview.html
 85: fastlane/screenshots/**/*.png
 86: fastlane/test_output
 87: 
 88: # Code Injection
 89: #
 90: # After new code Injection tools there&apos;s a generated folder /iOSInjectionProject
 91: # https://github.com/johnno1962/injectionforxcode
 92: 
 93: iOSInjectionProject/
 94: 
 95: # macOS
 96: .DS_Store
 97: 
 98: # cursor
 99: .cursor/
100: 
101: # App specific
102: memory.jsonl 
103: .claude/
104: .repomix/
105: ai_docs/
106: specs/
107: 
108: # API Keys
109: TestoSim/Config.xcconfig
110: TestoSim/Config.plist

================
File: README.md
================
  1: # TestoSim
  2: 
  3: TestoSim is a testosterone pharmacokinetics simulation app that helps visualize injection protocols and predict hormone levels.
  4: 
  5: ## Recent Changes and Updates
  6: 
  7: ### Model Refinements (June 2024)
  8: - **Removed TestosteroneEster Model**: Simplified the codebase by removing the redundant TestosteroneEster model in favor of the more flexible Compound model
  9: - **Protocol Type Selection**: Protocols now clearly identify as either compound-based or blend-based
 10: - **CloudKit Integration**: Fixed container ID issues in CoreDataManager and improved iCloud sync stability
 11: - **UI Improvements**: Updated protocol creation process with a streamlined interface for compound and blend selection
 12: - **Calibration View Fixes**: Resolved compiler issues with CalibrationResultView and parameter naming conflicts
 13: - **Code Cleanup**: Fixed various Swift compiler warnings and improved view composition to avoid &quot;unable to type-check&quot; errors
 14: 
 15: The app now provides a more consistent experience when creating and managing protocols, with proper support for different compound types and routes of administration.
 16: 
 17: ## Simulator Management
 18: 
 19: To prevent issues with multiple simulator instances, use the following scripts:
 20: 
 21: ### Build Without Launching (Recommended)
 22: 
 23: ```bash
 24: ./build-test.sh [clean]
 25: ```
 26: 
 27: - Use this script to build the application without launching a simulator
 28: - Add `clean` parameter to perform a clean build
 29: - After building, use SweetPad to run the app in a simulator
 30: 
 31: ### Close All Simulators
 32: 
 33: ```bash
 34: ./close-simulators.sh
 35: ```
 36: 
 37: - Shuts down all running simulator instances
 38: - Use this if multiple simulators are running and causing issues
 39: 
 40: ### Launch in a Single Simulator
 41: 
 42: ```bash
 43: ./launch-test.sh [device_name]
 44: ```
 45: 
 46: - Builds, installs, and launches the app in a specified simulator
 47: - Defaults to &quot;iPhone 16&quot; if no device is specified
 48: - Example: `./launch-test.sh &quot;iPhone 16 Pro&quot;`
 49: - Automatically closes other simulators before launching
 50: 
 51: ## Development Workflow
 52: 
 53: For the best development experience:
 54: 
 55: 1. Use VS Code with SweetPad extension:
 56:    - Run task &quot;SweetPad: Build&quot; from the command palette (Cmd+Shift+P) or context menu
 57:    - This builds and runs the app in a single simulator instance
 58: 
 59: 2. For command-line builds:
 60:    - Use `./build-test.sh` to build without launching simulators
 61:    - Use `./close-simulators.sh` if you have multiple simulators running
 62: 
 63: 3. For testing specific issues:
 64:    - Use `./launch-test.sh` to launch in a specific simulator
 65:    - This helps isolate issues by using a clean, single simulator instance
 66: 
 67: ## Troubleshooting
 68: 
 69: If the app crashes during launch:
 70: 1. Close all simulators: `./close-simulators.sh`
 71: 2. Clean build: `./build-test.sh clean`
 72: 3. Launch with a specific device: `./launch-test.sh &quot;iPhone 16&quot;`
 73: 
 74: If errors still occur, check the device logs:
 75: ```bash
 76: xcrun simctl spawn booted log stream --predicate &apos;processImagePath contains &quot;TestoSim&quot;&apos; --style compact
 77: ```
 78: 
 79: ## CloudKit Integration
 80: 
 81: TestoSim uses CloudKit for cloud data synchronization across devices. This allows users to access their protocols, compounds, and bloodwork results on all their iOS devices.
 82: 
 83: ### Key Features
 84: 
 85: - User profiles, protocols, and bloodwork data synchronize across devices
 86: - Automatic conflict resolution and merging
 87: - Offline capability with sync when connectivity is restored
 88: 
 89: ### Implementation Details
 90: 
 91: - The app uses `NSPersistentCloudKitContainer` for Core Data + CloudKit integration
 92: - CloudKit sync can be toggled on/off in the app settings
 93: - Data is stored in the `iCloud.flight505.TestoSim` private database
 94: 
 95: ### Requirements
 96: 
 97: - User must be signed into iCloud on the device
 98: - iCloud Drive must be enabled
 99: - Proper entitlements are included in the app bundle
100: 
101: ### Troubleshooting CloudKit Sync
102: 
103: If data is not syncing properly:
104: 
105: 1. Verify the user is signed into iCloud: Settings &gt; Apple ID &gt; iCloud
106: 2. Check iCloud Drive is enabled
107: 3. In the app, toggle CloudKit sync off and back on
108: 4. Restart the app after changing sync settings for changes to take effect
109: 
110: ## Compound Selection
111: 
112: TestoSim uses a comprehensive system for selecting compounds:
113: 
114: ### Features
115: 
116: - **Compounds Library**: A full database of compounds with accurate pharmacokinetic parameters:
117:   - Testosterone esters (propionate, enanthate, cypionate, etc.)
118:   - Other compounds (nandrolone, trenbolone, boldenone, etc.)
119:   - Various administration routes (intramuscular, subcutaneous, oral, transdermal)
120: 
121: - **Vial Blends**: Support for commercial multi-compound blends:
122:   - Pre-defined blends like Sustanon 250/350
123:   - Each component tracked individually with proper pharmacokinetics
124: 
125: ### Implementation
126: 
127: - Compounds are modeled with class types, esters, half-lives, and route-specific parameters
128: - Complete absorption and bioavailability characteristics for each compound and route
129: - Accurate simulation of single compounds and complex blends 
130: 
131: ## API Key Configuration
132: 
133: The TestoSim app uses OpenAI&apos;s API for generating insights about hormone protocols and cycles. The app includes a free test API key with a $20 spending limit for all users.
134: 
135: ### For Developers
136: 
137: When cloning this repository for development:
138: 
139: 1. The app uses configuration files to store API keys:
140:    - `Config.xcconfig` - For build-time configuration
141:    - `Config.plist` - For runtime configuration
142:    
143: 2. Sample files with placeholders are included in the repository:
144:    - `Config-Sample.xcconfig`
145:    - `Config-Sample.plist`
146:    
147: 3. On first build, the script `copy-config.sh` will automatically copy the sample files to create the real config files if they don&apos;t exist.
148: 
149: 4. To set up your own API key:
150:    - Open `TestoSim/Config.plist`
151:    - Replace the placeholder value with your OpenAI API key
152:    - Clean and rebuild the project
153: 
154: ### Security Notes
155: 
156: - Both `Config.xcconfig` and `Config.plist` are excluded from git in `.gitignore`
157: - Users can toggle between using their own API key or the test API key in the AI settings
158: - The API key is never stored directly in the source code

================
File: TestoSim/ViewModels/OpenAIService.swift
================
  1: import Foundation
  2: import SwiftUI
  3: /// Service for handling OpenAI API requests
  4: class OpenAIService: ObservableObject {
  5:     // MARK: - Properties
  6:     /// Singleton instance
  7:     static let shared = OpenAIService()
  8:     /// OpenAI API endpoint
  9:     private let apiEndpoint = &quot;https://api.openai.com/v1/chat/completions&quot;
 10:     /// Test project API key with $20 spending limit (for test users)
 11:     private var testApiKey: String {
 12:         // Read the API key from Config.plist
 13:         if let path = Bundle.main.path(forResource: &quot;Config&quot;, ofType: &quot;plist&quot;),
 14:            let dict = NSDictionary(contentsOfFile: path),
 15:            let key = dict[&quot;OPENAI_API_KEY&quot;] as? String {
 16:             if key == &quot;PLACEHOLDER_API_KEY&quot; {
 17:                 // This is the placeholder value, log an error
 18:                 print(&quot;WARNING: Using placeholder API key. Please update Config.plist with a valid API key.&quot;)
 19:                 return &quot;&quot;
 20:             }
 21:             return key
 22:         }
 23:         // Fallback if key not found
 24:         print(&quot;ERROR: API key not found in Config.plist.&quot;)
 25:         return &quot;&quot;
 26:     }
 27:     /// Flag to determine if using test API key
 28:     @Published private(set) var isUsingTestKey = false
 29:     /// OpenAI API key
 30:     private var apiKey: String {
 31:         // If user has toggled to use the test key, return it
 32:         if isUsingTestKey {
 33:             return testApiKey
 34:         }
 35:         // Otherwise, get API key from UserDefaults or environment
 36:         let userKey = UserDefaults.standard.string(forKey: &quot;openai_api_key&quot;) ?? 
 37:                       ProcessInfo.processInfo.environment[&quot;OPENAI_API_KEY&quot;] ?? &quot;&quot;
 38:         // If no user key is available, fall back to the test key
 39:         return userKey.isEmpty ? testApiKey : userKey
 40:     }
 41:     /// The model to use for generating insights
 42:     private let model = &quot;gpt-4o-mini&quot; // Using the more cost-effective GPT-4o-mini model
 43:     // MARK: - Initialization
 44:     /// Private initializer to enforce singleton pattern
 45:     private init() {
 46:         // Check if test key should be used by default
 47:         self.isUsingTestKey = UserDefaults.standard.bool(forKey: &quot;use_test_api_key&quot;)
 48:     }
 49:     // MARK: - API Methods
 50:     /// Save the API key to UserDefaults
 51:     /// - Parameter key: The API key
 52:     func saveAPIKey(_ key: String) {
 53:         UserDefaults.standard.set(key, forKey: &quot;openai_api_key&quot;)
 54:         isUsingTestKey = false
 55:         UserDefaults.standard.set(false, forKey: &quot;use_test_api_key&quot;)
 56:     }
 57:     /// Check if an API key is available
 58:     /// - Returns: True if an API key is available, false otherwise
 59:     func hasAPIKey() -&gt; Bool {
 60:         return !apiKey.isEmpty
 61:     }
 62:     /// Clear the saved API key
 63:     func clearAPIKey() {
 64:         UserDefaults.standard.removeObject(forKey: &quot;openai_api_key&quot;)
 65:     }
 66:     /// Toggle between using the test API key and the user&apos;s API key
 67:     /// - Parameter useTestKey: Whether to use the test API key
 68:     func toggleTestApiKey(_ useTestKey: Bool) {
 69:         isUsingTestKey = useTestKey
 70:         UserDefaults.standard.set(useTestKey, forKey: &quot;use_test_api_key&quot;)
 71:     }
 72:     /// Generate protocol insights using the OpenAI API
 73:     /// - Parameters:
 74:     ///   - protocol: The protocol to analyze
 75:     ///   - profile: User profile information
 76:     ///   - simulationData: Pharmacokinetic simulation data
 77:     ///   - completion: Callback with the result
 78:     func generateProtocolInsights(
 79:         treatmentProtocol: InjectionProtocol,
 80:         profile: UserProfile,
 81:         simulationData: [DataPoint],
 82:         compoundLibrary: CompoundLibrary,
 83:         completion: @escaping (Result&lt;Insights, Error&gt;) -&gt; Void
 84:     ) {
 85:         // Build the chat message content
 86:         let content = buildProtocolPrompt(
 87:             treatmentProtocol: treatmentProtocol,
 88:             profile: profile,
 89:             simulationData: simulationData,
 90:             compoundLibrary: compoundLibrary
 91:         )
 92:         // Create the request
 93:         makeCompletionRequest(content: content) { result in
 94:             switch result {
 95:             case .success(let jsonResponse):
 96:                 do {
 97:                     // Parse the insights from the response
 98:                     let insights = try self.parseInsightsFromResponse(jsonResponse, forProtocol: treatmentProtocol)
 99:                     completion(.success(insights))
100:                 } catch {
101:                     completion(.failure(error))
102:                 }
103:             case .failure(let error):
104:                 completion(.failure(error))
105:             }
106:         }
107:     }
108:     /// Generate cycle insights using the OpenAI API
109:     /// - Parameters:
110:     ///   - cycle: The cycle to analyze
111:     ///   - profile: User profile information
112:     ///   - simulationData: Pharmacokinetic simulation data
113:     ///   - completion: Callback with the result
114:     func generateCycleInsights(
115:         cycle: Cycle,
116:         profile: UserProfile,
117:         simulationData: [DataPoint],
118:         compoundLibrary: CompoundLibrary,
119:         completion: @escaping (Result&lt;Insights, Error&gt;) -&gt; Void
120:     ) {
121:         // Build the chat message content
122:         let content = buildCyclePrompt(
123:             cycle: cycle,
124:             profile: profile,
125:             simulationData: simulationData,
126:             compoundLibrary: compoundLibrary
127:         )
128:         // Create the request
129:         makeCompletionRequest(content: content) { result in
130:             switch result {
131:             case .success(let jsonResponse):
132:                 do {
133:                     // Parse the insights from the response
134:                     let insights = try self.parseInsightsFromResponse(jsonResponse, forCycle: cycle)
135:                     completion(.success(insights))
136:                 } catch {
137:                     completion(.failure(error))
138:                 }
139:             case .failure(let error):
140:                 completion(.failure(error))
141:             }
142:         }
143:     }
144:     // MARK: - Private Methods
145:     /// Build the prompt for protocol insights
146:     private func buildProtocolPrompt(
147:         treatmentProtocol: InjectionProtocol,
148:         profile: UserProfile,
149:         simulationData: [DataPoint],
150:         compoundLibrary: CompoundLibrary
151:     ) -&gt; String {
152:         // Extract protocol details
153:         let protocolType = treatmentProtocol.protocolType
154:         let protocolName = treatmentProtocol.name
155:         var compoundOrBlendName = &quot;Unknown&quot;
156:         var compoundInfo = &quot;&quot;
157:         // Get compound or blend information
158:         if protocolType == .compound, let compoundID = treatmentProtocol.compoundID,
159:            let compound = compoundLibrary.compounds.first(where: { $0.id == compoundID }) {
160:             compoundOrBlendName = compound.commonName
161:             if let ester = compound.ester {
162:                 compoundOrBlendName += &quot; \(ester)&quot;
163:             }
164:             compoundInfo = &quot;&quot;&quot;
165:             Compound: \(compound.commonName)
166:             Ester: \(compound.ester ?? &quot;None&quot;)
167:             Half-life: \(compound.halfLifeDays) days
168:             &quot;&quot;&quot;
169:         } else if protocolType == .blend, let blendID = treatmentProtocol.blendID,
170:                   let blend = compoundLibrary.blends.first(where: { $0.id == blendID }) {
171:             compoundOrBlendName = blend.name
172:             compoundInfo = &quot;&quot;&quot;
173:             Blend: \(blend.name)
174:             Manufacturer: \(blend.manufacturer ?? &quot;Unknown&quot;)
175:             Components:
176:             &quot;&quot;&quot;
177:             // Add blend components
178:             let components = blend.resolvedComponents(using: compoundLibrary)
179:             for component in components {
180:                 compoundInfo += &quot;&quot;&quot;
181:                 - \(component.compound.commonName) \(component.compound.ester ?? &quot;&quot;)
182:                   Concentration: \(component.mgPerML) mg/mL
183:                   Half-life: \(component.compound.halfLifeDays) days
184:                 &quot;&quot;&quot;
185:             }
186:         }
187:         // Extract simulation statistics
188:         let maxLevel = simulationData.map { $0.level }.max() ?? 0
189:         let minLevel = simulationData.map { $0.level }.min() ?? 0
190:         let avgLevel = simulationData.map { $0.level }.reduce(0, +) / Double(max(1, simulationData.count))
191:         let fluctuation = maxLevel &gt; 0 ? (maxLevel - minLevel) / maxLevel * 100 : 0
192:         // Build the prompt
193:         return &quot;&quot;&quot;
194:         You are a specialized AI assistant for TestoSim, a hormone therapy simulation app. 
195:         Analyze the following protocol and simulation data, and provide insights in the specified JSON format.
196:         USER PROFILE:
197:         Weight: \(profile.weight ?? 0) kg
198:         Height: \(profile.heightCm ?? 0) cm
199:         Age: \(profile.age ?? 0)
200:         Biological sex: \(profile.biologicalSex.rawValue)
201:         PROTOCOL DETAILS:
202:         Name: \(protocolName)
203:         Type: \(protocolType.rawValue)
204:         \(compoundInfo)
205:         Dose: \(treatmentProtocol.doseMg) mg
206:         Frequency: Every \(treatmentProtocol.frequencyDays) days
207:         Route: \(treatmentProtocol.selectedRoute ?? &quot;intramuscular&quot;)
208:         SIMULATION STATISTICS:
209:         Average Level: \(avgLevel) ng/dL
210:         Maximum Level: \(maxLevel) ng/dL
211:         Minimum Level: \(minLevel) ng/dL
212:         Fluctuation: \(fluctuation)%
213:         BLOOD SAMPLES:
214:         \(treatmentProtocol.bloodSamples.map { &quot;Date: \($0.date), Value: \($0.value) \($0.unit)&quot; }.joined(separator: &quot;\n&quot;))
215:         Based on this information, provide insights about the protocol in the following JSON format:
216:         {
217:             &quot;title&quot;: &quot;Insights for [Protocol Name]&quot;,
218:             &quot;summary&quot;: &quot;A concise summary of the protocol analysis.&quot;,
219:             &quot;blendExplanation&quot;: &quot;Detailed explanation of what&apos;s in the blend and how it behaves over time (only for blend protocols, null otherwise).&quot;,
220:             &quot;keyPoints&quot;: [
221:                 {
222:                     &quot;title&quot;: &quot;Short, specific point title&quot;,
223:                     &quot;description&quot;: &quot;Detailed explanation of the point&quot;,
224:                     &quot;type&quot;: &quot;information|positive|warning|suggestion&quot;
225:                 }
226:             ]
227:         }
228:         Focus on practical insights about:
229:         1. Dosing frequency and stability
230:         2. Level fluctuations and their implications
231:         3. Potential optimizations to the protocol
232:         4. Educational content about the compounds or blend
233:         &quot;&quot;&quot;
234:     }
235:     /// Build the prompt for cycle insights
236:     private func buildCyclePrompt(
237:         cycle: Cycle,
238:         profile: UserProfile,
239:         simulationData: [DataPoint],
240:         compoundLibrary: CompoundLibrary
241:     ) -&gt; String {
242:         // Extract cycle details
243:         let cycleName = cycle.name
244:         let cycleStages = cycle.stages
245:         // Build stages information
246:         var stagesInfo = &quot;&quot;
247:         for (index, stage) in cycleStages.enumerated() {
248:             stagesInfo += &quot;&quot;&quot;
249:             Stage \(index + 1):
250:             Name: \(stage.name)
251:             Duration: \(stage.durationWeeks) weeks
252:             Start Week: \(stage.startWeek)
253:             &quot;&quot;&quot;
254:             // Add compounds in stage
255:             if !stage.compounds.isEmpty {
256:                 stagesInfo += &quot;\nCompounds:&quot;
257:                 for compound in stage.compounds {
258:                     stagesInfo += &quot;&quot;&quot;
259:                       - \(compound.compoundName)
260:                           Dose: \(compound.doseMg) mg
261:                           Frequency: Every \(compound.frequencyDays) days
262:                           Route: \(compound.administrationRoute)
263:                     &quot;&quot;&quot;
264:                 }
265:             }
266:             // Add blends in stage
267:             if !stage.blends.isEmpty {
268:                 stagesInfo += &quot;\nBlends:&quot;
269:                 for blend in stage.blends {
270:                     stagesInfo += &quot;&quot;&quot;
271:                       - \(blend.blendName)
272:                           Dose: \(blend.doseMg) mg
273:                           Frequency: Every \(blend.frequencyDays) days
274:                           Route: \(blend.administrationRoute)
275:                     &quot;&quot;&quot;
276:                 }
277:             }
278:         }
279:         // Extract simulation statistics
280:         let maxLevel = simulationData.map { $0.level }.max() ?? 0
281:         let minLevel = simulationData.map { $0.level }.min() ?? 0
282:         let avgLevel = simulationData.map { $0.level }.reduce(0, +) / Double(max(1, simulationData.count))
283:         let fluctuation = maxLevel &gt; 0 ? (maxLevel - minLevel) / maxLevel * 100 : 0
284:         // Build the prompt
285:         return &quot;&quot;&quot;
286:         You are a specialized AI assistant for TestoSim, a hormone therapy simulation app. 
287:         Analyze the following cycle and simulation data, and provide insights in the specified JSON format.
288:         USER PROFILE:
289:         Weight: \(profile.weight ?? 0) kg
290:         Height: \(profile.heightCm ?? 0) cm
291:         Age: \(profile.age ?? 0)
292:         Biological sex: \(profile.biologicalSex.rawValue)
293:         CYCLE DETAILS:
294:         Name: \(cycleName)
295:         Total Duration: \(cycle.totalWeeks) weeks
296:         \(stagesInfo)
297:         SIMULATION STATISTICS:
298:         Average Level: \(avgLevel) ng/dL
299:         Maximum Level: \(maxLevel) ng/dL
300:         Minimum Level: \(minLevel) ng/dL
301:         Fluctuation: \(fluctuation)%
302:         Based on this information, provide insights about the cycle in the following JSON format:
303:         {
304:             &quot;title&quot;: &quot;Insights for [Cycle Name]&quot;,
305:             &quot;summary&quot;: &quot;A concise summary of the cycle analysis.&quot;,
306:             &quot;stageBreakdown&quot;: [
307:                 {
308:                     &quot;stageNumber&quot;: 1,
309:                     &quot;analysis&quot;: &quot;Analysis of what&apos;s happening in this stage and why&quot;
310:                 }
311:             ],
312:             &quot;keyPoints&quot;: [
313:                 {
314:                     &quot;title&quot;: &quot;Short, specific point title&quot;,
315:                     &quot;description&quot;: &quot;Detailed explanation of the point&quot;,
316:                     &quot;type&quot;: &quot;information|positive|warning|suggestion&quot;
317:                 }
318:             ]
319:         }
320:         Focus on practical insights about:
321:         1. Stage progression and rationale
322:         2. Compound selection and synergies
323:         3. Level fluctuations and their implications
324:         4. Potential optimizations to the cycle
325:         5. Educational content about the compounds and how they work together
326:         &quot;&quot;&quot;
327:     }
328:     /// Make a completion request to the OpenAI API
329:     private func makeCompletionRequest(content: String, completion: @escaping (Result&lt;String, Error&gt;) -&gt; Void) {
330:         // Create URL
331:         guard let url = URL(string: apiEndpoint) else {
332:             completion(.failure(NSError(domain: &quot;OpenAIService&quot;, code: 0, userInfo: [NSLocalizedDescriptionKey: &quot;Invalid URL&quot;])))
333:             return
334:         }
335:         // Create request
336:         var request = URLRequest(url: url)
337:         request.httpMethod = &quot;POST&quot;
338:         request.addValue(&quot;Bearer \(apiKey)&quot;, forHTTPHeaderField: &quot;Authorization&quot;)
339:         request.addValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
340:         // Create request body
341:         let requestBody: [String: Any] = [
342:             &quot;model&quot;: model,
343:             &quot;messages&quot;: [
344:                 [&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are a specialized AI assistant for a hormone therapy simulation app. Provide insights in JSON format only.&quot;],
345:                 [&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: content]
346:             ],
347:             &quot;temperature&quot;: 0.3,
348:             &quot;max_tokens&quot;: 2000,
349:             &quot;response_format&quot;: [&quot;type&quot;: &quot;json_object&quot;]
350:         ]
351:         // Convert request body to JSON
352:         guard let jsonData = try? JSONSerialization.data(withJSONObject: requestBody) else {
353:             completion(.failure(NSError(domain: &quot;OpenAIService&quot;, code: 0, userInfo: [NSLocalizedDescriptionKey: &quot;Failed to serialize request body&quot;])))
354:             return
355:         }
356:         request.httpBody = jsonData
357:         // Make the request
358:         let task = URLSession.shared.dataTask(with: request) { (data, response, error) in
359:             // Handle error
360:             if let error = error {
361:                 completion(.failure(error))
362:                 return
363:             }
364:             // Handle no data
365:             guard let data = data else {
366:                 completion(.failure(NSError(domain: &quot;OpenAIService&quot;, code: 0, userInfo: [NSLocalizedDescriptionKey: &quot;No data received&quot;])))
367:                 return
368:             }
369:             // Parse response
370:             do {
371:                 if let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
372:                    let choices = json[&quot;choices&quot;] as? [[String: Any]],
373:                    let firstChoice = choices.first,
374:                    let message = firstChoice[&quot;message&quot;] as? [String: Any],
375:                    let content = message[&quot;content&quot;] as? String {
376:                     completion(.success(content))
377:                 } else {
378:                     // Try to extract error message if available
379:                     if let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
380:                        let error = json[&quot;error&quot;] as? [String: Any],
381:                        let message = error[&quot;message&quot;] as? String {
382:                         completion(.failure(NSError(domain: &quot;OpenAIService&quot;, code: 0, userInfo: [NSLocalizedDescriptionKey: message])))
383:                     } else {
384:                         completion(.failure(NSError(domain: &quot;OpenAIService&quot;, code: 0, userInfo: [NSLocalizedDescriptionKey: &quot;Failed to parse response&quot;])))
385:                     }
386:                 }
387:             } catch {
388:                 completion(.failure(error))
389:             }
390:         }
391:         task.resume()
392:     }
393:     /// API response structure for insights
394:     private struct APIInsightsResponse: Decodable {
395:         let title: String
396:         let summary: String
397:         let blendExplanation: String?
398:         let stageBreakdown: [APIStageBreakdown]?
399:         let keyPoints: [APIKeyPoint]
400:         struct APIKeyPoint: Decodable {
401:             let title: String
402:             let description: String
403:             let type: String
404:         }
405:         struct APIStageBreakdown: Decodable {
406:             let stageNumber: Int
407:             let analysis: String
408:         }
409:     }
410:     /// Stage analysis information
411:     private struct StageAnalysis {
412:         let stageNumber: Int
413:         let analysis: String
414:     }
415:     /// Parse insights from the OpenAI API response
416:     private func parseInsightsFromResponse(_ jsonString: String, forProtocol protocol: InjectionProtocol? = nil, forCycle cycle: Cycle? = nil) throws -&gt; Insights {
417:         let decoder = JSONDecoder()
418:         // Extract the JSON structure from the response
419:         guard let jsonData = jsonString.data(using: .utf8) else {
420:             throw NSError(domain: &quot;OpenAIService&quot;, code: 0, userInfo: [NSLocalizedDescriptionKey: &quot;Failed to convert response to data&quot;])
421:         }
422:         // Try to decode as APIInsightsResponse
423:         do {
424:             let response = try decoder.decode(APIInsightsResponse.self, from: jsonData)
425:             // Convert API response to Insights model
426:             var keyPoints: [KeyPoint] = []
427:             for point in response.keyPoints {
428:                 let type: KeyPoint.KeyPointType
429:                 switch point.type {
430:                 case &quot;information&quot;: type = .information
431:                 case &quot;positive&quot;: type = .positive
432:                 case &quot;warning&quot;: type = .warning
433:                 case &quot;suggestion&quot;: type = .suggestion
434:                 default: type = .information
435:                 }
436:                 keyPoints.append(KeyPoint(title: point.title, description: point.description, type: type))
437:             }
438:             // Create the Insights object
439:             return Insights(
440:                 title: response.title,
441:                 summary: response.summary,
442:                 blendExplanation: response.blendExplanation,
443:                 keyPoints: keyPoints
444:             )
445:         } catch {
446:             print(&quot;Error parsing insights: \(error)&quot;)
447:             throw error
448:         }
449:     }
450:     // MARK: - Error Types
451:     /// API errors
452:     enum APIError: Error, LocalizedError {
453:         case missingAPIKey
454:         case invalidURL
455:         case invalidResponse
456:         case serverError(statusCode: Int)
457:         case noData
458:         case invalidResponseFormat
459:         case missingField(String)
460:         var errorDescription: String? {
461:             switch self {
462:             case .missingAPIKey:
463:                 return &quot;OpenAI API key is missing&quot;
464:             case .invalidURL:
465:                 return &quot;Invalid URL&quot;
466:             case .invalidResponse:
467:                 return &quot;Invalid response from server&quot;
468:             case .serverError(let statusCode):
469:                 return &quot;Server error with status code: \(statusCode)&quot;
470:             case .noData:
471:                 return &quot;No data received from server&quot;
472:             case .invalidResponseFormat:
473:                 return &quot;Invalid response format&quot;
474:             case .missingField(let field):
475:                 return &quot;Missing field in response: \(field)&quot;
476:             }
477:         }
478:     }
479: }

================
File: TestoSim/Views/ProtocolDetailView.swift
================
  1: import SwiftUI
  2: struct ProtocolDetailView: View {
  3:     @EnvironmentObject var dataStore: AppDataStore
  4:     @State private var showingAddBloodSheet = false
  5:     @State private var showingCalibrateConfirm = false
  6:     @State private var showingNotificationOptions = false
  7:     @State private var showingEnableNotificationsAlert = false
  8:     let injectionProtocol: InjectionProtocol
  9:     // Try to get the compound for any protocol type
 10:     var resolvedCompound: Compound? {
 11:         // If protocol has a direct compound reference, use that
 12:         if let compoundID = injectionProtocol.compoundID {
 13:             return dataStore.compoundLibrary.compound(withID: compoundID)
 14:         }
 15:         return nil
 16:     }
 17:     var body: some View {
 18:         ScrollView {
 19:             VStack(alignment: .leading, spacing: 16) {
 20:                 // Protocol summary
 21:                 protocolSummaryView
 22:                 // Display the latest bloodwork info if available
 23:                 if let latestSample = injectionProtocol.bloodSamples.max(by: { $0.date &lt; $1.date }) {
 24:                     latestBloodworkView(sample: latestSample)
 25:                 }
 26:                 // Chart
 27:                 TestosteroneChart(treatmentProtocol: injectionProtocol)
 28:                     .frame(height: 300)
 29:                 // Next injection information
 30:                 nextInjectionView
 31:                 // Action buttons section
 32:                 actionButtonsView
 33:             }
 34:             .padding()
 35:         }
 36:         .navigationTitle(injectionProtocol.name)
 37:         .navigationBarTitleDisplayMode(.inline)
 38:         .toolbar {
 39:             ToolbarItem(placement: .primaryAction) {
 40:                 Button(&quot;Edit&quot;) {
 41:                     dataStore.protocolToEdit = injectionProtocol
 42:                     dataStore.isPresentingProtocolForm = true
 43:                 }
 44:             }
 45:         }
 46:         .sheet(isPresented: $showingAddBloodSheet) {
 47:             AddBloodworkView(injectionProtocol: injectionProtocol)
 48:                 .environmentObject(dataStore)
 49:         }
 50:         .alert(&quot;Calibration Updated&quot;, isPresented: $showingCalibrateConfirm) {
 51:             Button(&quot;OK&quot;, role: .cancel) { }
 52:         }
 53:         .alert(&quot;Enable Notifications&quot;, isPresented: $showingEnableNotificationsAlert) {
 54:             Button(&quot;Settings&quot;, role: .none) {
 55:                 showingNotificationOptions = true
 56:             }
 57:             Button(&quot;Cancel&quot;, role: .cancel) { }
 58:         } message: {
 59:             Text(&quot;Notifications are currently disabled. Would you like to enable them in settings?&quot;)
 60:         }
 61:         .sheet(isPresented: $showingNotificationOptions) {
 62:             NotificationSettingsView()
 63:                 .environmentObject(dataStore)
 64:         }
 65:         .onAppear {
 66:             dataStore.selectProtocol(id: injectionProtocol.id)
 67:             dataStore.recalcSimulation()
 68:             // Check if the protocol needs a compound fix
 69:             fixProtocolCompound()
 70:         }
 71:     }
 72:     // MARK: - Next Injection View
 73:     var nextInjectionView: some View {
 74:         let nextInjection = nextInjectionDate()
 75:         return VStack(alignment: .leading, spacing: 8) {
 76:             Text(&quot;Next Injection&quot;)
 77:                 .font(.headline)
 78:             HStack {
 79:                 if let nextDate = nextInjection {
 80:                     VStack(alignment: .leading) {
 81:                         Text(nextDate, style: .date)
 82:                             .font(.title3)
 83:                             .foregroundColor(.primary)
 84:                         Text(daysUntilNextInjection(nextDate))
 85:                             .foregroundColor(.secondary)
 86:                     }
 87:                     Spacer()
 88:                     Button(action: {
 89:                         if NotificationManager.shared.notificationsEnabled {
 90:                             NotificationManager.shared.scheduleNotifications(
 91:                                 for: injectionProtocol,
 92:                                 using: dataStore.compoundLibrary
 93:                             )
 94:                         } else {
 95:                             showingEnableNotificationsAlert = true
 96:                         }
 97:                     }) {
 98:                         Label(&quot;Remind Me&quot;, systemImage: &quot;bell&quot;)
 99:                     }
100:                     .buttonStyle(.borderedProminent)
101:                 } else {
102:                     Text(&quot;No upcoming injections scheduled&quot;)
103:                         .foregroundColor(.secondary)
104:                         .italic()
105:                 }
106:             }
107:         }
108:         .padding()
109:         .background(Color(.systemGray6))
110:         .cornerRadius(10)
111:     }
112:     // MARK: - Action Buttons View
113:     var actionButtonsView: some View {
114:         HStack {
115:             Button(action: {
116:                 showingAddBloodSheet = true
117:             }) {
118:                 Label(&quot;Add Bloodwork&quot;, systemImage: &quot;drop.fill&quot;)
119:             }
120:             .buttonStyle(.bordered)
121:             Spacer()
122:             // Record injection button (acknowledges adherence)
123:             Button(action: {
124:                 if let nextDate = nextInjectionDate() {
125:                     dataStore.acknowledgeInjection(
126:                         protocolID: injectionProtocol.id,
127:                         injectionDate: nextDate
128:                     )
129:                 }
130:             }) {
131:                 Label(&quot;Record Injection&quot;, systemImage: &quot;checkmark.circle&quot;)
132:             }
133:             .buttonStyle(.bordered)
134:             .disabled(nextInjectionDate() == nil)
135:             Spacer()
136:             Button(action: {
137:                 dataStore.calibrateProtocol(injectionProtocol)
138:                 showingCalibrateConfirm = true
139:             }) {
140:                 Label(&quot;Recalibrate&quot;, systemImage: &quot;slider.horizontal.3&quot;)
141:             }
142:             .buttonStyle(.bordered)
143:             .disabled(injectionProtocol.bloodSamples.isEmpty)
144:         }
145:         .padding(.horizontal)
146:     }
147:     // MARK: - Protocol summary based on protocol type
148:     var protocolSummaryView: some View {
149:         VStack(alignment: .leading, spacing: 8) {
150:             // Display information based on protocol type
151:             switch injectionProtocol.protocolType {
152:             case .compound:
153:                 if let compoundID = injectionProtocol.compoundID,
154:                    let compound = dataStore.compoundLibrary.compound(withID: compoundID) {
155:                     compoundSummary(compound: compound)
156:                 } else {
157:                     // Fallback: Try to extract compound name from protocol name
158:                     let esterNames = [&quot;propionate&quot;, &quot;phenylpropionate&quot;, &quot;isocaproate&quot;, &quot;enanthate&quot;, 
159:                                      &quot;cypionate&quot;, &quot;decanoate&quot;, &quot;undecanoate&quot;]
160:                     let foundEster = esterNames.first { ester in
161:                         injectionProtocol.name.lowercased().contains(ester) ||
162:                         (injectionProtocol.notes ?? &quot;&quot;).lowercased().contains(ester)
163:                     }
164:                     if let esterName = foundEster,
165:                        let compound = dataStore.compoundLibrary.compounds.first(where: { 
166:                            $0.classType == .testosterone &amp;&amp; 
167:                            $0.ester?.lowercased() == esterName.lowercased() 
168:                        }) {
169:                         // Found a matching compound, show it
170:                         compoundSummary(compound: compound)
171:                         // This will be updated in onAppear
172:                         Text(&quot;Protocol will be updated&quot;)
173:                             .font(.caption)
174:                             .foregroundColor(.secondary)
175:                     } else {
176:                         Text(&quot;Invalid compound selection&quot;)
177:                             .foregroundColor(.red)
178:                     }
179:                 }
180:             case .blend:
181:                 if let blendID = injectionProtocol.blendID,
182:                    let blend = dataStore.compoundLibrary.blend(withID: blendID) {
183:                     blendSummary(blend: blend)
184:                 } else {
185:                     Text(&quot;Invalid blend selection&quot;)
186:                         .foregroundColor(.red)
187:                 }
188:             }
189:             // Common protocol details
190:             Divider()
191:             HStack {
192:                 Text(&quot;Dose:&quot;)
193:                     .bold()
194:                 Spacer()
195:                 Text(&quot;\(injectionProtocol.doseMg, specifier: &quot;%.1f&quot;) mg&quot;)
196:             }
197:             HStack {
198:                 Text(&quot;Frequency:&quot;)
199:                     .bold()
200:                 Spacer()
201:                 if injectionProtocol.frequencyDays == 7 {
202:                     Text(&quot;Weekly&quot;)
203:                 } else if injectionProtocol.frequencyDays == 3.5 {
204:                     Text(&quot;Twice weekly&quot;)
205:                 } else if injectionProtocol.frequencyDays == 1 {
206:                     Text(&quot;Daily&quot;)
207:                 } else {
208:                     Text(&quot;Every \(injectionProtocol.frequencyDays, specifier: &quot;%.1f&quot;) days&quot;)
209:                 }
210:             }
211:             // Show administration route if available
212:             if let routeString = injectionProtocol.selectedRoute,
213:                let route = Compound.Route(rawValue: routeString) {
214:                 HStack {
215:                     Text(&quot;Route:&quot;)
216:                         .bold()
217:                     Spacer()
218:                     Text(route.displayName)
219:                 }
220:             } else {
221:                 // Default route if not specified
222:                 HStack {
223:                     Text(&quot;Route:&quot;)
224:                         .bold()
225:                     Spacer()
226:                     Text(&quot;Intramuscular (IM)&quot;)
227:                 }
228:             }
229:             HStack {
230:                 Text(&quot;Start Date:&quot;)
231:                     .bold()
232:                 Spacer()
233:                 Text(injectionProtocol.startDate, style: .date)
234:             }
235:             if let notes = injectionProtocol.notes, !notes.isEmpty {
236:                 Text(&quot;Notes:&quot;)
237:                     .bold()
238:                 // Filter out the extended data JSON
239:                 let filteredNotes = notes.contains(&quot;---EXTENDED_DATA---&quot;) 
240:                     ? notes.components(separatedBy: &quot;---EXTENDED_DATA---&quot;).first?.trimmingCharacters(in: .whitespacesAndNewlines) 
241:                     : notes
242:                 if let filteredNotes = filteredNotes, !filteredNotes.isEmpty {
243:                     Text(filteredNotes)
244:                         .fixedSize(horizontal: false, vertical: true)
245:                 }
246:             }
247:         }
248:         .padding()
249:         .background(Color(.systemGray6))
250:         .cornerRadius(10)
251:     }
252:     // MARK: - Protocol type-specific summaries
253:     func compoundSummary(compound: Compound) -&gt; some View {
254:         VStack(alignment: .leading) {
255:             HStack {
256:                 Text(&quot;Compound:&quot;)
257:                     .bold()
258:                 Spacer()
259:                 Text(compound.fullDisplayName)
260:             }
261:             HStack {
262:                 Text(&quot;Half-life:&quot;)
263:                     .bold()
264:                 Spacer()
265:                 Text(&quot;\(compound.halfLifeDays, specifier: &quot;%.1f&quot;) days&quot;)
266:             }
267:             HStack {
268:                 Text(&quot;Class:&quot;)
269:                     .bold()
270:                 Spacer()
271:                 Text(compound.classType.displayName)
272:             }
273:         }
274:     }
275:     func blendSummary(blend: VialBlend) -&gt; some View {
276:         VStack(alignment: .leading) {
277:             HStack {
278:                 Text(&quot;Blend:&quot;)
279:                     .bold()
280:                 Spacer()
281:                 Text(blend.name)
282:             }
283:             if let manufacturer = blend.manufacturer {
284:                 HStack {
285:                     Text(&quot;Manufacturer:&quot;)
286:                         .bold()
287:                     Spacer()
288:                     Text(manufacturer)
289:                 }
290:             }
291:             HStack {
292:                 Text(&quot;Composition:&quot;)
293:                     .bold()
294:                 Spacer()
295:             }
296:             Text(blend.compositionDescription(using: dataStore.compoundLibrary))
297:                 .font(.caption)
298:                 .foregroundColor(.secondary)
299:                 .fixedSize(horizontal: false, vertical: true)
300:         }
301:     }
302:     // MARK: - Blood sample summary
303:     func latestBloodworkView(sample: BloodSample) -&gt; some View {
304:         VStack(alignment: .leading, spacing: 8) {
305:             Text(&quot;Latest Blood Test&quot;)
306:                 .font(.headline)
307:             HStack {
308:                 Text(&quot;Date:&quot;)
309:                     .bold()
310:                 Spacer()
311:                 Text(sample.date, style: .date)
312:             }
313:             HStack {
314:                 Text(&quot;Measured Level:&quot;)
315:                     .bold()
316:                 Spacer()
317:                 Text(&quot;\(formatValue(sample.value, unit: sample.unit)) \(sample.unit)&quot;)
318:             }
319:             // Calculate the model&apos;s prediction for the same date
320:             let modelPrediction = dataStore.predictedLevel(on: sample.date, for: injectionProtocol)
321:             HStack {
322:                 Text(&quot;Model Prediction:&quot;)
323:                     .bold()
324:                 Spacer()
325:                 Text(&quot;\(formatValue(modelPrediction, unit: dataStore.profile.unit)) \(dataStore.profile.unit)&quot;)
326:             }
327:             // Show error percentage
328:             let errorPercentage = abs((modelPrediction - sample.value) / sample.value * 100)
329:             HStack {
330:                 Text(&quot;Deviation:&quot;)
331:                     .bold()
332:                 Spacer()
333:                 Text(&quot;\(formatValue(errorPercentage, unit: &quot;%&quot;))%&quot;)
334:                     .foregroundColor(errorPercentage &lt; 10 ? .green : (errorPercentage &lt; 20 ? .yellow : .red))
335:             }
336:         }
337:         .padding()
338:         .background(Color(.systemGray6))
339:         .cornerRadius(10)
340:     }
341:     // MARK: - Helper for value formatting
342:     func formatValue(_ value: Double, unit: String) -&gt; String {
343:         let formatter = NumberFormatter()
344:         formatter.numberStyle = .decimal
345:         if unit == &quot;nmol/L&quot; {
346:             formatter.maximumFractionDigits = 1
347:         } else if unit == &quot;%&quot; {
348:             formatter.maximumFractionDigits = 1
349:         } else { // ng/dL typically whole numbers
350:             formatter.maximumFractionDigits = 0
351:         }
352:         formatter.minimumFractionDigits = formatter.maximumFractionDigits // Ensure consistency
353:         return formatter.string(from: NSNumber(value: value)) ?? &quot;\(value)&quot;
354:     }
355:     // MARK: - Helper Methods
356:     private func nextInjectionDate() -&gt; Date? {
357:         let today = Date()
358:         let endDate = today.addingTimeInterval(60 * 24 * 3600) // Look 60 days ahead
359:         let upcomingDates = injectionProtocol.injectionDates(from: today, upto: endDate)
360:         return upcomingDates.first
361:     }
362:     private func daysUntilNextInjection(_ nextDate: Date) -&gt; String {
363:         let today = Date()
364:         let calendar = Calendar.current
365:         let components = calendar.dateComponents([.day, .hour], from: today, to: nextDate)
366:         if let days = components.day, let hours = components.hour {
367:             if days == 0 {
368:                 return &quot;Today&quot;
369:             } else if days == 1 {
370:                 return &quot;Tomorrow&quot;
371:             } else {
372:                 return &quot;In \(days) days, \(hours) hours&quot;
373:             }
374:         }
375:         return &quot;&quot;
376:     }
377:     // MARK: - Protocol Compound Auto-Fix
378:     private func fixProtocolCompound() {
379:         // Only fix protocols that don&apos;t have compounds
380:         if injectionProtocol.compoundID == nil {
381:             let esterNames = [&quot;propionate&quot;, &quot;phenylpropionate&quot;, &quot;isocaproate&quot;, &quot;enanthate&quot;, 
382:                              &quot;cypionate&quot;, &quot;decanoate&quot;, &quot;undecanoate&quot;]
383:             // Look for matching ester in name or notes
384:             let foundEster = esterNames.first { ester in
385:                 injectionProtocol.name.lowercased().contains(ester) ||
386:                 (injectionProtocol.notes ?? &quot;&quot;).lowercased().contains(ester)
387:             }
388:             if let esterName = foundEster,
389:                let compound = dataStore.compoundLibrary.compounds.first(where: { 
390:                    $0.classType == .testosterone &amp;&amp; 
391:                    $0.ester?.lowercased() == esterName.lowercased() 
392:                }) {
393:                 // Found a matching compound, update protocol
394:                 var updatedProtocol = injectionProtocol
395:                 updatedProtocol.compoundID = compound.id
396:                 updatedProtocol.selectedRoute = updatedProtocol.selectedRoute ?? 
397:                                              Compound.Route.intramuscular.rawValue
398:                 // Update protocol in datastore
399:                 dataStore.updateProtocol(updatedProtocol)
400:             }
401:         }
402:     }
403: }
404: #Preview {
405:     NavigationStack {
406:         ProtocolDetailView(injectionProtocol: InjectionProtocol(
407:             name: &quot;Test Protocol&quot;,
408:             doseMg: 100,
409:             frequencyDays: 7,
410:             startDate: Date()
411:         ))
412:         .environmentObject(AppDataStore())
413:     }
414: }

================
File: TestoSim/ViewModels/AppDataStore.swift
================
   1: import Foundation
   2: import SwiftUI
   3: import CoreData // Make sure CoreData is imported
   4: @MainActor
   5: class AppDataStore: ObservableObject {
   6:     // MARK: - Published Properties
   7:     @Published var profile: UserProfile
   8:     @Published var simulationData: [DataPoint] = []
   9:     @Published var selectedProtocolID: UUID?
  10:     @Published var isPresentingProtocolForm = false
  11:     @Published var protocolToEdit: InjectionProtocol?
  12:     @Published var compoundLibrary = CompoundLibrary()
  13:     // Cycle management
  14:     @Published var cycles: [Cycle] = []
  15:     @Published var selectedCycleID: UUID?
  16:     @Published var isPresentingCycleForm = false // Used for presenting cycle creation form
  17:     @Published var cycleToEdit: Cycle?          // Used for editing existing cycles
  18:     @Published var isCycleSimulationActive = false
  19:     @Published var cycleSimulationData: [DataPoint] = []
  20:     // MARK: - Private Properties
  21:     private static let coreDataManager = CoreDataManager.shared
  22:     private let coreDataManager = CoreDataManager.shared
  23:     private let notificationManager = NotificationManager.shared
  24:     // PKModel instance - always use two-compartment model as per latest decision
  25:     private let pkModel = PKModel(useTwoCompartmentModel: true)
  26:     // MARK: - Constants
  27:     let simulationDurationDays: Double = 90.0 // Default simulation length
  28:     // MARK: - Computed Properties (Removed simulationEndDate as it&apos;s calculated dynamically now)
  29:     // MARK: - Initialization
  30:     init() {
  31:         // Initialize profile with a default empty profile first
  32:         self.profile = UserProfile()
  33:         // Check migration status and load data accordingly
  34:         if UserDefaults.standard.bool(forKey: &quot;migrated&quot;) {
  35:             // Load profile from Core Data
  36:             if let loadedProfile = AppDataStore.loadProfileFromCoreData() {
  37:                 self.profile = loadedProfile
  38:             } else {
  39:                 // If loading fails after migration, create default and save
  40:                 self.profile = AppDataStore.createDefaultProfile()
  41:                 let context = coreDataManager.persistentContainer.viewContext
  42:                 _ = self.profile.saveToCD(context: context)
  43:                 do {
  44:                     try context.save()
  45:                 } catch {
  46:                     print(&quot;Error saving default profile to Core Data after failed load: \(error)&quot;)
  47:                 }
  48:             }
  49:             // Load cycles from Core Data if migrated
  50:             loadCyclesFromCoreData()
  51:         } else {
  52:             // Not migrated yet, try loading from UserDefaults (old method)
  53:             if let savedData = UserDefaults.standard.data(forKey: &quot;userProfileData&quot;),
  54:                let decodedProfile = try? JSONDecoder().decode(UserProfile.self, from: savedData) {
  55:                 self.profile = decodedProfile
  56:                 // Trigger migration to Core Data
  57:                 coreDataManager.migrateUserProfileFromJSON() // This saves the migrated data
  58:                 UserDefaults.standard.set(true, forKey: &quot;migrated&quot;) // Mark as migrated
  59:                 print(&quot;Successfully migrated profile from UserDefaults to Core Data.&quot;)
  60:             } else {
  61:                 // No old data and not migrated: Create default profile and save to Core Data
  62:                 self.profile = AppDataStore.createDefaultProfile()
  63:                 let context = coreDataManager.persistentContainer.viewContext
  64:                 _ = self.profile.saveToCD(context: context)
  65:                 do {
  66:                     try context.save()
  67:                 } catch {
  68:                     print(&quot;Error saving initial default profile to Core Data: \(error)&quot;)
  69:                 }
  70:                 UserDefaults.standard.set(true, forKey: &quot;migrated&quot;) // Mark as migrated even if creating default
  71:             }
  72:         }
  73:         // Set initial selected protocol if any exist
  74:         if !profile.protocols.isEmpty {
  75:              // Ensure the selected protocol ID actually exists in the loaded profile
  76:              if let firstValidProtocolID = profile.protocols.first?.id {
  77:                   selectedProtocolID = firstValidProtocolID
  78:              }
  79:         } else {
  80:              selectedProtocolID = nil // Explicitly nil if no protocols
  81:         }
  82:         // Generate initial simulation data for the selected protocol (if any)
  83:         recalcSimulation() // This will handle the case where selectedProtocolID is nil
  84:         // Schedule notifications for all protocols if enabled
  85:         if notificationManager.notificationsEnabled {
  86:             Task {
  87:                 await scheduleAllNotifications()
  88:             }
  89:         }
  90:     }
  91:     // MARK: - Helper: Create PK Model
  92:     // Ensures the PK Model is created consistently with app settings
  93:     private func createPKModel() -&gt; PKModel {
  94:         return PKModel(useTwoCompartmentModel: true) // Always use two-compartment
  95:     }
  96:     // MARK: - Helper: Generate Simulation Dates
  97:     // Generates an array of Dates for simulation points
  98:     private func generateSimulationDates(startDate: Date, endDate: Date, interval: Double) -&gt; [Date] {
  99:         guard startDate &lt;= endDate, interval &gt; 0 else { return [] } // Basic validation
 100:         var dates: [Date] = []
 101:         var currentDate = startDate
 102:         let intervalSeconds = interval * 24 * 3600 // Convert days to seconds
 103:         while currentDate &lt;= endDate {
 104:             dates.append(currentDate)
 105:             // Ensure adding interval doesn&apos;t cause infinite loop with very small intervals near precision limits
 106:             if let nextDate = Calendar.current.date(byAdding: .second, value: Int(intervalSeconds.rounded()), to: currentDate), nextDate &gt; currentDate {
 107:                 currentDate = nextDate
 108:             } else {
 109:                 // Fallback or break if interval is too small or date calculation fails
 110:                 currentDate = currentDate.addingTimeInterval(intervalSeconds)
 111:                 if currentDate &lt;= dates.last ?? startDate { // Prevent infinite loop
 112:                     print(&quot;Warning: Simulation date interval too small or calculation failed. Breaking loop.&quot;)
 113:                     break
 114:                 }
 115:             }
 116:             // Safety break
 117:             if dates.count &gt; 5000 { // Limit number of points to prevent excessive calculation
 118:                 print(&quot;Warning: Simulation date generation exceeded 5000 points. Breaking loop.&quot;)
 119:                 break
 120:             }
 121:         }
 122:         // Ensure the end date is included if it wasn&apos;t hit exactly by the stride
 123:         if let lastDate = dates.last, lastDate &lt; endDate {
 124:             dates.append(endDate)
 125:         }
 126:         return dates
 127:     }
 128:     // MARK: - Helper: Find Legacy Compound (Temporary Fix)
 129:     // Attempts to find a matching compound based on legacy notes/name
 130:     private func findLegacyCompound(for injectionProtocol: InjectionProtocol) -&gt; Compound? {
 131:          let esterNames = [&quot;propionate&quot;, &quot;phenylpropionate&quot;, &quot;isocaproate&quot;, &quot;enanthate&quot;,
 132:                            &quot;cypionate&quot;, &quot;decanoate&quot;, &quot;undecanoate&quot;]
 133:          let notes = injectionProtocol.notes ?? &quot;&quot;
 134:          let name = injectionProtocol.name
 135:          // Prioritize finding ester name in the dedicated field within notes if available
 136:          var foundEsterName: String? = nil
 137:          if let notesRange = notes.range(of: &quot;---EXTENDED_DATA---&quot;) {
 138:              let jsonString = String(notes[notesRange.upperBound...]).trimmingCharacters(in: .whitespacesAndNewlines)
 139:              if let jsonData = jsonString.data(using: .utf8),
 140:                 let extendedData = try? JSONSerialization.jsonObject(with: jsonData) as? [String: String] {
 141:                  // Check if compoundID exists and find compound directly
 142:                  if let compoundIDStr = extendedData[&quot;compoundID&quot;], let uuid = UUID(uuidString: compoundIDStr) {
 143:                     if let directCompound = compoundLibrary.compound(withID: uuid) {
 144:                          print(&quot;Legacy Fix: Found compound via ID in extended data.&quot;)
 145:                          return directCompound
 146:                     }
 147:                  }
 148:                  // Otherwise, continue searching by name/notes
 149:              }
 150:          }
 151:          // If not found via ID, search by name/notes string matching
 152:          foundEsterName = esterNames.first { ester in
 153:              name.lowercased().contains(ester) || notes.lowercased().contains(ester)
 154:          }
 155:          if let esterName = foundEsterName {
 156:              let matchingCompound = compoundLibrary.compounds.first {
 157:                  $0.classType == .testosterone &amp;&amp; $0.ester?.lowercased() == esterName.lowercased()
 158:              }
 159:              if matchingCompound != nil { print(&quot;Legacy Fix: Found compound via name/notes string matching.&quot;) }
 160:              return matchingCompound
 161:          }
 162:          print(&quot;Legacy Fix: Could not find matching compound for protocol &apos;\(name)&apos;&quot;)
 163:          return nil
 164:      }
 165:     // MARK: - Core Data Loading/Saving
 166:     private static func loadProfileFromCoreData() -&gt; UserProfile? {
 167:         let context = coreDataManager.persistentContainer.viewContext
 168:         let fetchRequest: NSFetchRequest&lt;CDUserProfile&gt; = CDUserProfile.fetchRequest()
 169:         do {
 170:             let results = try context.fetch(fetchRequest)
 171:             if let cdProfile = results.first {
 172:                 print(&quot;Profile loaded successfully from Core Data.&quot;)
 173:                 return UserProfile(from: cdProfile)
 174:             } else {
 175:                 print(&quot;No profile found in Core Data.&quot;)
 176:             }
 177:         } catch {
 178:             print(&quot;Error fetching profile from Core Data: \(error)&quot;)
 179:         }
 180:         return nil
 181:     }
 182:     func saveProfile() {
 183:         // Always save to Core Data now
 184:         let context = coreDataManager.persistentContainer.viewContext
 185:         _ = profile.saveToCD(context: context) // This handles create/update
 186:         // Note: The actual context save is handled by CoreDataManager.saveContext()
 187:         // which might be called elsewhere (e.g., on app background) or explicitly if needed immediately.
 188:         // For robustness, you might call it here too, but be mindful of performance if called frequently.
 189:         // coreDataManager.saveContext() // Uncomment if immediate save is desired after every profile change
 190:         print(&quot;Profile prepared for saving to Core Data.&quot;)
 191:     }
 192:     // MARK: - Default Profile Creation
 193:     private static func createDefaultProfile() -&gt; UserProfile {
 194:         print(&quot;Creating default profile.&quot;)
 195:         var profile = UserProfile()
 196:         // Set up a complete test profile with realistic user data
 197:         profile.name = &quot;Test User&quot;
 198:         profile.unit = &quot;ng/dL&quot;
 199:         profile.calibrationFactor = 1.0
 200:         profile.dateOfBirth = Calendar.current.date(byAdding: .year, value: -35, to: Date())!
 201:         profile.heightCm = 175.0 // cm
 202:         profile.weight = 85.0 // kg
 203:         profile.biologicalSex = .male
 204:         profile.usesICloudSync = false
 205:         // Add a variety of test protocols with compounds
 206:         let compoundLibrary = CompoundLibrary() // Use a local instance for default creation
 207:         // 1. Standard TRT protocol (cypionate)
 208:         var weeklyProtocol = InjectionProtocol(
 209:             name: &quot;Weekly Cypionate&quot;,
 210:             doseMg: 100.0,
 211:             frequencyDays: 7.0,
 212:             startDate: Calendar.current.date(byAdding: .day, value: -60, to: Date())!,
 213:             notes: &quot;Standard TRT protocol with weekly injections&quot;
 214:         )
 215:         if let cypionate = compoundLibrary.compounds.first(where: { $0.classType == .testosterone &amp;&amp; $0.ester?.lowercased() == &quot;cypionate&quot; }) {
 216:             weeklyProtocol.compoundID = cypionate.id
 217:             weeklyProtocol.selectedRoute = Compound.Route.intramuscular.rawValue
 218:             // Add some test blood samples to the protocol
 219:             weeklyProtocol.bloodSamples = [
 220:                 BloodSample(date: Calendar.current.date(byAdding: .day, value: -30, to: Date())!, value: 650.0, unit: &quot;ng/dL&quot;),
 221:                 BloodSample(date: Calendar.current.date(byAdding: .day, value: -15, to: Date())!, value: 720.0, unit: &quot;ng/dL&quot;)
 222:             ]
 223:             profile.protocols.append(weeklyProtocol)
 224:         } else { print(&quot;Warning: Could not find Testosterone Cypionate in library for default profile.&quot;) }
 225:         // 2. Split dose protocol (enanthate)
 226:         var splitDoseProtocol = InjectionProtocol(
 227:             name: &quot;Split Dose Enanthate&quot;,
 228:             doseMg: 75.0,
 229:             frequencyDays: 3.5,
 230:             startDate: Calendar.current.date(byAdding: .day, value: -45, to: Date())!,
 231:             notes: &quot;Split dose protocol for more stable levels&quot;
 232:         )
 233:         if let enanthate = compoundLibrary.compounds.first(where: { $0.classType == .testosterone &amp;&amp; $0.ester?.lowercased() == &quot;enanthate&quot; }) {
 234:             splitDoseProtocol.compoundID = enanthate.id
 235:             splitDoseProtocol.selectedRoute = Compound.Route.intramuscular.rawValue
 236:             profile.protocols.append(splitDoseProtocol)
 237:         } else { print(&quot;Warning: Could not find Testosterone Enanthate in library for default profile.&quot;) }
 238:         // 3. Propionate protocol (more frequent injections)
 239:         var propionateProtocol = InjectionProtocol(
 240:             name: &quot;EOD Propionate&quot;,
 241:             doseMg: 30.0,
 242:             frequencyDays: 2.0,
 243:             startDate: Calendar.current.date(byAdding: .day, value: -30, to: Date())!,
 244:             notes: &quot;Every other day protocol with propionate&quot;
 245:         )
 246:         if let propionate = compoundLibrary.compounds.first(where: { $0.classType == .testosterone &amp;&amp; $0.ester?.lowercased() == &quot;propionate&quot; }) {
 247:             propionateProtocol.compoundID = propionate.id
 248:             propionateProtocol.selectedRoute = Compound.Route.subcutaneous.rawValue // Example different route
 249:             profile.protocols.append(propionateProtocol)
 250:         } else { print(&quot;Warning: Could not find Testosterone Propionate in library for default profile.&quot;) }
 251:         return profile
 252:     }
 253:     // MARK: - Protocol Management
 254:     func addProtocol(_ newProtocol: InjectionProtocol) {
 255:         profile.protocols.append(newProtocol)
 256:         selectedProtocolID = newProtocol.id // Select the newly added protocol
 257:         recalcSimulation() // Simulate the newly added protocol
 258:         saveProfile() // Prepare profile for saving
 259:         coreDataManager.saveContext() // Save immediately
 260:         // Schedule notifications for the new protocol
 261:         if notificationManager.notificationsEnabled {
 262:             notificationManager.scheduleNotifications(for: newProtocol, using: compoundLibrary)
 263:         }
 264:         print(&quot;Added protocol: \(newProtocol.name)&quot;)
 265:     }
 266:     func updateProtocol(_ updatedProtocol: InjectionProtocol) {
 267:         if let index = profile.protocols.firstIndex(where: { $0.id == updatedProtocol.id }) {
 268:             profile.protocols[index] = updatedProtocol
 269:             if updatedProtocol.id == selectedProtocolID {
 270:                 recalcSimulation() // Resimulate if the selected protocol was updated
 271:             }
 272:             saveProfile() // Prepare profile for saving
 273:             coreDataManager.saveContext() // Save immediately
 274:             // Update notifications for the modified protocol
 275:             if notificationManager.notificationsEnabled {
 276:                 notificationManager.scheduleNotifications(for: updatedProtocol, using: compoundLibrary)
 277:             }
 278:             print(&quot;Updated protocol: \(updatedProtocol.name)&quot;)
 279:         } else {
 280:             print(&quot;Error: Protocol to update not found (ID: \(updatedProtocol.id))&quot;)
 281:         }
 282:     }
 283:     func removeProtocol(at offsets: IndexSet) {
 284:         let deletedProtocols = offsets.map { profile.protocols[$0] }
 285:         let deletedIDs = deletedProtocols.map { $0.id }
 286:         profile.protocols.remove(atOffsets: offsets)
 287:         // Check if selected protocol was deleted
 288:         if let selectedID = selectedProtocolID, deletedIDs.contains(selectedID) {
 289:             // Select the first remaining protocol, or none if list is empty
 290:             selectedProtocolID = profile.protocols.first?.id
 291:             recalcSimulation() // Recalculate simulation for new selection or empty state
 292:         }
 293:         saveProfile() // Prepare profile for saving
 294:         coreDataManager.saveContext() // Save immediately
 295:         // Cancel notifications for deleted protocols
 296:         for item in deletedProtocols {
 297:             notificationManager.cancelNotifications(for: item.id)
 298:             print(&quot;Removed protocol: \(item.name)&quot;)
 299:         }
 300:     }
 301:     func selectProtocol(id: UUID?) { // Allow nil to deselect
 302:         guard let id = id else {
 303:              selectedProtocolID = nil
 304:              simulationData = [] // Clear simulation if no protocol selected
 305:              print(&quot;Protocol deselected.&quot;)
 306:              return
 307:         }
 308:         // Only proceed if the selected ID exists in the profile
 309:         guard profile.protocols.contains(where: { $0.id == id }) else {
 310:             print(&quot;Error: Attempted to select non-existent protocol ID: \(id)&quot;)
 311:             // Optionally select the first available protocol if selection is invalid
 312:             if let firstID = profile.protocols.first?.id {
 313:                  selectedProtocolID = firstID
 314:                  simulateProtocol(id: firstID) // Simulate the first one instead
 315:             } else {
 316:                  selectedProtocolID = nil
 317:                  simulationData = []
 318:             }
 319:             return
 320:         }
 321:         // Check if selection actually changed or if simulation needs recalculating
 322:         if selectedProtocolID != id || simulationData.isEmpty {
 323:             selectedProtocolID = id
 324:             simulateProtocol(id: id) // Always simulate when protocol is explicitly selected
 325:             print(&quot;Selected protocol: \(profile.protocols.first { $0.id == id }?.name ?? &quot;Unknown&quot;)&quot;)
 326:         }
 327:     }
 328:     // MARK: - Simulation Core Logic
 329:     // Recalculates simulation based on the currently selected protocol
 330:     func recalcSimulation() {
 331:         guard let currentSelectedID = selectedProtocolID else {
 332:             simulationData = [] // Clear data if no protocol is selected
 333:             print(&quot;RecalcSimulation: No protocol selected, clearing data.&quot;)
 334:             return
 335:         }
 336:         // Ensure the selected protocol exists before simulating
 337:         if profile.protocols.contains(where: { $0.id == currentSelectedID }) {
 338:              simulateProtocol(id: currentSelectedID)
 339:         } else {
 340:              print(&quot;RecalcSimulation: Selected protocol ID \(currentSelectedID) not found in profile. Clearing data.&quot;)
 341:              simulationData = []
 342:              selectedProtocolID = nil // Deselect invalid ID
 343:         }
 344:     }
 345:     // Simulate a specific protocol - called by selectProtocol and recalcSimulation
 346:     func simulateProtocol(id: UUID) {
 347:         guard let treatmentProtocol = profile.protocols.first(where: { $0.id == id }) else {
 348:             print(&quot;SimulateProtocol Error: Protocol with ID \(id) not found.&quot;)
 349:             simulationData = [] // Clear data if protocol not found
 350:             return
 351:         }
 352:         simulationData = generateSimulationData(for: treatmentProtocol)
 353:         print(&quot;Simulation generated for protocol: \(treatmentProtocol.name)&quot;)
 354:     }
 355:     // Generates the DataPoint array for a given protocol&apos;s simulation
 356:     // ** THIS IS THE REFACTORED VERSION **
 357:     func generateSimulationData(for injectionProtocol: InjectionProtocol) -&gt; [DataPoint] {
 358:         // 1. Determine simulation time range
 359:         let calendar = Calendar.current
 360:         let now = Date()
 361:         let simulationStartDate: Date
 362:         let daysBeforeStart = -7 // Show a week before start or now
 363:         if injectionProtocol.startDate &gt; now {
 364:             // Future protocol: start simulation view a week before protocol start
 365:             simulationStartDate = calendar.date(byAdding: .day, value: daysBeforeStart, to: injectionProtocol.startDate) ?? injectionProtocol.startDate
 366:         } else {
 367:             // Protocol already started: show from a week before now or protocol start, whichever is earlier
 368:             let aWeekBeforeNow = calendar.date(byAdding: .day, value: daysBeforeStart, to: now) ?? now
 369:             simulationStartDate = min(aWeekBeforeNow, injectionProtocol.startDate)
 370:         }
 371:         // Determine end date: Ensure at least 90 days from protocol start AND 30 days from now are shown
 372:         let minEndDate = calendar.date(byAdding: .day, value: Int(simulationDurationDays), to: injectionProtocol.startDate) ?? now // Use constant duration
 373:         let thirtyDaysFromNow = calendar.date(byAdding: .day, value: 30, to: now) ?? now
 374:         let simulationEndDate = max(minEndDate, thirtyDaysFromNow)
 375:         // 2. Generate time points for the chart
 376:         let simulationDates = generateSimulationDates(
 377:             startDate: simulationStartDate,
 378:             endDate: simulationEndDate,
 379:              // Dynamic interval based on frequency, minimum 6 hours (0.25 days)
 380:             interval: max(0.25, injectionProtocol.frequencyDays / 16.0) 
 381:         )
 382:         if simulationDates.isEmpty {
 383:             print(&quot;Warning: No simulation dates generated for protocol \(injectionProtocol.name)&quot;)
 384:             return []
 385:         }
 386:         // 3. Generate ALL relevant injection dates up to the simulation end date
 387:         let allInjectionDates = injectionProtocol.injectionDates(
 388:             from: injectionProtocol.startDate, // Base calculation from protocol start
 389:             upto: simulationEndDate             // Include all injections needed for the simulation window
 390:         )
 391:         // 4. Get compounds/blend details
 392:         var compounds: [(compound: Compound, dosePerInjectionMg: Double)] = []
 393:         let route: Compound.Route
 394:         if let routeString = injectionProtocol.selectedRoute, let selectedRoute = Compound.Route(rawValue: routeString) {
 395:             route = selectedRoute
 396:         } else {
 397:             route = .intramuscular // Default route
 398:         }
 399:         // Determine the compounds and doses based on protocol type
 400:         switch injectionProtocol.protocolType {
 401:             case .compound:
 402:                 if let compoundID = injectionProtocol.compoundID, let compound = compoundLibrary.compound(withID: compoundID) {
 403:                      if (compound.defaultBioavailability[route] ?? 0) &gt; 0 {
 404:                           compounds = [(compound: compound, dosePerInjectionMg: injectionProtocol.doseMg)]
 405:                      } else {
 406:                           print(&quot;Warning: Selected route \(route.displayName) not supported for compound \(compound.commonName). Using default route.&quot;)
 407:                           // Fallback to first supported route or default if none found
 408:                           if let _ = compound.defaultBioavailability.keys.first(where: { (compound.defaultBioavailability[$0] ?? 0) &gt; 0 }) {
 409:                                compounds = [(compound: compound, dosePerInjectionMg: injectionProtocol.doseMg)]
 410:                                // Note: Ideally, update protocol&apos;s selectedRoute here, but that could trigger unwanted UI updates.
 411:                           } else {
 412:                                print(&quot;Error: Compound \(compound.commonName) has no supported routes defined.&quot;)
 413:                                return [] // Cannot simulate without a valid route/compound combo
 414:                           }
 415:                      }
 416:                 }
 417:             case .blend:
 418:                 if let blendID = injectionProtocol.blendID, let blend = compoundLibrary.blend(withID: blendID) {
 419:                      // Blends usually assume IM, route check less critical here unless supporting SubQ blends later
 420:                      let resolvedComponents = blend.resolvedComponents(using: compoundLibrary)
 421:                      // Check if totalConcentration is valid before division
 422:                       guard blend.totalConcentration &gt; 0 else {
 423:                          print(&quot;Error: Blend \(blend.name) has zero total concentration.&quot;)
 424:                          return []
 425:                       }
 426:                       compounds = resolvedComponents.map {
 427:                          (compound: $0.compound, dosePerInjectionMg: $0.mgPerML * injectionProtocol.doseMg / blend.totalConcentration)
 428:                       }
 429:                 }
 430:         }
 431:         // Final check for compounds, potentially attempt legacy fix
 432:          if compounds.isEmpty {
 433:               print(&quot;Warning: No valid compounds initially determined for protocol \(injectionProtocol.name). Attempting legacy fix...&quot;)
 434:               if let fixedCompound = findLegacyCompound(for: injectionProtocol) {
 435:                    // Ensure the route is valid for the fixed compound
 436:                    if (fixedCompound.defaultBioavailability[route] ?? 0) &gt; 0 {
 437:                         // Valid route - use it
 438:                    } else if let firstSupported = fixedCompound.defaultBioavailability.keys.first(where: { (fixedCompound.defaultBioavailability[$0] ?? 0) &gt; 0 }) {
 439:                         print(&quot;Legacy Fix: Using route \(firstSupported.displayName) for compound \(fixedCompound.commonName)&quot;)
 440:                     } else {
 441:                         print(&quot;Legacy Fix Error: Compound \(fixedCompound.commonName) has no supported routes.&quot;)
 442:                         return []
 443:                     }
 444:                    compounds = [(compound: fixedCompound, dosePerInjectionMg: injectionProtocol.doseMg)]
 445:                    print(&quot;Legacy fix applied. Using compound: \(fixedCompound.fullDisplayName)&quot;)
 446:               } else {
 447:                    print(&quot;Error: No valid compounds found for protocol \(injectionProtocol.name), even after legacy check. Cannot simulate.&quot;)
 448:                    return []
 449:               }
 450:          }
 451:         // 5. Call PKModel calculation ONCE
 452:         let pkModel = createPKModel() // Ensure we use the correct model settings
 453:         // Print summary of simulation setup (keep this but make it less verbose)
 454:         print(&quot;Simulating protocol \(injectionProtocol.name): \(allInjectionDates.count) injections, \(compounds.count) compounds&quot;)
 455:         let concentrations = pkModel.protocolConcentrations(
 456:             at: simulationDates,
 457:             injectionDates: allInjectionDates, // Pass ALL injection dates needed for the full timeline
 458:             compounds: compounds,
 459:             route: route, // Use the determined (or default) route
 460:             weight: profile.weight ?? 70.0, // Use profile weight or default
 461:             calibrationFactor: profile.calibrationFactor
 462:         )
 463:         // Keep brief summary of results
 464:         let maxConcentration = concentrations.max() ?? 0
 465:         print(&quot;Max concentration: \(Int(maxConcentration)) \(profile.unit)&quot;)
 466:         // 6. Zip dates and concentrations into DataPoints
 467:         let dataPoints = zip(simulationDates, concentrations).map { date, level in
 468:             DataPoint(time: date, level: level.isNaN ? 0 : level) // Handle potential NaN results gracefully
 469:         }
 470:         return dataPoints
 471:     }
 472:     // MARK: - Single Point Level Calculation (for Calibration, etc.)
 473:     // Calculates the concentration at a *single* specific date.
 474:     private func calculateLevelForDate(_ date: Date, for injectionProtocol: InjectionProtocol) -&gt; Double {
 475:         // 1. Get compounds/blend details
 476:         var compounds: [(compound: Compound, dosePerInjectionMg: Double)] = []
 477:         let route: Compound.Route
 478:         if let routeString = injectionProtocol.selectedRoute, let selectedRoute = Compound.Route(rawValue: routeString) {
 479:             route = selectedRoute
 480:         } else {
 481:             route = .intramuscular // Default route
 482:         }
 483:         switch injectionProtocol.protocolType {
 484:             case .compound:
 485:                 if let compoundID = injectionProtocol.compoundID, let compound = compoundLibrary.compound(withID: compoundID) {
 486:                      if (compound.defaultBioavailability[route] ?? 0) &gt; 0 {
 487:                           compounds = [(compound: compound, dosePerInjectionMg: injectionProtocol.doseMg)]
 488:                      } else { return 0.0 } // Invalid route for compound
 489:                 }
 490:             case .blend:
 491:                  if let blendID = injectionProtocol.blendID, let blend = compoundLibrary.blend(withID: blendID) {
 492:                       guard blend.totalConcentration &gt; 0 else { return 0.0 }
 493:                       compounds = blend.resolvedComponents(using: compoundLibrary).map {
 494:                          (compound: $0.compound, dosePerInjectionMg: $0.mgPerML * injectionProtocol.doseMg / blend.totalConcentration)
 495:                       }
 496:                  }
 497:         }
 498:         // Attempt legacy fix if needed
 499:          if compounds.isEmpty {
 500:               if let fixedCompound = findLegacyCompound(for: injectionProtocol) {
 501:                    // Check if route is valid, otherwise just use it anyway (the route validation should happen elsewhere)
 502:                    if (fixedCompound.defaultBioavailability[route] ?? 0) &lt;= 0 {
 503:                         // Route not supported, but we&apos;ll use it anyway and let the PKModel handle it
 504:                         print(&quot;Warning: Selected route not optimal for legacy compound&quot;)
 505:                    }
 506:                    compounds = [(compound: fixedCompound, dosePerInjectionMg: injectionProtocol.doseMg)]
 507:               } else {
 508:                    print(&quot;Error: No valid compounds found for single date calculation: \(injectionProtocol.name)&quot;)
 509:                    return 0.0
 510:               }
 511:          }
 512:         // 2. Get ALL injection dates UP TO the target date
 513:         let injectionDates = injectionProtocol.injectionDates(
 514:             from: injectionProtocol.startDate, // Base calculation from protocol start
 515:             upto: date                         // Only include injections up to the specific date
 516:         )
 517:         // 3. Call PKModel calculation for the single date
 518:         let pkModel = createPKModel()
 519:         let concentrations = pkModel.protocolConcentrations(
 520:             at: [date], // Calculate only for this specific date
 521:             injectionDates: injectionDates,
 522:             compounds: compounds,
 523:             route: route,
 524:             weight: profile.weight ?? 70.0,
 525:             calibrationFactor: profile.calibrationFactor // Use current factor for prediction
 526:         )
 527:         return concentrations.first ?? 0.0
 528:     }
 529:     // MARK: - Predicted Level (for UI display, potentially)
 530:     // Primarily uses interpolation on existing simulation data for performance.
 531:     func predictedLevel(on date: Date, for injectionProtocol: InjectionProtocol) -&gt; Double {
 532:         // Option 1: Interpolate from existing simulationData (fast)
 533:         if !simulationData.isEmpty,
 534:             let firstDate = simulationData.first?.time,
 535:             let lastDate = simulationData.last?.time,
 536:             date &gt;= firstDate &amp;&amp; date &lt;= lastDate {
 537:             // Find the two points surrounding the date using binary search for efficiency
 538:              var lowerBound = 0
 539:              var upperBound = simulationData.count - 1
 540:              var midIndex = 0
 541:              while lowerBound &lt;= upperBound {
 542:                  midIndex = lowerBound + (upperBound - lowerBound) / 2
 543:                  let midDate = simulationData[midIndex].time
 544:                  if midDate == date {
 545:                       return simulationData[midIndex].level // Exact match
 546:                  } else if midDate &lt; date {
 547:                       lowerBound = midIndex + 1
 548:                  } else {
 549:                       upperBound = midIndex - 1
 550:                  }
 551:              }
 552:              // After loop, lowerBound points to the index *after* the target date&apos;s position
 553:              // The surrounding points are at indices lowerBound - 1 and lowerBound
 554:             // Check bounds
 555:              guard lowerBound &gt; 0 &amp;&amp; lowerBound &lt; simulationData.count else {
 556:                 // Date is outside the range or at the exact start/end
 557:                 if date &lt;= firstDate { return simulationData.first?.level ?? 0 }
 558:                 if date &gt;= lastDate { return simulationData.last?.level ?? 0 }
 559:                 print(&quot;Interpolation index out of bounds.&quot;)
 560:                 return 0.0 // Should not happen if date is within range
 561:              }
 562:             let p1 = simulationData[lowerBound - 1]
 563:             let p2 = simulationData[lowerBound]
 564:             // Linear interpolation
 565:             let timeIntervalTotal = p2.time.timeIntervalSince(p1.time)
 566:             if timeIntervalTotal &lt;= 0 { return p1.level } // Avoid division by zero or negative interval
 567:             let timeIntervalFromP1 = date.timeIntervalSince(p1.time)
 568:             let fraction = timeIntervalFromP1 / timeIntervalTotal
 569:             // Clamp fraction to [0, 1] to avoid extrapolation issues at edges
 570:             let clampedFraction = max(0.0, min(1.0, fraction))
 571:             return p1.level + (p2.level - p1.level) * clampedFraction
 572:         }
 573:         // Option 2: Date is outside the simulation range. Recalculate (can be slow if called often).
 574:         print(&quot;Warning: Predicted level requested for date \(date) outside current simulation range. Recalculating single point.&quot;)
 575:         return calculateLevelForDate(date, for: injectionProtocol) // Use the dedicated single-point calculator
 576:     }
 577:     // MARK: - Protocol Calibration
 578:     // Simple calibration using the latest blood sample
 579:     func calibrateProtocol(_ protocolToCalibrate: InjectionProtocol) {
 580:         guard let latestSample = protocolToCalibrate.bloodSamples.max(by: { $0.date &lt; $1.date }) else {
 581:             print(&quot;Cannot calibrate: No blood samples available for protocol \(protocolToCalibrate.name).&quot;)
 582:             return
 583:         }
 584:         // Calculate the model&apos;s prediction AT THE SAMPLE DATE using the CURRENT calibration factor
 585:         let modelPrediction = calculateLevelForDate(latestSample.date, for: protocolToCalibrate) // Uses the correct single-point calculation method
 586:         guard modelPrediction.isFinite, modelPrediction &gt; 0.01 else {
 587:             print(&quot;Calibration failed: Model prediction is zero or invalid (\(modelPrediction)) at sample date \(latestSample.date). Cannot calculate ratio.&quot;)
 588:             return
 589:         }
 590:         // Calculate the adjustment ratio needed to match the latest sample
 591:         let adjustmentRatio = latestSample.value / modelPrediction
 592:          // Apply the adjustment to the global factor
 593:          // Add bounds to prevent extreme calibration factors (e.g., 0.1x to 10x)
 594:          let newFactor = max(0.1, min(10.0, profile.calibrationFactor * adjustmentRatio))
 595:          print(&quot;Simple Calibration:&quot;)
 596:          print(&quot;  - Latest Sample: \(latestSample.value) \(latestSample.unit) on \(latestSample.date)&quot;)
 597:          print(&quot;  - Model Prediction (at sample date, current factor \(profile.calibrationFactor)): \(modelPrediction)&quot;)
 598:          print(&quot;  - Adjustment Ratio: \(adjustmentRatio)&quot;)
 599:          print(&quot;  - Old Factor: \(profile.calibrationFactor)&quot;)
 600:          print(&quot;  - New Factor (Clamped): \(newFactor)&quot;)
 601:         profile.calibrationFactor = newFactor
 602:         recalcSimulation() // Update chart data with the new factor
 603:         saveProfile()      // Persist the new factor
 604:         coreDataManager.saveContext() // Save immediately
 605:     }
 606:     // Bayesian calibration (currently applies result as a simple factor adjustment)
 607:     func calibrateProtocolWithBayesian(_ protocolToCalibrate: InjectionProtocol) {
 608:         guard !protocolToCalibrate.bloodSamples.isEmpty, protocolToCalibrate.bloodSamples.count &gt;= 2 else {
 609:             print(&quot;Bayesian calibration requires at least 2 blood samples. Falling back to simple calibration.&quot;)
 610:             calibrateProtocol(protocolToCalibrate) // Fallback if not enough samples
 611:             return
 612:         }
 613:         // Determine the compound/blend and dose for calibration
 614:         var compoundForCalibration: Compound?
 615:         var doseForCalibration: Double = protocolToCalibrate.doseMg
 616:         let route: Compound.Route = {
 617:             if let routeString = protocolToCalibrate.selectedRoute, let r = Compound.Route(rawValue: routeString) { return r }
 618:             return .intramuscular
 619:         }()
 620:         switch protocolToCalibrate.protocolType {
 621:         case .compound:
 622:             compoundForCalibration = protocolToCalibrate.compoundID.flatMap { compoundLibrary.compound(withID: $0) }
 623:         case .blend:
 624:             // Use the component with the largest contribution or longest half-life for calibration?
 625:             // For now, using the first component as an approximation. A more robust approach might be needed.
 626:             if let blendID = protocolToCalibrate.blendID,
 627:                let blend = compoundLibrary.blend(withID: blendID),
 628:                let mainComponent = blend.resolvedComponents(using: compoundLibrary).max(by: { $0.mgPerML &lt; $1.mgPerML }) { // Choose component with highest mg/mL
 629:                 compoundForCalibration = mainComponent.compound
 630:                 // Adjust dose proportionally for the main component
 631:                  guard blend.totalConcentration &gt; 0 else {
 632:                       print(&quot;Bayesian Calibration Error: Blend has zero total concentration.&quot;)
 633:                       calibrateProtocol(protocolToCalibrate); return // Fallback
 634:                  }
 635:                  doseForCalibration = mainComponent.mgPerML * protocolToCalibrate.doseMg / blend.totalConcentration
 636:             }
 637:         }
 638:         guard let compound = compoundForCalibration else {
 639:             print(&quot;Bayesian calibration failed: Could not determine valid compound for protocol \(protocolToCalibrate.name). Falling back.&quot;)
 640:             calibrateProtocol(protocolToCalibrate)
 641:             return
 642:         }
 643:         // Convert blood samples
 644:         let samplePoints = protocolToCalibrate.bloodSamples.map {
 645:             PKModel.SamplePoint(timestamp: $0.date, labValue: $0.value)
 646:         }
 647:         // Determine relevant injection dates (look back further for Bayesian)
 648:         let firstSampleDate = protocolToCalibrate.bloodSamples.map { $0.date }.min() ?? Date()
 649:         let lastSampleDate = protocolToCalibrate.bloodSamples.map { $0.date }.max() ?? Date()
 650:         // Look back significantly to capture buildup phase effects for Bayesian
 651:         let historyStartDate = Calendar.current.date(byAdding: .day, value: -180, to: firstSampleDate) ?? firstSampleDate
 652:         let injectionDates = protocolToCalibrate.injectionDates(from: historyStartDate, upto: lastSampleDate)
 653:         // Perform Bayesian calibration using the PKModel
 654:         if let calibrationResult = pkModel.bayesianCalibration(
 655:             samples: samplePoints,
 656:             injectionDates: injectionDates,
 657:             compound: compound,
 658:             dose: doseForCalibration, // Use the potentially adjusted dose for blends
 659:             route: route,
 660:             weight: profile.weight ?? 70.0
 661:         ) {
 662:             // --- Apply Calibration Result ---
 663:             // Option 1 (Current): Adjust the global calibration factor based on the overall fit improvement.
 664:             // Calculate average error before and after Bayesian adjustment to find the improvement factor.
 665:             let avgLabValue = samplePoints.reduce(0.0) { $0 + $1.labValue } / Double(samplePoints.count)
 666:              // Calculate average prediction using the *original* parameters but *current* calibration factor
 667:              // This represents the state *before* this Bayesian run, but after any previous simple calibrations
 668:              let avgPredictionBeforeBayesian = samplePoints.reduce(0.0) { sum, point in
 669:                   sum + calculateLevelForDate(point.timestamp, for: protocolToCalibrate) // Uses current profile.calibrationFactor internally
 670:              } / Double(samplePoints.count)
 671:             guard avgPredictionBeforeBayesian &gt; 0.01 else {
 672:                  print(&quot;Bayesian Calibration Apply Failed: Pre-Bayesian prediction average is too low.&quot;)
 673:                  calibrateProtocol(protocolToCalibrate) // Fallback
 674:                  return
 675:             }
 676:             // Calculate the ratio needed to align the pre-Bayesian average prediction with the average lab value
 677:             let adjustmentRatio = avgLabValue / avgPredictionBeforeBayesian
 678:             let newFactor = max(0.1, min(10.0, profile.calibrationFactor * adjustmentRatio)) // Apply adjustment relative to current factor
 679:             // Log details
 680:             print(&quot;--- Bayesian Calibration Results ---&quot;)
 681:             print(&quot;  Compound Used: \(compound.fullDisplayName)&quot;)
 682:             print(&quot;  Original Half-life: \(String(format: &quot;%.2f&quot;, log(2) / calibrationResult.originalKe)) days (ke: \(calibrationResult.originalKe))&quot;)
 683:             print(&quot;  Calibrated Half-life: \(String(format: &quot;%.2f&quot;, calibrationResult.halfLifeDays)) days (ke: \(calibrationResult.adjustedKe))&quot;)
 684:             print(&quot;  Half-life Change: \(String(format: &quot;%.1f&quot;, calibrationResult.halfLifeChangePercent))%&quot;)
 685:             print(&quot;  Original Ka: \(String(format: &quot;%.2f&quot;, calibrationResult.originalKa))&quot;)
 686:             print(&quot;  Calibrated Ka: \(String(format: &quot;%.2f&quot;, calibrationResult.adjustedKa))&quot;)
 687:             print(&quot;  Model Fit Correlation: \(String(format: &quot;%.3f&quot;, calibrationResult.correlation))&quot;)
 688:              print(&quot;  Adjustment Applied:&quot;)
 689:              print(&quot;    Avg Lab Value: \(avgLabValue)&quot;)
 690:              print(&quot;    Avg Prediction (Before Bayesian, Factor \(profile.calibrationFactor)): \(avgPredictionBeforeBayesian)&quot;)
 691:              print(&quot;    Adjustment Ratio: \(adjustmentRatio)&quot;)
 692:              print(&quot;    Old Global Factor: \(profile.calibrationFactor)&quot;)
 693:              print(&quot;    New Global Factor (Clamped): \(newFactor)&quot;)
 694:             print(&quot;------------------------------------&quot;)
 695:             // Apply the adjusted global factor
 696:             profile.calibrationFactor = newFactor
 697:             // Option 2 (Future): Store adjusted ke/ka per compound (more complex)
 698:             // This would involve updating the CompoundLibrary or creating user-specific compound parameters.
 699:             // Update simulation and save
 700:             recalcSimulation()
 701:             saveProfile()
 702:             coreDataManager.saveContext() // Save immediately
 703:         } else {
 704:             print(&quot;Bayesian calibration failed to produce results. Falling back to simple calibration.&quot;)
 705:             calibrateProtocol(protocolToCalibrate)
 706:         }
 707:     }
 708:     // MARK: - Value Formatting
 709:     func formatValue(_ value: Double, unit: String) -&gt; String {
 710:         let formatter = NumberFormatter()
 711:         formatter.numberStyle = .decimal
 712:         if unit == &quot;nmol/L&quot; {
 713:             formatter.maximumFractionDigits = 1
 714:         } else if unit == &quot;%&quot; {
 715:              formatter.maximumFractionDigits = 1
 716:         } else { // ng/dL typically whole numbers
 717:             formatter.maximumFractionDigits = 0
 718:         }
 719:         formatter.minimumFractionDigits = formatter.maximumFractionDigits // Ensure consistency
 720:         // Handle potential NaN or infinity
 721:         if !value.isFinite {
 722:              return &quot;N/A&quot;
 723:         }
 724:         return formatter.string(from: NSNumber(value: value)) ?? &quot;\(value)&quot;
 725:     }
 726:     // MARK: - Peak Predictions
 727:     func calculatePeakDetails(for injectionProtocol: InjectionProtocol) -&gt; (peakDate: Date, maxConcentration: Double) {
 728:         // Reuse the logic from generateSimulationData to get compounds and route
 729:          var compounds: [(compound: Compound, dosePerInjectionMg: Double)] = []
 730:          let route: Compound.Route
 731:          if let routeString = injectionProtocol.selectedRoute, let selectedRoute = Compound.Route(rawValue: routeString) {
 732:              route = selectedRoute
 733:          } else {
 734:              route = .intramuscular // Default route
 735:          }
 736:          switch injectionProtocol.protocolType {
 737:              case .compound:
 738:                  if let compoundID = injectionProtocol.compoundID, let compound = compoundLibrary.compound(withID: compoundID) {
 739:                       if (compound.defaultBioavailability[route] ?? 0) &gt; 0 {
 740:                            compounds = [(compound: compound, dosePerInjectionMg: injectionProtocol.doseMg)]
 741:                       }
 742:                  }
 743:              case .blend:
 744:                   if let blendID = injectionProtocol.blendID, let blend = compoundLibrary.blend(withID: blendID) {
 745:                        guard blend.totalConcentration &gt; 0 else { return (injectionProtocol.startDate, 0) }
 746:                        compounds = blend.resolvedComponents(using: compoundLibrary).map {
 747:                           (compound: $0.compound, dosePerInjectionMg: $0.mgPerML * injectionProtocol.doseMg / blend.totalConcentration)
 748:                        }
 749:                   }
 750:          }
 751:          if compounds.isEmpty {
 752:               if let fixedCompound = findLegacyCompound(for: injectionProtocol) {
 753:                    // Check if route is valid, otherwise just use it anyway (the route validation should happen elsewhere)
 754:                    if (fixedCompound.defaultBioavailability[route] ?? 0) &lt;= 0 {
 755:                         // Route not supported, but we&apos;ll try anyway
 756:                         print(&quot;Warning: Selected route not optimal for peak calculation&quot;)
 757:                         if !fixedCompound.defaultBioavailability.keys.contains(where: { (fixedCompound.defaultBioavailability[$0] ?? 0) &gt; 0 }) {
 758:                              return (peakDate: injectionProtocol.startDate, maxConcentration: 0) // No valid routes at all
 759:                         }
 760:                    }
 761:                    compounds = [(compound: fixedCompound, dosePerInjectionMg: injectionProtocol.doseMg)]
 762:               } else {
 763:                    print(&quot;Error calculating peak: No valid compounds for protocol \(injectionProtocol.name)&quot;)
 764:                    return (peakDate: injectionProtocol.startDate, maxConcentration: 0)
 765:               }
 766:          }
 767:         // Define time window (e.g., first 90 days of the protocol)
 768:         let timeWindow = (
 769:             start: injectionProtocol.startDate,
 770:             end: injectionProtocol.startDate.addingTimeInterval(simulationDurationDays * 24 * 3600)
 771:         )
 772:         // Get all injection dates within the window
 773:         let injectionDates = injectionProtocol.injectionDates(
 774:             from: timeWindow.start, // Need injections from the actual start
 775:             upto: timeWindow.end
 776:         )
 777:         // Use PKModel to calculate peak details
 778:         let pkModel = createPKModel()
 779:         return pkModel.calculateProtocolPeakDetails(
 780:             injectionDates: injectionDates,
 781:             compounds: compounds,
 782:             route: route,
 783:             timeWindow: timeWindow,
 784:             weight: profile.weight ?? 70.0,
 785:             calibrationFactor: profile.calibrationFactor
 786:         )
 787:     }
 788:     func calculateSingleDosePeakDetails(for injectionProtocol: InjectionProtocol) -&gt; (timeToMaxDays: Double, maxConcentration: Double) {
 789:          // Reuse logic to get compounds and route
 790:          var compounds: [(compound: Compound, doseMg: Double)] = []
 791:          let route: Compound.Route
 792:          if let routeString = injectionProtocol.selectedRoute, let selectedRoute = Compound.Route(rawValue: routeString) {
 793:              route = selectedRoute
 794:          } else {
 795:              route = .intramuscular // Default route
 796:          }
 797:          switch injectionProtocol.protocolType {
 798:              case .compound:
 799:                  if let compoundID = injectionProtocol.compoundID, let compound = compoundLibrary.compound(withID: compoundID) {
 800:                       if (compound.defaultBioavailability[route] ?? 0) &gt; 0 {
 801:                            compounds = [(compound: compound, doseMg: injectionProtocol.doseMg)]
 802:                       }
 803:                  }
 804:              case .blend:
 805:                   if let blendID = injectionProtocol.blendID, let blend = compoundLibrary.blend(withID: blendID) {
 806:                        guard blend.totalConcentration &gt; 0 else { return (0, 0) }
 807:                        compounds = blend.resolvedComponents(using: compoundLibrary).map {
 808:                           (compound: $0.compound, doseMg: $0.mgPerML * injectionProtocol.doseMg / blend.totalConcentration)
 809:                        }
 810:                   }
 811:          }
 812:          if compounds.isEmpty {
 813:               if let fixedCompound = findLegacyCompound(for: injectionProtocol) {
 814:                    // Check if route is valid, otherwise just use it anyway (the route validation should happen elsewhere)
 815:                    if (fixedCompound.defaultBioavailability[route] ?? 0) &lt;= 0 {
 816:                         // Route not supported, but we&apos;ll try anyway
 817:                         print(&quot;Warning: Selected route not optimal for single dose peak calculation&quot;)
 818:                         if !fixedCompound.defaultBioavailability.keys.contains(where: { (fixedCompound.defaultBioavailability[$0] ?? 0) &gt; 0 }) {
 819:                              return (0, 0) // No valid routes at all
 820:                         }
 821:                    }
 822:                    compounds = [(compound: fixedCompound, doseMg: injectionProtocol.doseMg)]
 823:               } else {
 824:                   print(&quot;Error calculating single dose peak: No valid compounds.&quot;)
 825:                    return (timeToMaxDays: 0, maxConcentration: 0)
 826:               }
 827:          }
 828:         // For single dose peak, if it&apos;s a blend, use the specialized blend peak calculation
 829:         if injectionProtocol.protocolType == .blend {
 830:             let pkModel = createPKModel()
 831:             return pkModel.calculateBlendPeakDetails(
 832:                 components: compounds,
 833:                 route: route,
 834:                 weight: profile.weight ?? 70.0,
 835:                 calibrationFactor: profile.calibrationFactor
 836:             )
 837:         }
 838:         // Otherwise (single compound), use the standard single dose calculation
 839:         else if let firstCompound = compounds.first {
 840:             let bioavailability = firstCompound.compound.defaultBioavailability[route] ?? 1.0
 841:             let absorptionRate = firstCompound.compound.defaultAbsorptionRateKa[route] ?? 0.7
 842:             let pkModel = createPKModel()
 843:             let timeToMax = pkModel.calculateTimeToMaxConcentration(
 844:                 dose: firstCompound.doseMg,
 845:                 halfLifeDays: firstCompound.compound.halfLifeDays,
 846:                 absorptionRateKa: absorptionRate,
 847:                 bioavailability: bioavailability,
 848:                 weight: profile.weight ?? 70.0,
 849:                 calibrationFactor: profile.calibrationFactor
 850:             )
 851:             let maxConc = pkModel.calculateMaxConcentration(
 852:                 dose: firstCompound.doseMg,
 853:                 halfLifeDays: firstCompound.compound.halfLifeDays,
 854:                 absorptionRateKa: absorptionRate,
 855:                 bioavailability: bioavailability,
 856:                 weight: profile.weight ?? 70.0,
 857:                 calibrationFactor: profile.calibrationFactor
 858:             )
 859:             return (timeToMaxDays: timeToMax, maxConcentration: maxConc)
 860:         }
 861:         return (timeToMaxDays: 0, maxConcentration: 0) // Fallback
 862:     }
 863:     // MARK: - Adherence Tracking Interface
 864:     func acknowledgeInjection(protocolID: UUID, injectionDate: Date) {
 865:         notificationManager.acknowledgeInjection(protocolID: protocolID, injectionDate: injectionDate)
 866:         print(&quot;Acknowledged injection for protocol \(protocolID) scheduled on \(injectionDate)&quot;)
 867:     }
 868:     func adherenceStats() -&gt; (total: Int, onTime: Int, late: Int, missed: Int) {
 869:         return notificationManager.adherenceStats()
 870:     }
 871:     func adherencePercentage() -&gt; Double {
 872:         return notificationManager.adherencePercentage()
 873:     }
 874:     func injectionHistory(for protocolID: UUID? = nil) -&gt; [NotificationManager.InjectionRecord] {
 875:         return notificationManager.injectionHistory(for: protocolID)
 876:     }
 877:     func cleanupOldRecords() {
 878:         notificationManager.cleanupOldRecords()
 879:         print(&quot;Cleaned up old injection records.&quot;)
 880:     }
 881:     // MARK: - Cycle Management
 882:     func loadCyclesFromCoreData() {
 883:         let context = coreDataManager.persistentContainer.viewContext
 884:         let fetchRequest: NSFetchRequest&lt;CDCycle&gt; = CDCycle.fetchRequest()
 885:         // Add sort descriptor to load cycles in a consistent order (e.g., by start date)
 886:         fetchRequest.sortDescriptors = [NSSortDescriptor(key: &quot;startDate&quot;, ascending: true)]
 887:         do {
 888:             let cdCycles = try context.fetch(fetchRequest)
 889:             self.cycles = cdCycles.map { Cycle(from: $0, context: context) } // Pass context if needed by Cycle init
 890:             print(&quot;Loaded \(self.cycles.count) cycles from Core Data.&quot;)
 891:         } catch {
 892:             print(&quot;Error loading cycles from Core Data: \(error)&quot;)
 893:             self.cycles = [] // Ensure cycles is empty on error
 894:         }
 895:     }
 896:     func saveCycle(_ cycle: Cycle) {
 897:         let context = coreDataManager.persistentContainer.viewContext
 898:         // Save to Core Data (create or update)
 899:         _ = cycle.save(to: context)
 900:         do {
 901:             try context.save()
 902:             // Refresh cycles from Core Data to update the @Published array
 903:             loadCyclesFromCoreData()
 904:             print(&quot;Saved cycle: \(cycle.name)&quot;)
 905:         } catch {
 906:             print(&quot;Error saving cycle \(cycle.name): \(error)&quot;)
 907:         }
 908:     }
 909:     func deleteCycle(with id: UUID) {
 910:         let context = coreDataManager.persistentContainer.viewContext
 911:         let fetchRequest: NSFetchRequest&lt;CDCycle&gt; = CDCycle.fetchRequest()
 912:         fetchRequest.predicate = NSPredicate(format: &quot;id == %@&quot;, id as CVarArg)
 913:         do {
 914:             if let cdCycle = try context.fetch(fetchRequest).first {
 915:                 let cycleName = cdCycle.name ?? &quot;Unknown&quot;
 916:                 context.delete(cdCycle)
 917:                 try context.save()
 918:                 // Refresh cycles from Core Data
 919:                 loadCyclesFromCoreData()
 920:                 // If this was the selected cycle, deselect it
 921:                 if selectedCycleID == id {
 922:                     selectedCycleID = nil
 923:                     isCycleSimulationActive = false
 924:                     cycleSimulationData = []
 925:                 }
 926:                 print(&quot;Deleted cycle: \(cycleName)&quot;)
 927:             } else {
 928:                 print(&quot;Error deleting cycle: Cycle with ID \(id) not found.&quot;)
 929:             }
 930:         } catch {
 931:             print(&quot;Error deleting cycle with ID \(id): \(error)&quot;)
 932:         }
 933:     }
 934:     func selectCycle(id: UUID?) {
 935:          guard let id = id else {
 936:               selectedCycleID = nil
 937:               cycleSimulationData = []
 938:               isCycleSimulationActive = false
 939:               print(&quot;Cycle deselected.&quot;)
 940:               return
 941:          }
 942:          // Only proceed if the selected ID exists
 943:          guard cycles.contains(where: { $0.id == id }) else {
 944:               print(&quot;Error: Attempted to select non-existent cycle ID: \(id)&quot;)
 945:               // Optionally select the first available cycle if selection is invalid
 946:               if let firstID = cycles.first?.id {
 947:                    selectedCycleID = firstID
 948:                    simulateCycle(id: firstID) // Simulate the first one instead
 949:               } else {
 950:                    selectedCycleID = nil
 951:                    cycleSimulationData = []
 952:                    isCycleSimulationActive = false
 953:               }
 954:               return
 955:          }
 956:          // Simulate if selection changed or simulation isn&apos;t active
 957:          if selectedCycleID != id || !isCycleSimulationActive {
 958:               selectedCycleID = id
 959:               simulateCycle(id: id)
 960:               print(&quot;Selected cycle: \(cycles.first { $0.id == id }?.name ?? &quot;Unknown&quot;)&quot;)
 961:          }
 962:      }
 963:     func simulateCycle(id: UUID) { // Changed parameter to non-optional for clarity
 964:         guard let cycle = cycles.first(where: { $0.id == id }) else {
 965:             print(&quot;SimulateCycle Error: Cycle with ID \(id) not found.&quot;)
 966:             cycleSimulationData = []
 967:             isCycleSimulationActive = false
 968:             return
 969:         }
 970:         // Create temporary protocols for simulation
 971:         let tempProtocols = cycle.generateTemporaryProtocols(compoundLibrary: compoundLibrary)
 972:         if tempProtocols.isEmpty {
 973:             print(&quot;No protocols generated for cycle \(cycle.name). Clearing simulation.&quot;)
 974:             cycleSimulationData = []
 975:             isCycleSimulationActive = false
 976:             return
 977:         }
 978:         print(&quot;Simulating cycle: \(cycle.name) with \(tempProtocols.count) derived protocols...&quot;)
 979:         let pkModel = createPKModel()
 980:         cycleSimulationData = [] // Clear previous data
 981:         // Determine simulation range based on cycle dates
 982:         let calendar = Calendar.current
 983:         let startDate = cycle.startDate
 984:         // Ensure end date calculation is robust
 985:         guard let endDate = calendar.date(byAdding: .day, value: cycle.totalWeeks * 7, to: startDate) else {
 986:             print(&quot;Error calculating cycle end date.&quot;)
 987:             cycleSimulationData = []
 988:             isCycleSimulationActive = false
 989:             return
 990:         }
 991:         let simulationDates = generateSimulationDates(
 992:             startDate: startDate,
 993:             endDate: endDate,
 994:             interval: 0.5 // Consistent interval for cycle charts (e.g., twice daily)
 995:         )
 996:         if simulationDates.isEmpty {
 997:             print(&quot;Error: No simulation dates generated for cycle.&quot;)
 998:             cycleSimulationData = []
 999:             isCycleSimulationActive = false
1000:             return
1001:         }
1002:         var totalConcentrations = Array(repeating: 0.0, count: simulationDates.count)
1003:         let weight = profile.weight ?? 70.0
1004:         // Accumulate concentrations from each derived protocol
1005:         for treatmentProtocol in tempProtocols {
1006:             var compounds: [(compound: Compound, dosePerInjectionMg: Double)] = []
1007:             let route: Compound.Route = {
1008:                 if let routeString = treatmentProtocol.selectedRoute, let r = Compound.Route(rawValue: routeString) { return r }
1009:                 return .intramuscular
1010:             }()
1011:             // Get compounds/blend for this temporary protocol
1012:             switch treatmentProtocol.protocolType {
1013:                 case .compound:
1014:                     if let compoundID = treatmentProtocol.compoundID, let c = compoundLibrary.compound(withID: compoundID), (c.defaultBioavailability[route] ?? 0) &gt; 0 {
1015:                         compounds = [(c, treatmentProtocol.doseMg)]
1016:                     }
1017:                 case .blend:
1018:                     if let blendID = treatmentProtocol.blendID, let b = compoundLibrary.blend(withID: blendID), b.totalConcentration &gt; 0 {
1019:                          compounds = b.resolvedComponents(using: compoundLibrary).map { rc in
1020:                              (rc.compound, treatmentProtocol.doseMg * (rc.mgPerML / b.totalConcentration))
1021:                          }
1022:                     }
1023:             }
1024:             if compounds.isEmpty {
1025:                 print(&quot;Warning: Skipping empty/invalid protocol &apos;\(treatmentProtocol.name)&apos; in cycle simulation.&quot;)
1026:                 continue // Skip this protocol if no valid compounds
1027:             }
1028:             // Generate injection dates for this specific protocol within the cycle&apos;s timeframe
1029:             let injectionDates = treatmentProtocol.injectionDates(from: startDate, upto: endDate)
1030:             // Calculate concentrations for this protocol
1031:             let concentrations = pkModel.protocolConcentrations(
1032:                 at: simulationDates,
1033:                 injectionDates: injectionDates,
1034:                 compounds: compounds,
1035:                 route: route,
1036:                 weight: weight,
1037:                 calibrationFactor: profile.calibrationFactor
1038:             )
1039:             // Add to the total concentrations
1040:             for i in 0..&lt;min(totalConcentrations.count, concentrations.count) {
1041:                 totalConcentrations[i] += concentrations[i]
1042:             }
1043:         }
1044:         // Convert to DataPoints
1045:         cycleSimulationData = zip(simulationDates, totalConcentrations).map {
1046:             DataPoint(time: $0, level: $1.isNaN ? 0 : $1)
1047:         }
1048:         isCycleSimulationActive = true // Mark simulation as active
1049:         print(&quot;Cycle simulation complete for \(cycle.name). Generated \(cycleSimulationData.count) points.&quot;)
1050:     }
1051:     // MARK: - Notification Management Interface
1052:     func toggleNotifications(enabled: Bool) {
1053:         notificationManager.notificationsEnabled = enabled
1054:         if enabled {
1055:             Task {
1056:                 let granted = await notificationManager.requestNotificationPermission()
1057:                 if granted {
1058:                     await scheduleAllNotifications()
1059:                     print(&quot;Notifications enabled and scheduled.&quot;)
1060:                 } else {
1061:                     // Permission denied - update state and potentially UI
1062:                     await MainActor.run {
1063:                         notificationManager.notificationsEnabled = false
1064:                         self.profile.usesICloudSync = false // Example UI update if needed
1065:                         print(&quot;Notification permission denied.&quot;)
1066:                     }
1067:                 }
1068:             }
1069:         } else {
1070:             notificationManager.cancelAllNotifications()
1071:             print(&quot;Notifications disabled and cancelled.&quot;)
1072:         }
1073:     }
1074:     func setNotificationSound(enabled: Bool) {
1075:         notificationManager.soundEnabled = enabled
1076:         // Reschedule all notifications to apply sound setting change
1077:         if notificationManager.notificationsEnabled {
1078:             Task {
1079:                 await scheduleAllNotifications()
1080:                 print(&quot;Notification sound setting updated and notifications rescheduled.&quot;)
1081:             }
1082:         }
1083:     }
1084:     func setNotificationLeadTime(_ leadTime: NotificationManager.LeadTime) {
1085:         notificationManager.selectedLeadTime = leadTime
1086:         // Reschedule all notifications to apply lead time change
1087:         if notificationManager.notificationsEnabled {
1088:             Task {
1089:                 await scheduleAllNotifications()
1090:                 print(&quot;Notification lead time updated to \(leadTime.rawValue) and notifications rescheduled.&quot;)
1091:             }
1092:         }
1093:     }
1094:     // Schedules notifications for ALL current protocols
1095:     func scheduleAllNotifications() async {
1096:         guard notificationManager.notificationsEnabled else { return }
1097:         // Ensure permission is granted before scheduling
1098:         let granted = await notificationManager.requestNotificationPermission()
1099:         if !granted {
1100:             await MainActor.run {
1101:                  notificationManager.notificationsEnabled = false // Reflect denial in state
1102:                  // Maybe update UI toggle? Requires binding or callback
1103:             }
1104:             print(&quot;Cannot schedule notifications: Permission denied.&quot;)
1105:             return
1106:         }
1107:         print(&quot;Scheduling notifications for \(profile.protocols.count) protocols...&quot;)
1108:         // Cancel all existing first to avoid duplicates if rescheduling
1109:         notificationManager.cancelAllNotifications()
1110:         // Schedule for each protocol
1111:         for p in profile.protocols {
1112:             notificationManager.scheduleNotifications(for: p, using: compoundLibrary)
1113:         }
1114:         print(&quot;Notification scheduling complete.&quot;)
1115:     }
1116: } // End of AppDataStore class

================
File: guide2.md
================
   1: # TestoSim Implementation Progress
   2: 
   3: ## Progress Summary
   4: | Story | Description | Status |
   5: |-------|-------------|--------|
   6: | 8 | Compound Library &amp; Blends | ✅ 100% Complete (UI and selection standardized) |
   7: | 9 | Refined PK Engine | ✅ 100% Complete (UI and allometric scaling explained) |
   8: | 10 | User Profile 2.0 &amp; Persistence | ✅ 100% Complete (CloudKit integration fixed) |
   9: | 11 | Notifications &amp; Adherence | ✅ 100% Complete |
  10: | 12 | Cycle Builder | ✅ 100% Complete |
  11: | 13 | AI Insights | ✅ 100% Complete (OpenAI integration with GPT-4o-mini model and free test API key - $20 limit) |
  12: | 14 | UI/UX Polish &amp; Animations | ❌ 0% Not Started (Next in pipeline) |
  13: | 15 | Testing &amp; Validation | ❌ 0% Not Started (Final stage) |
  14: | 16 | Help Center &amp; Documentation | ❌ 0% Not Started |
  15: 
  16: ## Code Conventions &amp; Naming Guidelines
  17: 
  18: To avoid build errors and conflicts in the codebase, follow these naming conventions:
  19: 
  20: | Issue | Convention |
  21: |-------|------------|
  22: | Swift Keywords | Never use Swift reserved keywords (`protocol`, `class`, `struct`, etc.) as variable names |
  23: | Protocol Variables | Use `treatmentProtocol` or `protocolItem` instead of `protocol` for InjectionProtocol variables |
  24: | Struct Names | Prefix struct names with context (e.g., `InjectionAdherenceStatsView`, `NotificationAdherenceStatsView`) |
  25: | Common Error Avoidance | When looping through protocol collections, always use: `for treatmentProtocol in protocols` or `for item in protocols` |
  26: 
  27: ### Fixed Codebase Issues:
  28: - ✅ AppDataStore.swift - Fixed `for protocol in deletedProtocols` to `for item in deletedProtocols`
  29: - ✅ InjectionHistoryView.swift - Fixed duplicate struct `AdherenceStatsView` to `InjectionAdherenceStatsView`
  30: - ✅ NotificationSettingsView.swift - Renamed `AdherenceStatsView` to `NotificationAdherenceStatsView`
  31: - ✅ Protocol parameter in functions - Changed to `treatmentProtocol` where used as a parameter name
  32: 
  33: **Note**: Using Swift keywords as variable names results in compile-time errors like `expected pattern` or `expected Sequence expression`.
  34: 
  35: ## Missing Frontend Implementations
  36: 
  37: The following backend features have been implemented but need UI components:
  38: 
  39: | Feature | Backend Status | Frontend Status | Description |
  40: |---------|---------------|-----------------|-------------|
  41: | Compound Library &amp; Blends | ✅ Complete | ✅ Implemented | UI for selecting from full compound library and blends has been added |
  42: | VialBlend Presets | ✅ Complete | ✅ Implemented | Added VialBlendListView to select pre-defined commercial blends |
  43: | Bayesian Calibration Details | ✅ Complete | ✅ Implemented | Added CalibrationResultView to display detailed calibration results |
  44: | Route Selection | ✅ Complete | ✅ Implemented | Added dropdown to protocol form for selecting administration route |
  45: | Two-Compartment Toggle | ✅ Complete | ✅ Implemented | Added toggle in Profile Settings with explanatory info popup |
  46: | Allometric Scaling Info | ✅ Complete | ✅ Implemented | Added explanatory view in Profile explaining how measurements affect calculations |
  47: | CloudKit Sync Toggle | ✅ Complete | ✅ Added | Toggle exists in settings and CloudKit integration has been fixed |
  48: | Compound Selection Standardization | ✅ Complete | ✅ Implemented | Simplified UI to use the Compound model instead of redundant TestosteroneEster model |
  49: | Notification &amp; Adherence System | ✅ Complete | ✅ Implemented | Added full notification system with adherence tracking and statistics |
  50: | Help Center &amp; Documentation | ⚠️ Partial | ❌ Not Started | Need to create centralized help system with dedicated views for each topic |
  51: 
  52: **Priority Tasks:**
  53: 0. ✅ start by adding a test user profile to the app and fill in the values, as well as a test protocol, this will help us testing the app with out having to type in the values every time, it should be easy to delete this after testing. (also add in this document when we should remove this test data)
  54:    * ✅ Created a dedicated test profile with realistic user information in AppDataStore
  55:    * ✅ Added multiple test protocols with various compounds and routes
  56:    * ✅ Implemented a `resetToDefaultProfile()` function for easy cleanup
  57:    * ✅ Added test blood samples to evaluate calibration functionality
  58:    * Target removal: After completing implementation of Stories 8-10
  59: 
  60: 1. ✅ Add UI for compound library and blend selection in protocol form
  61:    * ✅ Created `CompoundListView` to display and filter compounds by class/route
  62:    * ✅ Created `VialBlendListView` to browse pre-defined commercial blends
  63:    * ✅ Updated `ProtocolFormView` with a segmented control to choose between:
  64:      - Single Compound selection
  65:      - Vial Blend selection
  66:    * ✅ Added compound/blend picker that replaces the existing testosterone ester picker
  67:    * ✅ Updated `InjectionProtocol` model to support either compound or blend
  68: 
  69: 2. ✅ Add route selection dropdown to protocol form
  70:    * ✅ Added a `Picker` for `Compound.Route` in `ProtocolFormView`
  71:    * ✅ Updated the UI to dynamically show/hide route picker based on context
  72:    * ✅ Updated `InjectionProtocol` to store the selected route
  73:    * ✅ Added validation to ensure route is compatible with selected compound
  74:    * ✅ Connected route selection to the PK engine calculations
  75: 
  76: 3. ✅ Create CalibrationResultView to show detailed Bayesian calibration results
  77:    * ✅ Created new view to display:
  78:      - Correlation coefficient (model fit quality)
  79:      - Original vs. calibrated parameter values
  80:      - Visual representation of fit improvement
  81:    * ✅ Added navigation link from ProtocolDetailView to CalibrationResultView
  82:    * ✅ Implemented the model parameter adjustment visualization
  83:    * ✅ Added explanatory text about the meaning of calibration parameters
  84:    * ✅ Fixed Swift keyword issue by renaming &apos;protocol&apos; to &apos;treatmentProtocol&apos;
  85:    * ✅ Fixed DataPoint parameter references to use &apos;time&apos; and &apos;level&apos; instead of &apos;date&apos; and &apos;value&apos;
  86: 
  87: 4. ✅ Complete the Tp, Cmax predictions in the PK Engine
  88:    * ✅ Added `calculateTimeToMaxConcentration()` and `calculateMaxConcentration()` functions to `PKModel`
  89:    * ✅ Implemented the time-to-peak calculation for one and two-compartment models
  90:    * ✅ Added specialized methods for blend and protocol peak finding
  91:    * ✅ Exposed these values in the UI on the protocol detail screen
  92:    * ✅ Added visual markers on the chart for Tp and Cmax points with toggle
  93: 
  94: 5. ✅ Bug fixes and code quality improvements
  95:    * ✅ Fixed property name mismatches in UserProfile references (dob→dateOfBirth, height→heightCm)
  96:    * ✅ Fixed mutable properties declarations in AppDataStore (let→var for variables that need modification)
  97:    * ✅ Fixed Swift keyword usage in CalibrationResultView.swift (renamed &apos;protocol&apos; parameter to &apos;treatmentProtocol&apos;)
  98:    * ✅ Fixed parameter naming in DataPoint references (time/level instead of date/value)
  99:    * ✅ Updated all references to match the new parameter names
 100:    * ✅ Resolved &quot;unable to type-check this expression in reasonable time&quot; error in ProtocolListView by breaking down complex views
 101:    * ✅ Re-enabled TestosteroneChart in ProtocolDetailView after resolving compiler issues
 102:    * ✅ Build is now successful and app runs cleanly
 103: 
 104: 6. ✅ Re-enable CloudKit integration for data persistence
 105:    * ✅ Fixed container ID issues in CoreDataManager
 106:      * Used &quot;iCloud.flight505.TestoSim&quot; as the CloudKit container ID, matching the entitlements file
 107:      * Added conditional logic to use NSPersistentCloudKitContainer only when iCloud sync is enabled
 108:      * Fixed CoreDataManager to properly cast the container when initializing CloudKit schema
 109:    * ✅ Fixed migration logic for seamless transition
 110:      * Updated CoreDataManager.migrateUserProfileFromJSON() to handle new properties
 111:      * Stored extended properties (protocolType, compoundID, blendID, selectedRoute) in notes field as JSON
 112:    * ✅ Added proper error handling for CloudKit operations
 113:      * Improved error logging for CloudKit-specific issues
 114:      * Added notification for when CloudKit sync settings are changed
 115:    * ✅ Added sync status indicators in the UI
 116:      * Added isCloudSyncEnabled() method to check current sync status
 117:      * Improved enableCloudSync method to notify when a restart is required
 118: 
 119: 7. ✅ UI standardization for compound selection
 120:    * ✅ Removed redundant TestosteroneEster option from protocol creation
 121:    * ✅ Updated ProtocolFormView to focus on Compound and Blend selection options
 122:    * ✅ Added automatic conversion of legacy protocols to use the Compound model
 123:    * ✅ Updated ProtocolDetailView to display compound information for all protocols
 124:    * ✅ Updated ProtocolListView to use proper compound/blend protocol display
 125:    * ✅ Maintained backward compatibility for existing protocols
 126: 
 127: 8. ✅ Implement notification system for injection adherence
 128:    * ✅ **Created NotificationManager class**
 129:      * ✅ Implemented `UNUserNotificationCenter.requestAuthorization` for permissions
 130:      * ✅ Added methods to schedule, update, and cancel injection reminders
 131:      * ✅ Added support for different notification sounds and actions
 132: 
 133:    * ✅ **Integrated with protocol management**
 134:      * ✅ After each protocol edit, scheduled next-dose alert with `UNCalendarNotificationTrigger` 
 135:      * ✅ Implemented proper notification timing based on protocol schedule
 136:      * ✅ Added update notifications for protocol changes and deletions
 137: 
 138:    * ✅ **Added notification preferences**
 139:      * ✅ Created UI settings for lead-time options (1h / 6h / 12h before injection)
 140:      * ✅ Added toggle for notification sounds
 141:      * ✅ Implemented proper notification handling with feedback
 142:      
 143:    * ✅ **Implemented adherence tracking**
 144:      * ✅ Created system to record when users acknowledge injections
 145:      * ✅ Added tracking for adherence statistics (on-time, late, missed)
 146:      * ✅ Created InjectionHistoryView to visualize adherence data
 147:      * ✅ Added adherence rate display in profile view
 148: 
 149: ---
 150: 
 151: ## Story 8 — Compound Library &amp; Blends
 152: 
 153: *Data and utilities for single esters **and** multi-ester vials.*
 154: 
 155: * [x] **Create `Compound.swift`** data model (see code block).
 156: * [x] **Create `VialBlend.swift`** to describe commercial mixtures (each `Component` maps to a `Compound`).
 157: * [x] **Populate `CompoundLibrary.swift`** with the literature half-lives below:
 158: 
 159:   * [x] Testosterone propionate 0.8 d ([Wikipedia][1])
 160:   * [x] Testosterone phenylpropionate 2.5 d ([Iron Daddy][2])
 161:   * [x] Testosterone isocaproate 3.1 d ([Cayman Chemical][3])
 162:   * [x] Testosterone decanoate 7-14 d (use 10 d midpoint) ([BloomTechz][4])
 163:   * [x] Injectable testosterone undecanoate 18-24 d ([PubMed][5], [Wikipedia][6])
 164:   * [x] Oral testosterone undecanoate t½ 1.6 h, F = 0.07 ([Wikipedia][6])
 165:   * [x] Nandrolone decanoate 6-12 d ([Wikipedia][7])
 166:   * [x] Boldenone undecylenate ≈123 h ([ScienceDirect][8])
 167:   * [x] Trenbolone acetate 1-2 d ([ScienceDirect][9])
 168:   * [x] Trenbolone enanthate 11 d / hexahydrobenzylcarbonate 8 d ([Wikipedia][10])
 169:   * [x] Stanozolol IM suspension 24 h ([Wikipedia][11])
 170:   * [x] Drostanolone propionate 2 d ([Wikipedia][12])
 171:   * [x] Drostanolone enanthate ≈5 d ([Wikipedia][12])
 172:   * [x] Metenolone enanthate 10.5 d ([Wikipedia][13])
 173:   * [x] Trestolone (MENT) acetate t½ 40 min IV ≈ 2 h SC ([PubMed][14])
 174:   * [x] 1-Testosterone (DHB) cypionate ≈8 d (class analogue) ([Wikipedia][15])
 175: * [x] **Define `VialBlend` constants** for: Sustanon 250/350/400, Winstrol Susp 50, Masteron P 100 &amp; E 200, Primobolan E 100, Tren Susp 50, Tren A 100, Tren E 200, Tren Hex 76, Tren Mix 150, Cut-Stack 150 &amp; 250, MENT Ac 50, DHB Cyp 100 (per-mL mg in guide&apos;s table).
 176: * [x] **Library helpers**: `blends(containing:)`, `class(is:)`, `route(_:)`, and half-life range filters.
 177: * [x] **UI: Create CompoundView** to browse and select from all compounds.
 178: * [x] **UI: Create VialBlendView** to browse and select from pre-defined blends.
 179: * [x] **UI: Update ProtocolFormView** to allow selection of any Compound or VialBlend instead of just TestosteroneEster.
 180: * [x] **UI: Add route selection** dropdown to protocol form for choosing administration route.
 181: 
 182: ```swift
 183: struct Compound: Identifiable, Codable, Hashable {
 184:     enum Class: String, Codable { case testosterone, nandrolone, trenbolone,
 185:                                    boldenone, drostanolone, stanozolol, metenolone,
 186:                                    trestolone, dhb }
 187:     enum Route: String, Codable { case intramuscular, subcutaneous, oral, transdermal }
 188:     let id: UUID
 189:     var commonName: String
 190:     var classType: Class
 191:     var ester: String?          // nil for suspensions
 192:     var halfLifeDays: Double
 193:     var defaultBioavailability: [Route: Double]
 194:     var defaultAbsorptionRateKa: [Route: Double] // d-¹
 195: }
 196: ```
 197: 
 198: ---
 199: 
 200: ## Story 9 — Refined PK Engine
 201: 
 202: *Accurate curves for any route, any blend.*
 203: 
 204: * [x] **Implement `PKModel.concentration`**
 205: 
 206:   $$
 207:   C(t)=\frac{F\,D\,k_a}{V_d\,(k_a-k_e)}\bigl(e^{-k_e t}-e^{-k_a t}\bigr)
 208:   $$
 209: 
 210:   where $k_e=\ln2/t_{1/2}$.\* Units = days\* ([UF College of Pharmacy][16])
 211: 
 212: * [x] **Optional two-compartment flag**; derive α, β from $k_{12}=0.3$, $k_{21}=0.15$ d⁻¹ ([UF College of Pharmacy][16])
 213: 
 214: * [x] **Allometric scaling**:
 215:   $V_{d,\text{user}} = V_{d,70}(WT/70)^{1.0}$;
 216:   $CL_{\text{user}} = CL_{70}(WT/70)^{0.75}$ ([PubMed][17])
 217: 
 218: * [x] **Route parameters** (defaults in `CompoundLibrary`):
 219: 
 220:   | Ester               | k&lt;sub&gt;a&lt;/sub&gt; (d⁻¹ IM) | Oral F | Notes                               |
 221:   | ------------------- | ---------------------- | ------ | ----------------------------------- |
 222:   | Propionate          | 0.70                   | —      | Fastest IM absorption               |
 223:   | Phenylpropionate    | 0.50                   | —      | Moderate-fast absorption            |
 224:   | Isocaproate         | 0.35                   | —      | Medium absorption                   |
 225:   | Enanthate           | 0.30                   | —      | Medium absorption                   |
 226:   | Cypionate           | 0.25                   | —      | Longer absorption                   |
 227:   | Decanoate           | 0.18                   | —      | Extended absorption                 |
 228:   | Undecanoate         | 0.15                   | 0.07   | Slowest IM absorption; low oral F   |
 229: 
 230: * [x] **Fix compoundFromEster method** to properly match TestosteroneEster to Compound with safe error handling
 231: 
 232: * [x] **Bayesian calibration** using trough samples
 233:   * Implemented with gradient descent optimization
 234:   * Adjusts elimination (ke) and absorption (ka) rates based on blood samples
 235:   * Maintains parameters within reasonable bounds (0.5x to 2.0x of literature values)
 236:   * Includes correlation calculation to evaluate model fit quality
 237: 
 238: * [x] **Accurate T&lt;sub&gt;p&lt;/sub&gt;, C&lt;sub&gt;max&lt;/sub&gt;** predictions
 239: 
 240: * [x] **UI: Create CalibrationResultView** to show detailed Bayesian calibration results including correlation coefficient and parameter adjustments.
 241: * [x] **UI: Add two-compartment model toggle** in Profile Settings to enable/disable more accurate but intensive calculations.
 242:   * Added toggle in UserProfile model with proper Core Data persistence
 243:   * Created helper method in AppDataStore to consistently create PKModel instances
 244:   * Updated all simulation methods to use the user&apos;s two-compartment model preference
 245:   * Added informational popup explaining the benefits and performance implications
 246: 
 247: * [x] **UI: Add explainer for allometric scaling** to inform users how their physical measurements improve calculation accuracy.
 248:   * Created comprehensive AllometricInfoView with visual explanations of scaling equations
 249:   * Added button in Physical Measurements section to access the explainer
 250:   * Included scientific basis and benefits of providing accurate measurements
 251:   * Used clear visualizations to demonstrate how body size affects pharmacokinetics
 252: 
 253: ---
 254: 
 255: ## Story 10 — User Profile 2.0 &amp; Persistence
 256: 
 257: *Personalisation + seamless cloud backup.*
 258: 
 259: * [x] Extend `UserProfile` with DOB, height cm, weight kg, biologicalSex, `usesICloudSync`; compute `bodySurfaceArea` (DuBois).
 260: * [x] Migrate storage to **Core Data + CloudKit** with `NSPersistentCloudKitContainer` ([Apple Developer][18])
 261:   * Core Data model has been created with proper entity relationships and attributes
 262:   * Container configuration implemented with proper container identifier
 263: * [x] Write one-time JSON-to-CoreData migrator flag `UserDefaults.migrated = true`.
 264: * [x] **Re-enable CloudKit integration**
 265:   * Fixed crashing issues with the proper container ID
 266:   * Added proper CloudKit schema initialization
 267:   * Implemented conditional container creation based on user preferences
 268: 
 269: ---
 270: 
 271: ## Story 11 — Notifications &amp; Adherence
 272: 
 273: *Keep users on-schedule.*
 274: 
 275: * [x] **Created NotificationManager class**
 276:   * [x] Implemented `UNUserNotificationCenter.requestAuthorization` for permissions
 277:   * [x] Added methods to schedule, update, and cancel injection reminders
 278:   * [x] Added support for different notification sounds and actions
 279: 
 280: * [x] **Integrated with protocol management**
 281:   * [x] After each protocol edit, scheduled next-dose alert with `UNCalendarNotificationTrigger` 
 282:   * [x] Calculated proper notification times based on protocol schedule
 283:   * [x] Updated notifications when protocols are deleted or modified
 284: 
 285: * [x] **Added notification preferences**
 286:   * [x] Created UI settings for lead-time options (1h / 6h / 12h before injection)
 287:   * [x] Added toggle for notification sounds
 288:   * [x] Implemented proper notification handling with feedback
 289:   
 290: * [x] **Implemented adherence tracking**
 291:   * [x] Created system to record when users acknowledge injections
 292:   * [x] Added tracking for adherence statistics (on-time, late, missed)
 293:   * [x] Created InjectionHistoryView to visualize adherence data
 294:   * [x] Added adherence rate display in profile view
 295: 
 296: ---
 297: 
 298: ## Story 12 — Cycle Builder
 299: 
 300: *Visual timeline for multi-compound plans.*
 301: 
 302: * [x] **`Cycle` and `CycleStage` data models** for representing comprehensive multi-compound treatment plans
 303:   * [x] Created `Cycle` with name, startDate, totalWeeks, and collection of stages
 304:   * [x] Created `CycleStage` with startWeek, durationWeeks, and collections of compounds/blends
 305:   * [x] Implemented `CompoundStageItem` and `BlendStageItem` to handle different component types
 306:   * [x] Added conversion methods to generate temporary protocols for simulation
 307: 
 308: * [x] **Core Data integration** for persistence
 309:   * [x] Added `CDCycle` and `CDCycleStage` entities with proper relationships
 310:   * [x] Created extension methods for model-entity conversion
 311:   * [x] Implemented JSON serialization for compound/blend collections
 312:   * [x] Connected cycles to user profiles for organization
 313: 
 314: * [x] **Cycle Management in AppDataStore**
 315:   * [x] Added CRUD operations for cycles (load, save, delete)
 316:   * [x] Implemented cycle simulation by combining multiple compounds/blends
 317:   * [x] Created data accumulation logic to properly visualize combined effects
 318: 
 319: * [x] **SwiftUI CyclePlannerView** for visual planning
 320:   * [x] Created main interface with cycles list and simulation results
 321:   * [x] Added `CycleFormView` for creating and editing cycles
 322:   * [x] Implemented `CycleStageFormView` for configuring stages with compounds/blends
 323:   * [x] Created support views for compound and blend selection and configuration
 324: 
 325: * [x] **Visualization Components**
 326:   * [x] Implemented `CycleChartView` using Swift Charts for concentration visualization
 327:   * [x] Added date formatting and timeline representation
 328:   * [x] Created placeholder for detailed Gantt-style visualization (to be enhanced)
 329: 
 330: * [x] **Navigation and Integration**
 331:   * [x] Updated ContentView to use TabView for easy navigation
 332:   * [x] Added tab for Cycles alongside existing Protocols and Profile tabs
 333:   * [x] Implemented proper state management between views
 334: 
 335: ---
 336: 
 337: ## Story 13 — AI Insights
 338: 
 339: *Contextual coaching for optimized therapy.*
 340: 
 341: * [x] **`InsightsGenerator` Architecture**
 342:   * [x] Created a dedicated module to orchestrate AI interactions
 343:   * [x] Designed JSON schema for structured insights responses
 344:   * [x] Implemented caching system to reduce redundant API calls
 345:   * [x] Added appropriate disclaimers for AI-generated content
 346: 
 347: * [x] **Core Insight Types**
 348:   * [x] **Blend Explainer** - Provides plain-English breakdown of multi-ester blends
 349:     * Explains expected pharmacokinetic behavior (e.g., &quot;Sustanon 250 contains four esters with varying release times, creating an initial spike followed by sustained release&quot;)
 350:     * Uses visualization aids to explain compound interactions
 351:     * Implements similarity search for educational content
 352: 
 353:   * [x] **Protocol Analysis** - Evaluates user&apos;s protocol design
 354:     * Identifies suboptimal dosing schedules (e.g., suggests splitting weekly injections for more stable levels)
 355:     * Compares protocols against evidence-based best practices
 356:     * Suggests protocol modifications based on user&apos;s blood test results
 357: 
 358:   * [x] **Adherence Coach** - Helps users maintain consistent therapy
 359:     * Analyzes adherence patterns to provide personalized feedback
 360:     * Suggests routine adjustments to improve consistency
 361:     * Provides education on the importance of therapy consistency
 362: 
 363: * [x] **Implementation Details**
 364:   * [x] **Complete OpenAI Integration**
 365:     * Uses GPT-4o-mini model to balance cost-effectiveness and quality
 366:     * Implements structured JSON response format for consistent UI presentation
 367:     * Added free test API key for all users with $20 spending limit
 368:     * Includes API key management UI with option to use personal key or test key
 369:     * Implements proper error handling and loading states
 370:   
 371:   * [x] **Robust Offline Fallback**
 372:     * Created mock implementation that works without internet connection
 373:     * Pre-generates common insights for basic functionality
 374:     * Automatically falls back to mock data when API is unavailable
 375: 
 376:   * [x] **Prompt Engineering**
 377:     * Developed specialized prompts for protocol and cycle analysis
 378:     * Includes relevant user profile data for personalized insights
 379:     * Structured to generate consistent, actionable advice
 380:     * Optimized token usage for cost efficiency
 381: 
 382: * [x] **UI Integration**
 383:   * [x] Created dedicated &quot;Insights&quot; tab in the app interface
 384:   * [x] Implemented interactive UI with expandable key points
 385:   * [x] Added color-coded insights by category (information, warnings, suggestions, positive feedback)
 386:   * [x] Created settings view for API key management
 387:   * [x] Added visual indicators for test API key usage
 388:   * [x] Implemented auto-refresh when API settings change
 389: 
 390: * [x] **Cache and Performance**
 391:   * [x] Implemented intelligent caching to minimize API calls
 392:   * [x] Added force refresh option for updated results
 393:   * [x] Created proper loading and error states in the UI
 394: 
 395: ## Next Steps
 396: 
 397: With Stories 8-13 now complete, the application has all its core functional requirements implemented. The focus will now shift to:
 398: 
 399: 
 400: ---
 401: 
 402: ## Story 14 — UI/UX Polish &amp; Animations
 403: 
 404: *Delightful &amp; accessible.*
 405: 
 406: The next step is to enhance the visual appeal and user experience of the application. This will include implementing smooth animations, improving visual consistency, optimizing the interface for accessibility, and adding delightful interactions to make the app more engaging.
 407: 
 408: 
 409: ## 1. Chart Component Architecture
 410: 
 411: - [ ] Create a flexible `ChartContainer` component
 412:   - [ ] Implement time scale switching capabilities
 413:   - [ ] Add data aggregation functionality based on selected time scale
 414:   - [ ] Build state management for smooth transitions
 415:   - [ ] Implement progressive disclosure pattern with expandable views
 416: 
 417: - [ ] Design component hierarchy with separation of concerns
 418:   - [ ] Build `TimeScaleSelector` component with options for &apos;4-week&apos;, &apos;quarterly&apos;, &apos;all-time&apos;
 419:   - [ ] Create `TestosteroneLineChart` for core visualization
 420:   - [ ] Implement `ReferenceRangeOverlay` to show normal ranges
 421:   - [ ] Add `InteractionLayer` for user selection and tooltips
 422: 
 423: ## 2. Time Scale Implementation
 424: 
 425: - [ ] Build dedicated `TimeScaleManager` class
 426:   - [ ] Implement 4-week view with daily precision
 427:   - [ ] Create intermediate view (3-6 months) with weekly aggregation
 428:   - [ ] Design all-time view with monthly/quarterly aggregation
 429:   - [ ] Add trend highlighting for long-term views
 430: 
 431: - [ ] Create smooth transitions between time scales
 432:   - [ ] Implement animation system for transitioning between scales (300-500ms duration)
 433:   - [ ] Maintain context when switching by keeping focal point consistent
 434:   - [ ] Add calculation for proper data aggregation based on scale
 435:   - [ ] Implement intelligent date formatting that adapts to each scale
 436: 
 437: ## 3. Dashboard Optimization with Pre-attentive Principles
 438: 
 439: - [ ] Redesign dashboard layout following NN/g principles
 440:   - [ ] Place critical metrics in upper-left corner (current level and days until next dose)
 441:   - [ ] Group related metrics visually using consistent spacing and subtle backgrounds
 442:   - [ ] Implement clean information hierarchy with 5-7 key metrics maximum
 443:   - [ ] Create visual distinction between primary and secondary metrics
 444: 
 445: - [ ] Optimize pre-attentive attributes
 446:   - [ ] Use length-based visualizations (bar charts) for comparing quantities
 447:   - [ ] Implement 2D position (line charts) for showing relationships over time
 448:   - [ ] Apply color strategically as secondary attribute for highlighting
 449:   - [ ] Create sufficient white space between information groups
 450: 
 451: ## 4. Chart Visualization Enhancement
 452: 
 453: - [ ] Implement Apple HIG &quot;Charting Data&quot; principles
 454:   - [ ] Create uncluttered axes with minimal but sufficient gridlines
 455:   - [ ] Design clear call-outs for important data points
 456:   - [ ] Implement proper data range scaling to maximize visibility
 457:   - [ ] Add contextual information display around chart
 458: 
 459: - [ ] Add Swift Charts 2D interactions
 460:   - [ ] Implement scroll-zoom functionality for exploring data
 461:   - [ ] Create selection marks for important data points
 462:   - [ ] Add pinch-to-zoom gesture support
 463:   - [ ] Implement double-tap to reset view
 464: 
 465: ## 5. Animation System
 466: 
 467: - [ ] Create curve reveal animations
 468:   - [ ] Implement easeInOut animation for data presentation (1.2s duration)
 469:   - [ ] Create sequential animation for multi-dataset charts
 470:   - [ ] Add fade-in effects for chart elements (axes, labels, gridlines)
 471:   - [ ] Design visual transitions for data updates
 472: 
 473: - [ ] Implement micro-animations for user feedback
 474:   - [ ] Create subtle animations for user interactions (150-200ms)
 475:   - [ ] Design feedback animations for selections and taps
 476:   - [ ] Implement loading states with branded skeleton screens
 477:   - [ ] Add subtle pulse animations for highlighting new data
 478: 
 479: - [ ] Add celebration animations
 480:   - [ ] Design milestone celebration animations (800-1200ms)
 481:   - [ ] Create visual feedback for completing injections
 482:   - [ ] Implement progress celebrations for adherence achievements
 483:   - [ ] Design subtle success animations for data submissions
 484: 
 485: ## 6. Haptic and Sound Integration
 486: 
 487: - [ ] Implement haptic feedback system
 488:   - [ ] Add light impact haptics for selections and navigation
 489:   - [ ] Design medium impact haptics for confirming injections
 490:   - [ ] Create notification haptics for reminders
 491:   - [ ] Implement success haptics for completed actions
 492: 
 493: - [ ] Add sound design
 494:   - [ ] Create subtle sound effects for primary interactions
 495:   - [ ] Design success sounds for completed injections
 496:   - [ ] Implement notification sounds for reminders
 497:   - [ ] Add option to disable sounds in settings
 498: 
 499: ## 7. Visual Design System
 500: 
 501: - [ ] Create focused color palette
 502:   - [ ] Implement primary palette with deep blues and teal accents
 503:   - [ ] Design accent colors (vibrant orange/red) for highlighting
 504:   - [ ] Create semantic color system (green for improvements, red for declines)
 505:   - [ ] Ensure proper contrast ratios for accessibility
 506: 
 507: - [ ] Design typography system
 508:   - [ ] Implement SF Pro (iOS native) font family
 509:   - [ ] Create clear hierarchy with 2-3 weights
 510:   - [ ] Define consistent text sizes for different UI elements
 511:   - [ ] Ensure proper line height and letter spacing for readability
 512: 
 513: - [ ] Build dark mode compatibility
 514:   - [ ] Create semantic color assets that adapt to light/dark mode
 515:   - [ ] Design dark mode variants of all UI components
 516:   - [ ] Adjust contrast and brightness appropriately for dark mode
 517:   - [ ] Test color combinations in both modes for accessibility
 518: 
 519: ## 8. Component Pattern Implementation
 520: 
 521: - [ ] Create card-based organization system
 522:   - [ ] Design subtle shadows and rounded corners (consistent 8px or 12px radius)
 523:   - [ ] Implement proper elevation hierarchy (1-3 levels of cards)
 524:   - [ ] Create consistent internal padding (16px or 20px)
 525:   - [ ] Add subtle hover/press states for interactive cards
 526: 
 527: - [ ] Build navigation patterns
 528:   - [ ] Implement bottom tab navigation for main sections
 529:   - [ ] Create floating action buttons for primary actions
 530:   - [ ] Design slide-up sheets for detailed information
 531:   - [ ] Add animation for navigation transitions
 532: 
 533: - [ ] Define spacing system
 534:   - [ ] Create 8px increment-based spacing system
 535:   - [ ] Implement consistent margins between UI elements
 536:   - [ ] Design proper whitespace distribution
 537:   - [ ] Create balanced component density
 538: 
 539: ## 9. Nike-Inspired Visual Elements
 540: 
 541: - [ ] Implement minimalist chart styling
 542:   - [ ] Create clean, thin chart lines with subtle animations
 543:   - [ ] Design ample white space around charts
 544:   - [ ] Add subtle gradient fills under trend lines
 545:   - [ ] Implement subtle grid lines that don&apos;t compete with data
 546: 
 547: - [ ] Create performance zone visualization
 548:   - [ ] Design color-coded zones for different testosterone ranges
 549:   - [ ] Implement subtle background color bands for zones
 550:   - [ ] Add indicators for optimal ranges
 551:   - [ ] Create tooltips explaining each zone
 552: 
 553: - [ ] Build consistent visual language
 554:   - [ ] Design unified icon system
 555:   - [ ] Create consistent corner radius across all elements
 556:   - [ ] Implement uniform shadow treatment
 557:   - [ ] Design consistent animation timing across UI
 558: 
 559: ## 10. Progressive Disclosure Implementation
 560: 
 561: - [ ] Create layered information architecture
 562:   - [ ] Design summary views that expand to detailed charts
 563:   - [ ] Implement &quot;Learn more&quot; expansions for complex information
 564:   - [ ] Create hierarchy of importance for displayed metrics
 565:   - [ ] Build collapsible sections for detailed information
 566: 
 567: - [ ] Implement interaction patterns for exploration
 568:   - [ ] Design clear affordances for expandable content
 569:   - [ ] Create smooth transitions for expanding/collapsing
 570:   - [ ] Add breadcrumbs for navigating complex data
 571:   - [ ] Implement information tooltips for advanced metrics
 572: 
 573: ## 11. Implementation Examples for Key Components
 574: 
 575: ### Current Level Dashboard Card
 576: 
 577: - [ ] Create card design with:
 578:   - [ ] Large current testosterone level display (primary focus)
 579:   - [ ] Days until next dose countdown
 580:   - [ ] Small trend indicator showing change since last reading
 581:   - [ ] Subtle animation on value changes
 582:   - [ ] Tap interaction to expand to full chart
 583: 
 584: ```swift
 585: // Example structure for CurrentLevelCard
 586: struct CurrentLevelCard: View {
 587:     @ObservedObject var dataStore: AppDataStore
 588:     @State private var isExpanded = false
 589:     
 590:     var body: some View {
 591:         VStack(alignment: .leading, spacing: 12) {
 592:             // Header with current level
 593:             HStack {
 594:                 Text(&quot;Current Level&quot;)
 595:                     .font(.subheadline)
 596:                     .foregroundColor(.secondary)
 597:                 Spacer()
 598:                 // Trend indicator
 599:                 TrendIndicator(change: dataStore.levelChange)
 600:             }
 601:             
 602:             // Primary value with large display
 603:             Text(&quot;\(formattedCurrentLevel) ng/dL&quot;)
 604:                 .font(.system(size: 32, weight: .bold))
 605:                 .foregroundColor(.primary)
 606:                 .padding(.bottom, 4)
 607:             
 608:             // Days until next dose
 609:             HStack {
 610:                 Image(systemName: &quot;calendar.badge.clock&quot;)
 611:                     .foregroundColor(.accentColor)
 612:                 Text(&quot;\(dataStore.daysUntilNextDose) days until next dose&quot;)
 613:                     .font(.callout)
 614:             }
 615:             
 616:             // Expand button
 617:             Button {
 618:                 withAnimation(.spring()) {
 619:                     isExpanded.toggle()
 620:                 }
 621:             } label: {
 622:                 Text(isExpanded ? &quot;Show less&quot; : &quot;Show chart&quot;)
 623:                     .font(.caption)
 624:                     .fontWeight(.medium)
 625:             }
 626:             .buttonStyle(.plain)
 627:             
 628:             // Expanded chart
 629:             if isExpanded {
 630:                 TestosteroneChart(data: dataStore.recentLevels)
 631:                     .frame(height: 200)
 632:                     .transition(.move(edge: .top).combined(with: .opacity))
 633:             }
 634:         }
 635:         .padding(16)
 636:         .background(
 637:             RoundedRectangle(cornerRadius: 16)
 638:                 .fill(Color(.secondarySystemBackground))
 639:                 .shadow(color: Color.primary.opacity(0.05), radius: 10, x: 0, y: 4)
 640:         )
 641:         .padding(.horizontal)
 642:     }
 643:     
 644:     private var formattedCurrentLevel: String {
 645:         let formatter = NumberFormatter()
 646:         formatter.numberStyle = .decimal
 647:         return formatter.string(from: NSNumber(value: dataStore.currentLevel)) ?? &quot;0&quot;
 648:     }
 649: }
 650: ```
 651: 
 652: ### Time Scale Selector with Transitions
 653: 
 654: - [ ] Implement component with:
 655:   - [ ] Segmented control for time scale selection
 656:   - [ ] Smooth transitions between scales
 657:   - [ ] Visual indication of current scale
 658:   - [ ] Appropriate date range display
 659: 
 660: ```swift
 661: struct TimeScaleSelector: View {
 662:     @Binding var selectedTimeScale: TimeScale
 663:     @State private var isTransitioning = false
 664:     let onChange: (TimeScale) -&gt; Void
 665:     
 666:     var body: some View {
 667:         VStack(spacing: 8) {
 668:             // Segmented control
 669:             Picker(&quot;Time Scale&quot;, selection: $selectedTimeScale) {
 670:                 Text(&quot;4 Week&quot;).tag(TimeScale.fourWeek)
 671:                 Text(&quot;Quarterly&quot;).tag(TimeScale.quarterly)
 672:                 Text(&quot;All Time&quot;).tag(TimeScale.allTime)
 673:             }
 674:             .pickerStyle(.segmented)
 675:             .onChange(of: selectedTimeScale) { newScale in
 676:                 withAnimation(.easeInOut(duration: 0.3)) {
 677:                     isTransitioning = true
 678:                 }
 679:                 
 680:                 // Allow time for animation to start
 681:                 DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
 682:                     onChange(newScale)
 683:                 }
 684:                 
 685:                 // Reset transition state
 686:                 DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
 687:                     isTransitioning = false
 688:                 }
 689:             }
 690:             
 691:             // Date range display
 692:             Text(dateRangeText)
 693:                 .font(.caption)
 694:                 .foregroundColor(.secondary)
 695:                 .padding(.top, 4)
 696:         }
 697:         .padding(.horizontal)
 698:         .padding(.vertical, 8)
 699:         .background(Color(.secondarySystemBackground).opacity(0.5))
 700:         .cornerRadius(8)
 701:     }
 702:     
 703:     private var dateRangeText: String {
 704:         switch selectedTimeScale {
 705:         case .fourWeek:
 706:             return &quot;Last 28 days&quot;
 707:         case .quarterly:
 708:             return &quot;Last 3 months&quot;
 709:         case .allTime:
 710:             return &quot;Complete history&quot;
 711:         }
 712:     }
 713: }
 714: 
 715: enum TimeScale {
 716:     case fourWeek, quarterly, allTime
 717: }
 718: ```
 719: 
 720: ### Testosterone Chart with Animations
 721: 
 722: - [ ] Build chart with:
 723:   - [ ] Clean, minimal axes and gridlines
 724:   - [ ] Smooth curve animation on appearance
 725:   - [ ] Properly scaled y-axis for current data
 726:   - [ ] Reference range visualization
 727:   - [ ] Interaction support for data point selection
 728: 
 729: ```swift
 730: struct TestosteroneChart: View {
 731:     let data: [DataPoint]
 732:     @State private var showChart = false
 733:     @State private var selectedPoint: DataPoint?
 734:     
 735:     var body: some View {
 736:         VStack(alignment: .leading, spacing: 24) {
 737:             // Chart title
 738:             Text(&quot;Testosterone Levels&quot;)
 739:                 .font(.headline)
 740:                 .padding(.horizontal)
 741:             
 742:             // Chart container
 743:             Chart {
 744:                 // Reference range area
 745:                 RectangleMark(
 746:                     xStart: .value(&quot;Start&quot;, data.first?.date ?? Date()),
 747:                     xEnd: .value(&quot;End&quot;, data.last?.date ?? Date()),
 748:                     yStart: .value(&quot;Min&quot;, 350),
 749:                     yEnd: .value(&quot;Max&quot;, 1000)
 750:                 )
 751:                 .foregroundStyle(Color.green.opacity(0.1))
 752:                 .cornerRadius(4)
 753:                 
 754:                 // Data line
 755:                 if showChart {
 756:                     LineMark(
 757:                         x: .value(&quot;Date&quot;, data.map { $0.date }),
 758:                         y: .value(&quot;Level&quot;, data.map { $0.level })
 759:                     )
 760:                     .lineStyle(StrokeStyle(lineWidth: 2.5))
 761:                     .foregroundStyle(Color.accentColor.gradient)
 762:                     .interpolationMethod(.catmullRom)
 763:                     
 764:                     // Data points
 765:                     ForEach(data) { point in
 766:                         PointMark(
 767:                             x: .value(&quot;Date&quot;, point.date),
 768:                             y: .value(&quot;Level&quot;, point.level)
 769:                         )
 770:                         .foregroundStyle(Color.accentColor)
 771:                         .symbolSize(point.id == selectedPoint?.id ? 120 : 60)
 772:                     }
 773:                 }
 774:             }
 775:             .chartXAxis {
 776:                 AxisMarks(values: .automatic) { value in
 777:                     AxisGridLine(centered: true, stroke: StrokeStyle(lineWidth: 0.5))
 778:                     AxisValueLabel() {
 779:                         if let date = value.as(Date.self) {
 780:                             Text(date.formatted(.dateTime.month(.abbreviated).day()))
 781:                                 .font(.caption2)
 782:                                 .foregroundColor(.secondary)
 783:                         }
 784:                     }
 785:                 }
 786:             }
 787:             .chartYAxis {
 788:                 AxisMarks(position: .leading, values: .automatic) { value in
 789:                     AxisGridLine(centered: true, stroke: StrokeStyle(lineWidth: 0.5))
 790:                     AxisValueLabel() {
 791:                         if let level = value.as(Double.self) {
 792:                             Text(&quot;\(Int(level))&quot;)
 793:                                 .font(.caption2)
 794:                                 .foregroundColor(.secondary)
 795:                         }
 796:                     }
 797:                 }
 798:             }
 799:             .frame(height: 220)
 800:             .padding(.horizontal, 8)
 801:             .padding(.bottom)
 802:             .onAppear {
 803:                 // Animate chart appearance
 804:                 withAnimation(.easeInOut(duration: 1.2)) {
 805:                     showChart = true
 806:                 }
 807:             }
 808:             
 809:             // Selected point details
 810:             if let selectedPoint = selectedPoint {
 811:                 HStack(spacing: 16) {
 812:                     VStack(alignment: .leading) {
 813:                         Text(selectedPoint.date.formatted(.dateTime.day().month().year()))
 814:                             .font(.subheadline)
 815:                             .foregroundColor(.secondary)
 816:                         Text(&quot;\(Int(selectedPoint.level)) ng/dL&quot;)
 817:                             .font(.title2)
 818:                             .fontWeight(.semibold)
 819:                     }
 820:                     
 821:                     Spacer()
 822:                     
 823:                     // Status indicator
 824:                     StatusIndicator(level: selectedPoint.level)
 825:                 }
 826:                 .padding()
 827:                 .background(Color(.secondarySystemBackground))
 828:                 .cornerRadius(12)
 829:                 .transition(.move(edge: .bottom).combined(with: .opacity))
 830:             }
 831:         }
 832:         .chartOverlay { proxy in
 833:             GeometryReader { geometry in
 834:                 Rectangle().fill(.clear).contentShape(Rectangle())
 835:                     .gesture(
 836:                         DragGesture()
 837:                             .onChanged { value in
 838:                                 let x = value.location.x - geometry.frame(in: .local).minX
 839:                                 if let (date, _) = proxy.value(atX: x),
 840:                                    let nearestPoint = findNearestPoint(to: date) {
 841:                                     selectedPoint = nearestPoint
 842:                                     HapticFeedback.selection.trigger()
 843:                                 }
 844:                             }
 845:                     )
 846:             }
 847:         }
 848:     }
 849:     
 850:     private func findNearestPoint(to date: Date) -&gt; DataPoint? {
 851:         guard !data.isEmpty else { return nil }
 852:         
 853:         return data.min(by: { abs($0.date.timeIntervalSince(date)) &lt; abs($1.date.timeIntervalSince(date)) })
 854:     }
 855: }
 856: 
 857: // Helper for haptic feedback
 858: enum HapticFeedback {
 859:     case selection, success, warning, error
 860:     
 861:     func trigger() {
 862:         switch self {
 863:         case .selection:
 864:             let generator = UISelectionFeedbackGenerator()
 865:             generator.prepare()
 866:             generator.selectionChanged()
 867:         case .success:
 868:             let generator = UINotificationFeedbackGenerator()
 869:             generator.prepare()
 870:             generator.notificationOccurred(.success)
 871:         case .warning:
 872:             let generator = UINotificationFeedbackGenerator()
 873:             generator.prepare()
 874:             generator.notificationOccurred(.warning)
 875:         case .error:
 876:             let generator = UINotificationFeedbackGenerator()
 877:             generator.prepare()
 878:             generator.notificationOccurred(.error)
 879:         }
 880:     }
 881: }
 882: 
 883: // Status indicator component
 884: struct StatusIndicator: View {
 885:     let level: Double
 886:     
 887:     var body: some View {
 888:         HStack(spacing: 4) {
 889:             Circle()
 890:                 .fill(statusColor)
 891:                 .frame(width: 8, height: 8)
 892:             
 893:             Text(statusText)
 894:                 .font(.caption)
 895:                 .fontWeight(.medium)
 896:                 .foregroundColor(statusColor)
 897:         }
 898:         .padding(.horizontal, 8)
 899:         .padding(.vertical, 4)
 900:         .background(statusColor.opacity(0.1))
 901:         .cornerRadius(12)
 902:     }
 903:     
 904:     private var statusColor: Color {
 905:         if level &lt; 300 {
 906:             return .red
 907:         } else if level &lt; 350 {
 908:             return .orange
 909:         } else if level &lt;= 1000 {
 910:             return .green
 911:         } else {
 912:             return .purple
 913:         }
 914:     }
 915:     
 916:     private var statusText: String {
 917:         if level &lt; 300 {
 918:             return &quot;Low&quot;
 919:         } else if level &lt; 350 {
 920:             return &quot;Borderline&quot;
 921:         } else if level &lt;= 1000 {
 922:             return &quot;Normal&quot;
 923:         } else {
 924:             return &quot;High&quot;
 925:         }
 926:     }
 927: }
 928: ```
 929: 
 930: ## 12. Animation and Transition Strategy
 931: 
 932: - [ ] Define a consistent animation timing system
 933:   - [ ] Quick feedback: 150-200ms
 934:   - [ ] UI transitions: 300-500ms
 935:   - [ ] Progress celebrations: 800-1200ms
 936:   - [ ] Data visualizations: 1000-1500ms
 937: 
 938: - [ ] Create a centralized animation manager
 939:   - [ ] Define standard curves for different interaction types
 940:   - [ ] Create consistent entry/exit animations for views
 941:   - [ ] Design staggered animations for related elements
 942:   - [ ] Implement spring animations for natural movements
 943: 
 944: - [ ] Build celebration animation system
 945:   - [ ] Create success animations for completed injections
 946:   - [ ] Design milestone celebrations for adherence achievements
 947:   - [ ] Implement subtle progress indicators
 948:   - [ ] Add confetti or similar effects for major milestones
 949: 
 950: 
 951: ## 14. Testing and Validation Plan
 952: 
 953: - [ ] Define key test scenarios
 954:   - [ ] Verify time scale transitions work smoothly
 955:   - [ ] Test chart interactions on all supported devices
 956:   - [ ] Validate animations perform well on older devices
 957:   - [ ] Check accessibility with VoiceOver and Dynamic Type
 958: 
 959: - [ ] Create visual regression testing
 960:   - [ ] Capture screenshots for baseline comparisons
 961:   - [ ] Test across different iOS versions and devices
 962:   - [ ] Verify dark mode compatibility
 963:   - [ ] Test dynamic type size variations
 964: 
 965: - [ ] Performance testing
 966:   - [ ] Measure animation frame rates (target 60 FPS)
 967:   - [ ] Test with large datasets (1+ year of daily data)
 968:   - [ ] Verify memory usage during transitions
 969:   - [ ] Measure time to initial render for charts
 970: 
 971: ## 15. Documentation and Handoff
 972: 
 973: - [ ] Create component documentation
 974:   - [ ] Document all custom UI components with usage examples
 975:   - [ ] Define animation timing and curve standards
 976:   - [ ] Document color palette and typography system
 977:   - [ ] Create spacing and layout guidelines
 978: 
 979: - [ ] Build interactive prototypes
 980:   - [ ] Create working prototypes of key interactions
 981:   - [ ] Demonstrate animation timing and sequences
 982:   - [ ] Show time scale transitions
 983:   - [ ] Illustrate celebration animations
 984: 
 985: This detailed checklist should provide a comprehensive guide for implementing the UI/UX enhancements described in the &quot;Making TestoSim Shine&quot; document. The checklist includes specific implementation details, code examples, and visual design specifications to help guide the development process.
 986: 
 987: ---
 988: 
 989: ## Story 15 — Testing &amp; Validation
 990: 
 991: | Test     | Target                                                                                                             | Pass criteria            |
 992: | -------- | ------------------------------------------------------------------------------------------------------------------ | ------------------------ |
 993: | **Unit** | 250 mg Test E single IM → C&lt;sub&gt;max&lt;/sub&gt; ≈ 1540 ng/dL @ 72 h; 50 % peak by day 9 ([World Anti Doping Agency][24]) | Δ ≤ 10 %                 |
 994: |          | 100 mg Tren A Q2D × 14 d steady-state \~6× baseline ([Wikipedia][10])                                              | Δ ≤ 10 %                 |
 995: | **UI**   | Notification permission flow, drag-drop in cycle builder                                                           | No crash, state persists |
 996: | **Perf** | Simulate 5-compound 20-week plan on iPhone 12                                                                      | &lt; 50 ms average          |
 997: 
 998: ---
 999: 
1000: ## Story 16 — Help Center &amp; Documentation
1001: 
1002: *Comprehensive in-app learning center*
1003: 
1004: * [ ] **Core Help Center Architecture**
1005:   * [ ] Create `HelpCenterView` as the main entry point for all documentation
1006:   * [ ] Implement topic-based navigation with hierarchical structure
1007:   * [ ] Create consistent visual styling and interactive elements
1008:   * [ ] Design for high readability with appropriate typography and spacing
1009:   * [ ] Add global access through navigation bar help button
1010: 
1011: * [ ] **PK Model Documentation**
1012:   * [ ] Create detailed explanations of the two-compartment model
1013:   * [ ] Develop interactive visualizations showing compound movement between compartments
1014:   * [ ] Include scientific foundation with simplified explanations
1015:   * [ ] Provide practical examples showing how the model predicts real-world concentrations
1016:   * [ ] Explain key pharmacokinetic parameters (ke, ka, α, β, Vd)
1017: 
1018: * [ ] **Educational Content Modules**
1019:   * [ ] **PKModelExplanationView**: Two-compartment model details and benefits
1020:     * Visual representation of central and peripheral compartments
1021:     * Animation showing compound distribution and elimination
1022:     * Explanation of why two compartments produces more accurate predictions
1023:     * Comparison with simpler one-compartment models
1024: 
1025:   * [ ] **AllometricScalingView**: Enhanced version of existing content
1026:     * Expanded visualization of scaling equations
1027:     * Clearer connection to PK model concepts
1028:     * Additional scientific foundation with accessible explanations
1029: 
1030:   * [ ] **ApplicationGuideView**: Practical usage tutorials
1031:     * Protocol creation walkthrough
1032:     * Blood test integration explanation
1033:     * Calibration process explanation
1034:     * Step-by-step instructions with screenshots
1035: 
1036:   * [ ] **CyclePlannerGuideView**: Multi-compound cycle documentation
1037:     * Explanation of cycle planner functionality
1038:     * Multi-compound interactions and considerations
1039:     * Visual interpretation guide for cycle simulations
1040:     * Best practices for monitoring during cycles
1041: 
1042: * [ ] **UI Implementation**
1043:   * [ ] Add global help button in navigation bar across app
1044:     ```swift
1045:     .toolbar {
1046:         ToolbarItem(placement: .navigationBarTrailing) {
1047:             Button {
1048:                 showingHelpCenter = true
1049:             } label: {
1050:                 Image(systemName: &quot;questionmark.circle&quot;)
1051:             }
1052:         }
1053:     }
1054:     .sheet(isPresented: $showingHelpCenter) {
1055:         HelpCenterView()
1056:     }
1057:     ```
1058:   * [ ] Create consistent section styling with cards and grid layouts
1059:   * [ ] Implement topic filtering and search functionality
1060:   * [ ] Design expandable sections for progressive disclosure
1061:   * [ ] Support both light and dark mode with appropriate contrast
1062: 
1063: * [ ] **Content Organization**
1064:   * [ ] Move existing explanatory content into the centralized Help Center
1065:   * [ ] Remove redundant &quot;Advanced PK Model&quot; explanatory text from ProfileView
1066:   * [ ] Create new illustrations and animations for complex concepts
1067:   * [ ] Ensure content is scientifically accurate but accessible to users
1068: 
1069: * [ ] **Integration Plan**
1070:   * [ ] Create Help directory in Views folder with modular components
1071:   * [ ] Update ContentView and primary feature views with Help button
1072:   * [ ] Add state variables to manage help presentation
1073:   * [ ] Implement deep-linking to specific help topics from relevant screens
1074: 
1075: * [ ] **Clean-up Tasks**
1076:   * [ ] Remove or consolidate scattered explanatory content
1077:   * [ ] Establish consistent typography and visual hierarchy
1078:   * [ ] Ensure all help content is accessible with proper semantic markup
1079:   * [ ] Add contextual help links in appropriate locations
1080: 
1081: ---
1082: 
1083: ## References
1084: 
1085: 1. Testosterone propionate half-life 0.8 d ([Wikipedia][1])
1086: 2. Testosterone PP half-life 2.5 d ([Iron Daddy][2])
1087: 3. Testosterone isocaproate info ([Cayman Chemical][3])
1088: 4. Testosterone decanoate 7–14 d ([BloomTechz][4])
1089: 5. TU depot half-life 18–24 d ([PubMed][5])
1090: 6. Oral TU bioavailability 0.07, t½ 1.6 h ([Wikipedia][6])
1091: 7. Nandrolone decanoate 6–12 d ([Wikipedia][7])
1092: 8. Boldenone undecylenate \~123 h ([ScienceDirect][8])
1093: 9. Trenbolone acetate 1-2 d ([ScienceDirect][9])
1094: 10. Trenbolone hex/enanthate data ([Wikipedia][10])
1095: 11. Stanozolol suspension 24 h ([Wikipedia][11])
1096: 12. Drostanolone propionate 2 d; enanthate \~5 d ([Wikipedia][12])
1097: 13. Metenolone enanthate 10.5 d ([Wikipedia][13])
1098: 14. Trestolone acetate 40 min IV t½ ([PubMed][14])
1099: 15. DHB overview (1-Testosterone) ([Wikipedia][15])
1100: 16. UF &quot;Useful PK equations&quot; sheet ([UF College of Pharmacy][16])
1101: 17. Allometric scaling study (TE) ([PubMed][17])
1102: 18. Apple CoreData + CloudKit doc ([Apple Developer][18])
1103: 19. UNUserNotificationCenter API page ([Apple Developer][19])
1104: 20. WWDC23 Swift Charts interactivity ([Apple Developer][20])
1105: 21. Apple Charting-Data HIG ([Apple Developer][21])
1106: 22. NN/g dashboard pre-attentive article ([Nielsen Norman Group][22])
1107: 23. Lottie-SPM install guide ([GitHub][23])
1108: 24. WADA blood detection of testosterone esters ([World Anti Doping Agency][24])
1109: 
1110: [1]: https://en.wikipedia.org/wiki/Testosterone_propionate?utm_source=chatgpt.com &quot;Testosterone propionate - Wikipedia&quot;
1111: [2]: https://iron-daddy.to/product-category/injectable-steroids/testosterone-phenylpropionate/?utm_source=chatgpt.com &quot;Testosterone Phenylpropionate Half Life - Iron-Daddy.to&quot;
1112: [3]: https://www.caymanchem.com/product/22547/testosterone-isocaproate?srsltid=AfmBOoqMzkbumL-PTe0EBkhjjakJVRLR66OsRIFjNbNDIX5YwYpMLPer&amp;utm_source=chatgpt.com &quot;Testosterone Isocaproate (CAS 15262-86-9) - Cayman Chemical&quot;
1113: [4]: https://www.bloomtechz.com/info/what-is-the-half-life-of-testosterone-decanoat-93380289.html?utm_source=chatgpt.com &quot;What Is The Half Life Of Testosterone Decanoate? - BLOOM TECH&quot;
1114: [5]: https://pubmed.ncbi.nlm.nih.gov/9876028/?utm_source=chatgpt.com &quot;A pharmacokinetic study of injectable testosterone undecanoate in ...&quot;
1115: [6]: https://en.wikipedia.org/wiki/Testosterone_undecanoate?utm_source=chatgpt.com &quot;Testosterone undecanoate - Wikipedia&quot;
1116: [7]: https://en.wikipedia.org/wiki/Nandrolone_decanoate?utm_source=chatgpt.com &quot;Nandrolone decanoate - Wikipedia&quot;
1117: [8]: https://www.sciencedirect.com/science/article/abs/pii/S1567576921005750?utm_source=chatgpt.com &quot;Boldenone undecylenate disrupts the immune system and induces ...&quot;
1118: [9]: https://www.sciencedirect.com/science/article/abs/pii/S002228602030452X?utm_source=chatgpt.com &quot;Structural studies of Trenbolone, Trenbolone Acetate ...&quot;
1119: [10]: https://en.wikipedia.org/wiki/Trenbolone?utm_source=chatgpt.com &quot;Trenbolone&quot;
1120: [11]: https://en.wikipedia.org/wiki/Stanozolol?utm_source=chatgpt.com &quot;Stanozolol - Wikipedia&quot;
1121: [12]: https://en.wikipedia.org/wiki/Drostanolone_propionate?utm_source=chatgpt.com &quot;Drostanolone propionate - Wikipedia&quot;
1122: [13]: https://en.wikipedia.org/wiki/Metenolone_enanthate?utm_source=chatgpt.com &quot;Metenolone enanthate - Wikipedia&quot;
1123: [14]: https://pubmed.ncbi.nlm.nih.gov/9283946/?utm_source=chatgpt.com &quot;Pharmacokinetics of 7 alpha-methyl-19-nortestosterone in men and ...&quot;
1124: [15]: https://en.wikipedia.org/wiki/1-Testosterone?utm_source=chatgpt.com &quot;1-Testosterone - Wikipedia&quot;
1125: [16]: https://pharmacy.ufl.edu/files/2013/01/5127-28-equations.pdf?utm_source=chatgpt.com &quot;[PDF] Useful Pharmacokinetic Equations&quot;
1126: [17]: https://pubmed.ncbi.nlm.nih.gov/37180212/?utm_source=chatgpt.com &quot;Allometric Scaling of Testosterone Enanthate Pharmacokinetics to ...&quot;
1127: [18]: https://developer.apple.com/documentation/coredata/setting-up-core-data-with-cloudkit &quot;Setting Up Core Data with CloudKit | Apple Developer Documentation&quot;
1128: [19]: https://developer.apple.com/documentation/usernotifications/unusernotificationcenter/requestauthorization &quot;UNUserNotificationCenter - Apple Developer Documentation&quot;
1129: [20]: https://developer.apple.com/videos/play/wwdc2023/10037 &quot;Explore pie charts and interactivity in Swift Charts - WWDC23 - Videos - Apple Developer&quot;
1130: [21]: https://developer.apple.com/design/human-interface-guidelines/charting-data &quot;Charting data | Apple Developer Documentation&quot;
1131: [22]: https://www.nngroup.com/articles/dashboards-preattentive/?utm_source=chatgpt.com &quot;Dashboards: Making Charts and Graphs Easier to Understand - NN/g&quot;
1132: [23]: https://github.com/airbnb/lottie-ios &quot;airbnb/lottie-ios: An iOS library to natively render After Effects vector animations&quot;
1133: [24]: https://www.wada-ama.org/en/resources/scientific-research/detection-testosterone-esters-blood-sample?utm_source=chatgpt.com &quot;Detection of testosterone esters in blood sample - WADA&quot;
1134: 
1135: ## Code Cleanup
1136: 
1137: As part of our ongoing refinement of the application architecture, we&apos;ve made the following improvements:
1138: 
1139: 1. [x] Removed redundant TestosteroneEster model
1140:    * The legacy TestosteroneEster model has been completely removed
1141:    * All protocols now use the more flexible Compound model
1142:    * Protocol creation process has been simplified to just two options: Compound and Blend
1143:    * Core Data persistence has been updated to store compound/blend references in the notes field until the data model is updated
1144: 
1145: 2. [x] Simplified protocol type selection
1146:    * Protocols now clearly identify as either compound-based or blend-based
1147:    * UI has been streamlined to show only the relevant options for each type
1148:    * Added proper route selection for all protocol types
1149: 
1150: 3. [x] Improved database efficiency
1151:    * Protocols now store direct references to compounds and blends instead of duplicating data
1152:    * Added support for extended property serialization in the Core Data persistence layer
1153:    * Prepared the application for future data model updates
1154: 
1155: These changes have resulted in a more maintainable codebase and a clearer user experience when creating and managing protocols.
1156: 
1157: 4. [x] Added comprehensive notification system
1158:    * Created NotificationManager class to handle all notification-related functionality
1159:    * Integrated notification scheduling with protocol management
1160:    * Added adherence tracking system to monitor user compliance
1161:    * Created UI for managing notification preferences and viewing adherence data



================================================================
End of Codebase
================================================================</file><file path="TestoSim/Models/CoreDataExtensions.swift">import Foundation
import CoreData

// MARK: - UserProfile Extensions

extension UserProfile {
    // Create a UserProfile from a Core Data CDUserProfile
    init(from cdProfile: CDUserProfile) {
        self.id = cdProfile.id ?? UUID()
        self.name = cdProfile.name ?? &quot;My Profile&quot;
        self.unit = cdProfile.unit ?? &quot;ng/dL&quot;
        self.calibrationFactor = cdProfile.calibrationFactor
        self.dateOfBirth = cdProfile.dateOfBirth
        self.heightCm = cdProfile.heightCm
        self.weight = cdProfile.weight
        
        // Convert string biologicalSex to enum
        if let sexString = cdProfile.biologicalSex,
           let sex = BiologicalSex(rawValue: sexString) {
            self.biologicalSex = sex
        } else {
            self.biologicalSex = .male
        }
        
        self.usesICloudSync = cdProfile.usesICloudSync
        self.useTwoCompartmentModel = cdProfile.useTwoCompartmentModel
        
        // Extract protocols
        if let cdProtocols = cdProfile.protocols as? Set&lt;CDInjectionProtocol&gt; {
            self.protocols = cdProtocols.compactMap { InjectionProtocol(from: $0) }
        } else {
            self.protocols = []
        }
    }
    
    // Save/update UserProfile to Core Data
    func saveToCD(context: NSManagedObjectContext) -&gt; CDUserProfile {
        // Check if profile already exists
        let fetchRequest: NSFetchRequest&lt;CDUserProfile&gt; = CDUserProfile.fetchRequest()
        fetchRequest.predicate = NSPredicate(format: &quot;id == %@&quot;, self.id as CVarArg)
        
        var cdProfile: CDUserProfile
        
        do {
            let results = try context.fetch(fetchRequest)
            if let existingProfile = results.first {
                cdProfile = existingProfile
            } else {
                cdProfile = CDUserProfile(context: context)
                cdProfile.id = self.id
            }
            
            // Update properties
            cdProfile.name = self.name
            cdProfile.unit = self.unit
            cdProfile.calibrationFactor = self.calibrationFactor
            cdProfile.dateOfBirth = self.dateOfBirth
            cdProfile.heightCm = self.heightCm ?? 0
            cdProfile.weight = self.weight ?? 0
            cdProfile.biologicalSex = self.biologicalSex.rawValue
            cdProfile.usesICloudSync = self.usesICloudSync
            cdProfile.useTwoCompartmentModel = self.useTwoCompartmentModel
            
            // Handle protocols (this will be more complex due to relationships)
            // We&apos;d need to compare existing protocols with new ones
            // For now, we&apos;ll just replace them all
            
            // First, remove all existing protocols
            if let existingProtocols = cdProfile.protocols as? Set&lt;CDInjectionProtocol&gt; {
                for p in existingProtocols {
                    context.delete(p)
                }
            }
            
            // Then add all current protocols
            for p in self.protocols {
                let cdProtocol = p.saveToCD(context: context)
                cdProfile.addToProtocols(cdProtocol)
            }
            
            // Save the context
            try context.save()
            
        } catch {
            print(&quot;Error saving UserProfile to CoreData: \(error)&quot;)
            cdProfile = CDUserProfile(context: context)
            cdProfile.id = self.id
            cdProfile.name = self.name
        }
        
        return cdProfile
    }
}

// MARK: - InjectionProtocol Extensions

extension InjectionProtocol {
    // Create an InjectionProtocol from a Core Data CDInjectionProtocol
    init?(from cdProtocol: CDInjectionProtocol) {
        guard let id = cdProtocol.id,
              let name = cdProtocol.name,
              let startDate = cdProtocol.startDate else {
            return nil
        }
        
        self.id = id
        self.name = name
        self.doseMg = cdProtocol.doseMg
        self.frequencyDays = cdProtocol.frequencyDays
        self.startDate = startDate
        self.notes = cdProtocol.notes
        
        // Try to extract extended properties from notes
        if let notes = cdProtocol.notes, notes.contains(&quot;---EXTENDED_DATA---&quot;) {
            if let range = notes.range(of: &quot;---EXTENDED_DATA---&quot;) {
                let startIndex = range.upperBound
                let jsonString = String(notes[startIndex...]).trimmingCharacters(in: .whitespacesAndNewlines)
                
                if !jsonString.isEmpty, let jsonData = jsonString.data(using: .utf8) {
                    do {
                        if let extendedData = try JSONSerialization.jsonObject(with: jsonData, options: []) as? [String: String] {
                            // Extract properties
                            if let protocolTypeStr = extendedData[&quot;protocolType&quot;], 
                               let _ = ProtocolType(rawValue: protocolTypeStr) {
                                // Protocol type will be set via computed property
                            }
                            
                            if let compoundIDStr = extendedData[&quot;compoundID&quot;], !compoundIDStr.isEmpty {
                                self.compoundID = UUID(uuidString: compoundIDStr)
                            }
                            
                            if let blendIDStr = extendedData[&quot;blendID&quot;], !blendIDStr.isEmpty {
                                self.blendID = UUID(uuidString: blendIDStr)
                            }
                            
                            if let routeStr = extendedData[&quot;selectedRoute&quot;], !routeStr.isEmpty {
                                self.selectedRoute = routeStr
                            }
                        }
                    } catch {
                        print(&quot;Error parsing extended data JSON: \(error)&quot;)
                    }
                }
            }
        }
        
        // Extract blood samples
        if let cdSamples = cdProtocol.bloodSamples as? Set&lt;CDBloodSample&gt; {
            self.bloodSamples = cdSamples.compactMap { BloodSample(from: $0) }
        } else {
            self.bloodSamples = []
        }
    }
    
    // Save/update InjectionProtocol to Core Data
    func saveToCD(context: NSManagedObjectContext) -&gt; CDInjectionProtocol {
        // Check if protocol already exists
        let fetchRequest: NSFetchRequest&lt;CDInjectionProtocol&gt; = CDInjectionProtocol.fetchRequest()
        fetchRequest.predicate = NSPredicate(format: &quot;id == %@&quot;, self.id as CVarArg)
        
        var cdProtocol: CDInjectionProtocol
        
        do {
            let results = try context.fetch(fetchRequest)
            if let existingProtocol = results.first {
                cdProtocol = existingProtocol
            } else {
                cdProtocol = CDInjectionProtocol(context: context)
                cdProtocol.id = self.id
            }
            
            // Update properties
            cdProtocol.name = self.name
            cdProtocol.doseMg = self.doseMg
            cdProtocol.frequencyDays = self.frequencyDays
            cdProtocol.startDate = self.startDate
            
            // Store extended properties in notes field as JSON
            var userNotes = self.notes ?? &quot;&quot;
            
            // Remove existing extended data section if present
            if let range = userNotes.range(of: &quot;---EXTENDED_DATA---&quot;) {
                userNotes = String(userNotes[..&lt;range.lowerBound]).trimmingCharacters(in: .whitespacesAndNewlines)
            }
            
            // Create the extended data dictionary
            let extendedData: [String: String] = [
                &quot;protocolType&quot;: self.protocolType.rawValue,
                &quot;compoundID&quot;: self.compoundID?.uuidString ?? &quot;&quot;,
                &quot;blendID&quot;: self.blendID?.uuidString ?? &quot;&quot;,
                &quot;selectedRoute&quot;: self.selectedRoute ?? &quot;&quot;
            ]
            
            if let extendedJSON = try? JSONEncoder().encode(extendedData),
               let jsonString = String(data: extendedJSON, encoding: .utf8) {
                // Append to notes
                if !userNotes.isEmpty {
                    cdProtocol.notes = userNotes + &quot;\n\n---EXTENDED_DATA---\n&quot; + jsonString
                } else {
                    cdProtocol.notes = &quot;---EXTENDED_DATA---\n&quot; + jsonString
                }
            } else {
                cdProtocol.notes = userNotes
            }
            
            // Handle blood samples
            // First, remove all existing samples
            if let existingSamples = cdProtocol.bloodSamples as? Set&lt;CDBloodSample&gt; {
                for sample in existingSamples {
                    context.delete(sample)
                }
            }
            
            // Then add all current samples
            for sample in self.bloodSamples {
                let cdSample = sample.saveToCD(context: context)
                cdProtocol.addToBloodSamples(cdSample)
            }
            
        } catch {
            print(&quot;Error saving InjectionProtocol to CoreData: \(error)&quot;)
            cdProtocol = CDInjectionProtocol(context: context)
            cdProtocol.id = self.id
            cdProtocol.name = self.name
        }
        
        return cdProtocol
    }
}

// MARK: - BloodSample Extensions

extension BloodSample {
    // Create a BloodSample from a Core Data CDBloodSample
    init?(from cdSample: CDBloodSample) {
        guard let id = cdSample.id,
              let date = cdSample.date,
              let unit = cdSample.unit else {
            return nil
        }
        
        self.id = id
        self.date = date
        self.value = cdSample.value
        self.unit = unit
    }
    
    // Save/update BloodSample to Core Data
    func saveToCD(context: NSManagedObjectContext) -&gt; CDBloodSample {
        // Check if sample already exists
        let fetchRequest: NSFetchRequest&lt;CDBloodSample&gt; = CDBloodSample.fetchRequest()
        fetchRequest.predicate = NSPredicate(format: &quot;id == %@&quot;, self.id as CVarArg)
        
        var cdSample: CDBloodSample
        
        do {
            let results = try context.fetch(fetchRequest)
            if let existingSample = results.first {
                cdSample = existingSample
            } else {
                cdSample = CDBloodSample(context: context)
                cdSample.id = self.id
            }
            
            // Update properties
            cdSample.date = self.date
            cdSample.value = self.value
            cdSample.unit = self.unit
            
        } catch {
            print(&quot;Error saving BloodSample to CoreData: \(error)&quot;)
            cdSample = CDBloodSample(context: context)
            cdSample.id = self.id
        }
        
        return cdSample
    }
}

// MARK: - Compound Extensions

extension Compound {
    // Create a Compound from a Core Data CDCompound
    init?(from cdCompound: CDCompound) {
        guard let id = cdCompound.id,
              let commonName = cdCompound.commonName,
              let classTypeString = cdCompound.classType,
              let classType = Class(rawValue: classTypeString) else {
            return nil
        }
        
        // Default values for dictionaries if serialized data not available
        let bioavailability: [Route: Double] = [.intramuscular: 1.0]
        let absorptionRates: [Route: Double] = [.intramuscular: 0.7]
        
        // Deserialize the dictionary data if available
        if cdCompound.routeBioavailabilityData != nil {
            // We would implement proper deserialization here
            // For now, using default values
        }
        
        if cdCompound.routeKaData != nil {
            // We would implement proper deserialization here
            // For now, using default values
        }
        
        self.id = id
        self.commonName = commonName
        self.classType = classType
        self.ester = cdCompound.ester
        self.halfLifeDays = cdCompound.halfLifeDays
        self.defaultBioavailability = bioavailability
        self.defaultAbsorptionRateKa = absorptionRates
    }
    
    // Save/update Compound to Core Data
    func saveToCD(context: NSManagedObjectContext) -&gt; CDCompound {
        // Check if compound already exists
        let fetchRequest: NSFetchRequest&lt;CDCompound&gt; = CDCompound.fetchRequest()
        fetchRequest.predicate = NSPredicate(format: &quot;id == %@&quot;, self.id as CVarArg)
        
        var cdCompound: CDCompound
        
        do {
            let results = try context.fetch(fetchRequest)
            if let existingCompound = results.first {
                cdCompound = existingCompound
            } else {
                cdCompound = CDCompound(context: context)
                cdCompound.id = self.id
            }
            
            // Update properties
            cdCompound.commonName = self.commonName
            cdCompound.classType = self.classType.rawValue
            cdCompound.ester = self.ester
            cdCompound.halfLifeDays = self.halfLifeDays
            
            // Serialize the dictionaries
            // This is just a placeholder - we would need proper serialization
            // cdCompound.routeBioavailabilityData = serializeDictionary(self.defaultBioavailability)
            // cdCompound.routeKaData = serializeDictionary(self.defaultAbsorptionRateKa)
            
        } catch {
            print(&quot;Error saving Compound to CoreData: \(error)&quot;)
            cdCompound = CDCompound(context: context)
            cdCompound.id = self.id
        }
        
        return cdCompound
    }
}

// MARK: - VialBlend Extensions

extension VialBlend {
    // Create a VialBlend from a Core Data CDVialBlend
    init?(from cdBlend: CDVialBlend) {
        guard let id = cdBlend.id,
              let name = cdBlend.name else {
            return nil
        }
        
        self.id = id
        self.name = name
        self.manufacturer = cdBlend.manufacturer
        self.description = cdBlend.blendDescription
        
        // Extract components
        if let cdComponents = cdBlend.components as? Set&lt;CDVialComponent&gt; {
            self.components = cdComponents.compactMap { Component(from: $0) }
        } else {
            self.components = []
        }
    }
    
    // Save/update VialBlend to Core Data
    func saveToCD(context: NSManagedObjectContext) -&gt; CDVialBlend {
        // Check if blend already exists
        let fetchRequest: NSFetchRequest&lt;CDVialBlend&gt; = CDVialBlend.fetchRequest()
        fetchRequest.predicate = NSPredicate(format: &quot;id == %@&quot;, self.id as CVarArg)
        
        var cdBlend: CDVialBlend
        
        do {
            let results = try context.fetch(fetchRequest)
            if let existingBlend = results.first {
                cdBlend = existingBlend
            } else {
                cdBlend = CDVialBlend(context: context)
                cdBlend.id = self.id
            }
            
            // Update properties
            cdBlend.name = self.name
            cdBlend.manufacturer = self.manufacturer
            cdBlend.blendDescription = self.description
            
            // Handle components
            // First, remove all existing components
            if let existingComponents = cdBlend.components as? Set&lt;CDVialComponent&gt; {
                for component in existingComponents {
                    context.delete(component)
                }
            }
            
            // Then add all current components
            for component in self.components {
                let cdComponent = CDVialComponent(context: context)
                cdComponent.mgPerML = component.mgPerML
                
                // Find the compound
                let compoundFetchRequest: NSFetchRequest&lt;CDCompound&gt; = CDCompound.fetchRequest()
                compoundFetchRequest.predicate = NSPredicate(format: &quot;id == %@&quot;, component.compoundID as CVarArg)
                
                let compoundResults = try context.fetch(compoundFetchRequest)
                if let cdCompound = compoundResults.first {
                    cdComponent.compound = cdCompound
                } else {
                    // Compound not found - this is an error condition
                    print(&quot;Error: Compound with ID \(component.compoundID) not found in Core Data&quot;)
                    continue
                }
                
                cdBlend.addToComponents(cdComponent)
            }
            
        } catch {
            print(&quot;Error saving VialBlend to CoreData: \(error)&quot;)
            cdBlend = CDVialBlend(context: context)
            cdBlend.id = self.id
        }
        
        return cdBlend
    }
}

// MARK: - VialBlend.Component Extensions

extension VialBlend.Component {
    init?(from cdComponent: CDVialComponent) {
        guard let compound = cdComponent.compound,
              let compoundID = compound.id else {
            return nil
        }
        
        self.compoundID = compoundID
        self.mgPerML = cdComponent.mgPerML
    }
}

// MARK: - Cycle Extensions

extension Cycle {
    init(from cdCycle: CDCycle, context: NSManagedObjectContext) {
        self.id = cdCycle.id ?? UUID()
        self.name = cdCycle.name ?? &quot;Unnamed Cycle&quot;
        self.startDate = cdCycle.startDate ?? Date()
        self.totalWeeks = Int(cdCycle.totalWeeks)
        self.notes = cdCycle.notes
        
        // Load stages if they exist
        if let cdStages = cdCycle.stages as? Set&lt;CDCycleStage&gt;, !cdStages.isEmpty {
            self.stages = cdStages.map { CycleStage(from: $0) }.sorted { $0.startWeek &lt; $1.startWeek }
        }
    }
    
    func save(to context: NSManagedObjectContext) -&gt; CDCycle {
        let cdCycle: CDCycle
        
        // Try to find existing entity first
        let fetchRequest: NSFetchRequest&lt;CDCycle&gt; = CDCycle.fetchRequest()
        fetchRequest.predicate = NSPredicate(format: &quot;id == %@&quot;, self.id as CVarArg)
        
        if let existingCycle = try? context.fetch(fetchRequest).first {
            cdCycle = existingCycle
        } else {
            cdCycle = CDCycle(context: context)
            cdCycle.id = self.id
        }
        
        // Update properties
        cdCycle.name = self.name
        cdCycle.startDate = self.startDate
        cdCycle.totalWeeks = Int32(self.totalWeeks)
        cdCycle.notes = self.notes
        
        // Remove old stages
        if let existingStages = cdCycle.stages as? Set&lt;CDCycleStage&gt; {
            for stage in existingStages {
                context.delete(stage)
            }
        }
        
        // Add new stages
        for stage in self.stages {
            let cdStage = stage.save(to: context)
            cdStage.cycle = cdCycle
        }
        
        return cdCycle
    }
}

extension CycleStage {
    init(from cdStage: CDCycleStage) {
        self.id = cdStage.id ?? UUID()
        self.name = cdStage.name ?? &quot;Unnamed Stage&quot;
        self.startWeek = Int(cdStage.startWeek)
        self.durationWeeks = Int(cdStage.durationWeeks)
        
        // Parse compounds and blends from JSON
        if let compoundsData = cdStage.compoundsData, 
           let compoundsArray = try? JSONDecoder().decode([CompoundStageItem].self, from: compoundsData) {
            self.compounds = compoundsArray
        }
        
        if let blendsData = cdStage.blendsData,
           let blendsArray = try? JSONDecoder().decode([BlendStageItem].self, from: blendsData) {
            self.blends = blendsArray
        }
    }
    
    func save(to context: NSManagedObjectContext) -&gt; CDCycleStage {
        let cdStage: CDCycleStage
        
        // Try to find existing entity first
        let fetchRequest: NSFetchRequest&lt;CDCycleStage&gt; = CDCycleStage.fetchRequest()
        fetchRequest.predicate = NSPredicate(format: &quot;id == %@&quot;, self.id as CVarArg)
        
        if let existingStage = try? context.fetch(fetchRequest).first {
            cdStage = existingStage
        } else {
            cdStage = CDCycleStage(context: context)
            cdStage.id = self.id
        }
        
        // Update properties
        cdStage.name = self.name
        cdStage.startWeek = Int32(self.startWeek)
        cdStage.durationWeeks = Int32(self.durationWeeks)
        
        // Save compounds and blends as JSON
        do {
            cdStage.compoundsData = try JSONEncoder().encode(self.compounds)
            cdStage.blendsData = try JSONEncoder().encode(self.blends)
        } catch {
            print(&quot;Error encoding stage items: \(error)&quot;)
        }
        
        return cdStage
    }
}</file><file path="TestoSim/Views/ProfileView.swift">import SwiftUI

struct ProfileView: View {
    @EnvironmentObject var dataStore: AppDataStore
    @State private var dobString: String = &quot;&quot;
    @State private var showingNotificationSettings = false
    @State private var showingInjectionHistory = false
    @State private var showingModelInfo = false
    @State private var showingAllometricInfo = false
    
    var body: some View {
        Form {
            Section(&quot;User&quot;) {
                TextField(&quot;Name&quot;, text: $dataStore.profile.name)
                
                Picker(&quot;Biological Sex&quot;, selection: $dataStore.profile.biologicalSex) {
                    Text(&quot;Male&quot;).tag(UserProfile.BiologicalSex.male)
                    Text(&quot;Female&quot;).tag(UserProfile.BiologicalSex.female)
                }
                
                DatePicker(
                    &quot;Date of Birth&quot;,
                    selection: Binding(
                        get: { dataStore.profile.dateOfBirth ?? Date() },
                        set: { dataStore.profile.dateOfBirth = $0 }
                    ),
                    displayedComponents: .date
                )
                
                if let age = dataStore.profile.age {
                    Text(&quot;Age: \(age) years&quot;)
                        .foregroundColor(.secondary)
                }
            }
            
            Section(&quot;Physical Measurements&quot;) {
                HStack {
                    Text(&quot;Height&quot;)
                    Spacer()
                    TextField(&quot;Height&quot;, value: Binding(
                        get: { dataStore.profile.heightCm ?? 0 },
                        set: { dataStore.profile.heightCm = $0 &gt; 0 ? $0 : nil }
                    ), format: .number)
                    .keyboardType(.decimalPad)
                    .multilineTextAlignment(.trailing)
                    .frame(width: 80)
                    Text(&quot;cm&quot;)
                        .foregroundColor(.secondary)
                }
                
                HStack {
                    Text(&quot;Weight&quot;)
                    Spacer()
                    TextField(&quot;Weight&quot;, value: Binding(
                        get: { dataStore.profile.weight ?? 0 },
                        set: { dataStore.profile.weight = $0 &gt; 0 ? $0 : nil }
                    ), format: .number)
                    .keyboardType(.decimalPad)
                    .multilineTextAlignment(.trailing)
                    .frame(width: 80)
                    Text(&quot;kg&quot;)
                        .foregroundColor(.secondary)
                }
                
                if let bsa = dataStore.profile.bodySurfaceArea {
                    Text(&quot;Body Surface Area: \(bsa, specifier: &quot;%.2f&quot;) m²&quot;)
                        .foregroundColor(.secondary)
                }
                
                Button {
                    showingAllometricInfo = true
                } label: {
                    HStack {
                        Image(systemName: &quot;scalemass&quot;)
                            .frame(width: 25, height: 25)
                            .foregroundColor(.blue)
                        Text(&quot;How physical measurements improve accuracy&quot;)
                        Spacer()
                        Image(systemName: &quot;chevron.right&quot;)
                            .foregroundColor(.gray)
                    }
                }
                .sheet(isPresented: $showingAllometricInfo) {
                    AllometricInfoView()
                }
            }
            
            Section(&quot;Notifications &amp; Adherence&quot;) {
                Button {
                    showingNotificationSettings = true
                } label: {
                    HStack {
                        Image(systemName: &quot;bell&quot;)
                            .frame(width: 25, height: 25)
                            .foregroundColor(.blue)
                        Text(&quot;Notification Settings&quot;)
                        Spacer()
                        Image(systemName: &quot;chevron.right&quot;)
                            .foregroundColor(.gray)
                    }
                }
                
                Button {
                    showingInjectionHistory = true
                } label: {
                    HStack {
                        Image(systemName: &quot;list.clipboard&quot;)
                            .frame(width: 25, height: 25)
                            .foregroundColor(.blue)
                        Text(&quot;Injection History&quot;)
                        Spacer()
                        Image(systemName: &quot;chevron.right&quot;)
                            .foregroundColor(.gray)
                    }
                }
                
                // Show adherence rate if we have any data
                if dataStore.adherenceStats().total &gt; 0 {
                    HStack {
                        Text(&quot;Adherence Rate:&quot;)
                        Spacer()
                        Text(String(format: &quot;%.1f%%&quot;, dataStore.adherencePercentage()))
                            .fontWeight(.bold)
                    }
                }
            }
            
            Section(&quot;Settings&quot;) {
                Picker(&quot;Preferred Unit&quot;, selection: $dataStore.profile.unit) {
                    Text(&quot;ng/dL&quot;).tag(&quot;ng/dL&quot;)
                    Text(&quot;nmol/L&quot;).tag(&quot;nmol/L&quot;)
                }
                
                Toggle(&quot;Use iCloud Sync&quot;, isOn: $dataStore.profile.usesICloudSync)
                
                HStack {
                    Text(&quot;Advanced PK Model&quot;)
                    Spacer()
                    Text(&quot;Enabled&quot;)
                        .foregroundColor(.secondary)
                    Button {
                        showingModelInfo = true
                    } label: {
                        Image(systemName: &quot;info.circle&quot;)
                            .foregroundColor(.blue)
                    }
                    .buttonStyle(BorderlessButtonStyle())
                }
                .alert(&quot;Advanced PK Model&quot;, isPresented: $showingModelInfo) {
                    Button(&quot;OK&quot;, role: .cancel) { }
                } message: {
                    Text(&quot;The app uses a two-compartment pharmacokinetic model that provides accurate concentration predictions, especially for long-acting compounds. Modern devices can easily handle this advanced calculation model.&quot;)
                }
            }
            
            Section(&quot;Calibration&quot;) {
                Text(&quot;Model Calibration Factor: \(dataStore.profile.calibrationFactor.formatted(.number.precision(.fractionLength(2))))&quot;)
                Button(&quot;Reset Calibration to 1.0&quot;) {
                    dataStore.profile.calibrationFactor = 1.0
                    dataStore.recalcSimulation()
                    dataStore.saveProfile()
                }
            }
        }
        .navigationTitle(&quot;Profile Settings&quot;)
        .onDisappear {
            dataStore.saveProfile()
        }
        .sheet(isPresented: $showingNotificationSettings) {
            NotificationSettingsView()
                .environmentObject(dataStore)
        }
        .sheet(isPresented: $showingInjectionHistory) {
            InjectionHistoryView()
                .environmentObject(dataStore)
        }
    }
}

struct AllometricInfoView: View {
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(alignment: .leading, spacing: 16) {
                    Group {
                        Text(&quot;How Your Measurements Improve Accuracy&quot;)
                            .font(.title)
                            .fontWeight(.bold)
                            .padding(.bottom, 6)
                        
                        Text(&quot;TestoSim uses allometric scaling to personalize pharmacokinetic predictions based on your physical measurements.&quot;)
                            .font(.headline)
                            .padding(.bottom, 6)
                        
                        Text(&quot;What is Allometric Scaling?&quot;)
                            .font(.title2)
                            .fontWeight(.bold)
                        
                        Text(&quot;Allometric scaling is a scientific approach that accounts for how drug metabolism and distribution scales with body size. People with different body sizes process medications differently.&quot;)
                        
                        HStack {
                            Image(systemName: &quot;chart.line.uptrend.xyaxis&quot;)
                                .font(.largeTitle)
                                .foregroundColor(.blue)
                                .padding()
                            
                            VStack(alignment: .leading) {
                                Text(&quot;Volume of Distribution&quot;)
                                    .fontWeight(.bold)
                                Text(&quot;Vd(user) = Vd(70kg) × (Weight/70)¹·⁰&quot;)
                                Text(&quot;How your bodyweight affects how widely the compound distributes throughout your body.&quot;)
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                        }
                        .padding()
                        .background(Color.gray.opacity(0.1))
                        .cornerRadius(8)
                        
                        HStack {
                            Image(systemName: &quot;waveform.path.ecg&quot;)
                                .font(.largeTitle)
                                .foregroundColor(.blue)
                                .padding()
                            
                            VStack(alignment: .leading) {
                                Text(&quot;Clearance Rate&quot;)
                                    .fontWeight(.bold)
                                Text(&quot;CL(user) = CL(70kg) × (Weight/70)⁰·⁷⁵&quot;)
                                Text(&quot;How your bodyweight affects how quickly your body eliminates the compound.&quot;)
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                        }
                        .padding()
                        .background(Color.gray.opacity(0.1))
                        .cornerRadius(8)
                    }
                    
                    Group {
                        Text(&quot;Benefits of Providing Your Measurements&quot;)
                            .font(.title2)
                            .fontWeight(.bold)
                            .padding(.top)
                        
                        VStack(alignment: .leading, spacing: 8) {
                            Label(&quot;More accurate peak and trough predictions&quot;, systemImage: &quot;checkmark.circle&quot;)
                            Label(&quot;Better timing recommendations for blood tests&quot;, systemImage: &quot;checkmark.circle&quot;)
                            Label(&quot;More precise dosing guidance&quot;, systemImage: &quot;checkmark.circle&quot;)
                            Label(&quot;Personalized pharmacokinetic calculations&quot;, systemImage: &quot;checkmark.circle&quot;)
                        }
                        .padding(.leading)
                        
                        Text(&quot;Scientific Basis&quot;)
                            .font(.title2)
                            .fontWeight(.bold)
                            .padding(.top)
                        
                        Text(&quot;This approach is based on peer-reviewed research on how testosterone pharmacokinetics vary with body size. The scaling exponents (1.0 for volume, 0.75 for clearance) are derived from population studies.&quot;)
                        
                        Text(&quot;TestoSim applies these principles to all compounds in the library to provide you with the most accurate predictions possible.&quot;)
                    }
                }
                .padding()
            }
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(&quot;Done&quot;) {
                        dismiss()
                    }
                }
            }
            .navigationBarTitleDisplayMode(.inline)
        }
    }
}

#Preview {
    NavigationStack {
        ProfileView()
            .environmentObject(AppDataStore())
    }
}</file><file path="TestoSim/Views/ProtocolFormView.swift">import SwiftUI

struct ProtocolFormView: View {
    @EnvironmentObject var dataStore: AppDataStore
    @Environment(\.dismiss) var dismiss
    
    var protocolToEdit: InjectionProtocol?
    
    // MARK: - State variables
    @State private var name: String = &quot;&quot;
    @State private var doseMg: String = &quot;&quot;
    @State private var frequencyDays: String = &quot;&quot;
    @State private var startDate: Date = Date()
    @State private var notes: String = &quot;&quot;
    
    // Protocol type and selection variables
    @State private var protocolType: ProtocolType = .compound
    @State private var selectedCompoundID: UUID?
    @State private var selectedBlendID: UUID?
    @State private var selectedRoute: Compound.Route = .intramuscular
    
    // Sheet presentation flags
    @State private var showingCompoundPicker = false
    @State private var showingBlendPicker = false
    
    var isEditing: Bool {
        protocolToEdit != nil
    }
    
    var selectedCompoundName: String {
        if let id = selectedCompoundID,
           let compound = dataStore.compoundLibrary.compound(withID: id) {
            return compound.fullDisplayName
        }
        return &quot;Select Compound&quot;
    }
    
    var selectedBlendName: String {
        if let id = selectedBlendID,
           let blend = dataStore.compoundLibrary.blend(withID: id) {
            return blend.name
        }
        return &quot;Select Blend&quot;
    }
    
    var body: some View {
        NavigationView {
            Form {
                Section(header: Text(&quot;Protocol Details&quot;)) {
                    TextField(&quot;Name&quot;, text: $name)
                    
                    // Protocol Type Selector
                    Picker(&quot;Type&quot;, selection: $protocolType) {
                        Text(&quot;Compound&quot;).tag(ProtocolType.compound)
                        Text(&quot;Blend&quot;).tag(ProtocolType.blend)
                    }
                    .pickerStyle(SegmentedPickerStyle())
                    .onChange(of: protocolType) { oldValue, newValue in
                        // Reset selection when changing type
                        if protocolType != .compound {
                            selectedCompoundID = nil
                        }
                        if protocolType != .blend {
                            selectedBlendID = nil
                        }
                    }
                    
                    // Dynamically show the appropriate selection UI based on protocol type
                    switch protocolType {
                    case .compound:
                        Button(action: {
                            showingCompoundPicker = true
                        }) {
                            HStack {
                                Text(&quot;Compound&quot;)
                                Spacer()
                                Text(selectedCompoundName)
                                    .foregroundColor(.secondary)
                                Image(systemName: &quot;chevron.right&quot;)
                                    .foregroundColor(.secondary)
                                    .font(.caption)
                            }
                        }
                        
                        // Show route picker if compound is selected
                        if selectedCompoundID != nil,
                           let compound = dataStore.compoundLibrary.compound(withID: selectedCompoundID!) {
                            
                            // Filter routes to only those supported by the compound
                            let supportedRoutes = compound.defaultBioavailability.keys.filter { 
                                (compound.defaultBioavailability[$0] ?? 0) &gt; 0 
                            }
                            
                            if !supportedRoutes.isEmpty {
                                Picker(&quot;Administration Route&quot;, selection: $selectedRoute) {
                                    ForEach(supportedRoutes.sorted(by: { $0.rawValue &lt; $1.rawValue }), id: \.self) { route in
                                        Text(route.displayName).tag(route)
                                    }
                                }
                                .onChange(of: selectedRoute) { oldValue, newRoute in
                                    // Ensure the route is valid for this compound
                                    if let compound = dataStore.compoundLibrary.compound(withID: selectedCompoundID!),
                                       (compound.defaultBioavailability[newRoute] ?? 0) &lt;= 0 {
                                        // If invalid, pick the first supported route
                                        if let firstValid = compound.defaultBioavailability.keys.first {
                                            selectedRoute = firstValid
                                        }
                                    }
                                }
                            }
                        }
                        
                    case .blend:
                        Button(action: {
                            showingBlendPicker = true
                        }) {
                            HStack {
                                Text(&quot;Vial Blend&quot;)
                                Spacer()
                                Text(selectedBlendName)
                                    .foregroundColor(.secondary)
                                Image(systemName: &quot;chevron.right&quot;)
                                    .foregroundColor(.secondary)
                                    .font(.caption)
                            }
                        }
                        
                        // For blends, always default to intramuscular
                        Picker(&quot;Administration Route&quot;, selection: $selectedRoute) {
                            Text(&quot;Intramuscular (IM)&quot;).tag(Compound.Route.intramuscular)
                        }
                    }
                    
                    #if os(iOS)
                    TextField(&quot;Dose (mg)&quot;, text: $doseMg)
                        .keyboardType(.decimalPad)
                    #else
                    TextField(&quot;Dose (mg)&quot;, text: $doseMg)
                    #endif
                    
                    #if os(iOS)
                    TextField(&quot;Frequency (days)&quot;, text: $frequencyDays)
                        .keyboardType(.decimalPad)
                    #else
                    TextField(&quot;Frequency (days)&quot;, text: $frequencyDays)
                    #endif
                    
                    DatePicker(&quot;Start Date&quot;, selection: $startDate, displayedComponents: [.date])
                }
                
                Section(header: Text(&quot;Notes&quot;)) {
                    TextEditor(text: $notes)
                        .frame(height: 100)
                }
            }
            .navigationTitle(isEditing ? &quot;Edit Protocol&quot; : &quot;New Protocol&quot;)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button(&quot;Cancel&quot;) {
                        dismiss()
                    }
                }
                
                ToolbarItem(placement: .confirmationAction) {
                    Button(isEditing ? &quot;Update&quot; : &quot;Add&quot;) {
                        saveProtocol()
                    }
                    .disabled(!isValid)
                }
            }
            .onAppear {
                if let protocolToEdit = protocolToEdit {
                    // Fill form with existing protocol data
                    name = protocolToEdit.name
                    
                    // Determine which protocol type we&apos;re editing
                    protocolType = protocolToEdit.protocolType
                    selectedCompoundID = protocolToEdit.compoundID
                    selectedBlendID = protocolToEdit.blendID
                    
                    // Set route if available
                    if let routeString = protocolToEdit.selectedRoute,
                       let route = Compound.Route(rawValue: routeString) {
                        selectedRoute = route
                    } else {
                        selectedRoute = .intramuscular // Default
                    }
                    
                    doseMg = String(format: &quot;%.1f&quot;, protocolToEdit.doseMg)
                    frequencyDays = String(format: &quot;%.1f&quot;, protocolToEdit.frequencyDays)
                    startDate = protocolToEdit.startDate
                    notes = protocolToEdit.notes ?? &quot;&quot;
                }
            }
            .sheet(isPresented: $showingCompoundPicker) {
                CompoundListView(selectedCompoundID: $selectedCompoundID)
                    .environmentObject(dataStore)
            }
            .sheet(isPresented: $showingBlendPicker) {
                VialBlendListView(selectedBlendID: $selectedBlendID)
                    .environmentObject(dataStore)
            }
        }
    }
    
    private var isValid: Bool {
        // Basic validation
        guard !name.isEmpty &amp;&amp; Double(doseMg) != nil &amp;&amp; Double(frequencyDays) != nil else {
            return false
        }
        
        // Type-specific validation
        switch protocolType {
        case .compound:
            return selectedCompoundID != nil
        case .blend:
            return selectedBlendID != nil
        }
    }
    
    private func saveProtocol() {
        guard let doseValue = Double(doseMg),
              let frequencyValue = Double(frequencyDays) else {
            return
        }
        
        if isEditing, let protocolToEdit = protocolToEdit {
            var updatedProtocol = protocolToEdit
            updatedProtocol.name = name
            updatedProtocol.doseMg = doseValue
            updatedProtocol.frequencyDays = frequencyValue
            updatedProtocol.startDate = startDate
            updatedProtocol.notes = notes.isEmpty ? nil : notes
            
            // Update the protocol type-specific properties
            switch protocolType {
            case .compound:
                updatedProtocol.compoundID = selectedCompoundID
                updatedProtocol.blendID = nil
                updatedProtocol.selectedRoute = selectedRoute.rawValue
                
            case .blend:
                updatedProtocol.compoundID = nil
                updatedProtocol.blendID = selectedBlendID
                updatedProtocol.selectedRoute = selectedRoute.rawValue
            }
            
            dataStore.updateProtocol(updatedProtocol)
        } else {
            var newProtocol = InjectionProtocol(
                name: name,
                doseMg: doseValue,
                frequencyDays: frequencyValue,
                startDate: startDate,
                notes: notes.isEmpty ? nil : notes
            )
            
            // Set the protocol type-specific properties
            switch protocolType {
            case .compound:
                newProtocol.compoundID = selectedCompoundID
                newProtocol.selectedRoute = selectedRoute.rawValue
                
            case .blend:
                newProtocol.blendID = selectedBlendID
                newProtocol.selectedRoute = selectedRoute.rawValue
            }
            
            dataStore.addProtocol(newProtocol)
        }
        
        dismiss()
    }
}

#Preview {
    ProtocolFormView()
        .environmentObject(AppDataStore())
}</file><file path="TestoSim/Views/TestosteroneChart.swift">import SwiftUI
import Charts

struct TestosteroneChart: View {
    @EnvironmentObject var dataStore: AppDataStore
    let treatmentProtocol: InjectionProtocol
    
    @State private var selectedDataPoint: DataPoint?
    @State private var selectedDate: Date?
    
    // Find reasonable min/max for Y axis
    private var yAxisRange: ClosedRange&lt;Double&gt; {
        if dataStore.simulationData.isEmpty {
            return 0...1000
        }
        
        let levels = dataStore.simulationData.map { $0.level }
        let minLevel = max(0, levels.min() ?? 0)
        let maxLevel = max(1000, levels.max() ?? 1000)
        
        // Add 20% padding at top
        return minLevel...(maxLevel * 1.2)
    }
    
    // Find dates for X axis to avoid super tiny display
    private var dateRange: ClosedRange&lt;Date&gt; {
        guard !dataStore.simulationData.isEmpty else {
            return Date()...(Date().addingTimeInterval(30*24*3600))
        }
        
        if let firstDate = dataStore.simulationData.first?.time,
           let lastDate = dataStore.simulationData.last?.time {
            return firstDate...lastDate
        }
        
        return Date()...(Date().addingTimeInterval(30*24*3600))
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            // Header
            HStack {
                Text(&quot;Concentration Chart&quot;)
                    .font(.headline)
                Spacer()
                Text(dataStore.profile.unit)
                    .foregroundColor(.secondary)
            }
            
            ZStack(alignment: .topLeading) {
                // Chart
                Chart {
                    // Main concentration line
                    ForEach(dataStore.simulationData) { dataPoint in
                        LineMark(
                            x: .value(&quot;Date&quot;, dataPoint.time),
                            y: .value(&quot;Level&quot;, dataPoint.level)
                        )
                        .foregroundStyle(Color.blue.gradient)
                        .interpolationMethod(.catmullRom)
                        .lineStyle(StrokeStyle(lineWidth: 2.5))
                    }
                    
                    // Highlight selected point
                    if let selectedPoint = selectedDataPoint {
                        PointMark(
                            x: .value(&quot;Date&quot;, selectedPoint.time),
                            y: .value(&quot;Level&quot;, selectedPoint.level)
                        )
                        .symbolSize(100)
                        .foregroundStyle(Color.blue.opacity(0.3))
                    }
                    
                    // Injection dates markers
                    let injectionDates = treatmentProtocol.injectionDates(
                        from: dateRange.lowerBound,
                        upto: dateRange.upperBound
                    )
                    
                    ForEach(injectionDates, id: \.self) { date in
                        // Add point markers for injections
                        PointMark(
                            x: .value(&quot;Injection&quot;, date),
                            y: .value(&quot;Level&quot;, findLevelAt(date: date))
                        )
                        .foregroundStyle(Color.green)
                        .symbolSize(30)
                        
                        // Add vertical lines
                        RuleMark(
                            x: .value(&quot;Injection&quot;, date)
                        )
                        .foregroundStyle(Color.green.opacity(0.2))
                        .lineStyle(StrokeStyle(lineWidth: 1, dash: [4, 4]))
                    }
                    
                    // Show selected date vertical line
                    if let date = selectedDate {
                        RuleMark(
                            x: .value(&quot;Selected&quot;, date)
                        )
                        .foregroundStyle(Color.secondary.opacity(0.5))
                    }
                }
                .chartYScale(domain: yAxisRange)
                .chartXScale(domain: dateRange)
                .chartXAxis {
                    AxisMarks(values: .stride(by: .day, count: 7)) { _ in
                        AxisValueLabel(format: .dateTime.month().day())
                        AxisGridLine()
                    }
                }
                .chartYAxis {
                    AxisMarks(position: .leading, values: .automatic(desiredCount: 5)) { value in
                        let level = value.as(Double.self) ?? 0
                        AxisValueLabel(&quot;\(level.isFinite ? Int(level) : 0)&quot;)
                        AxisGridLine()
                    }
                }
                .frame(height: 250)
                .chartOverlay { proxy in
                    GeometryReader { geo in
                        Rectangle()
                            .fill(Color.clear)
                            .contentShape(Rectangle())
                            .gesture(
                                DragGesture(minimumDistance: 0)
                                    .onChanged { value in
                                        let x = value.location.x - geo.frame(in: .local).origin.x
                                        guard let date = proxy.value(atX: x, as: Date.self) else { return }
                                        
                                        selectedDate = date
                                        if let closestPoint = findClosestDataPoint(to: date) {
                                            selectedDataPoint = closestPoint
                                        }
                                    }
                                    .onEnded { _ in
                                        selectedDate = nil
                                        selectedDataPoint = nil
                                    }
                            )
                    }
                }
                
                // If no data, show message
                if dataStore.simulationData.isEmpty {
                    Text(&quot;No data available for chart&quot;)
                        .foregroundColor(.secondary)
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                        .background(Color(.systemGray6).opacity(0.5))
                }
            }
            
            // Display selected point info
            if let selected = selectedDataPoint {
                HStack {
                    VStack(alignment: .leading) {
                        Text(selected.time, style: .date)
                            .font(.caption)
                        Text(selected.time, style: .time)
                            .font(.caption)
                    }
                    
                    Spacer()
                    
                    Text(&quot;\(selected.level.isFinite ? Int(selected.level) : 0) \(dataStore.profile.unit)&quot;)
                        .font(.headline)
                        .foregroundColor(.blue)
                }
                .padding(.vertical, 4)
            }
        }
        .padding()
        .background(Color(.systemGray6))
        .cornerRadius(10)
    }
    
    private func findClosestDataPoint(to date: Date) -&gt; DataPoint? {
        guard !dataStore.simulationData.isEmpty else { return nil }
        
        return dataStore.simulationData.min(by: { abs($0.time.timeIntervalSince(date)) &lt; abs($1.time.timeIntervalSince(date)) })
    }
    
    private func findLevelAt(date: Date) -&gt; Double {
        guard !dataStore.simulationData.isEmpty else { return 0 }
        
        if let closestPoint = findClosestDataPoint(to: date) {
            return closestPoint.level
        }
        
        // If no close point found, try to calculate directly
        return dataStore.predictedLevel(on: date, for: treatmentProtocol)
    }
}</file><file path="TestoSim/TestoSimApp.swift">//
//  TestoSimApp.swift
//  TestoSim
//
//  Created by Jesper Vang on 01/05/2025.
//

import SwiftUI
import CoreData
#if os(iOS)
import UIKit
#elseif os(macOS)
import AppKit
#endif

@main
struct TestoSimApp: App {
    @StateObject private var dataStore = AppDataStore()
    
    // Create a reference to the Core Data manager
    private let coreDataManager = CoreDataManager.shared
    
    init() {
        print(&quot;TestoSim is starting up...&quot;)
        
        // Set up default API key settings if not already set
        if UserDefaults.standard.object(forKey: &quot;use_test_api_key&quot;) == nil {
            // Enable test API key by default for all users
            UserDefaults.standard.set(true, forKey: &quot;use_test_api_key&quot;)
            print(&quot;Default API key settings initialized: Using test key&quot;)
        }
    }
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(dataStore)
                .environment(\.managedObjectContext, coreDataManager.persistentContainer.viewContext)
                #if os(iOS)
                .onReceive(NotificationCenter.default.publisher(for: UIApplication.willResignActiveNotification)) { _ in
                    // Save when app moves to background
                    coreDataManager.saveContext()
                }
                #elseif os(macOS)
                .onReceive(NotificationCenter.default.publisher(for: NSApplication.willResignActiveNotification)) { _ in
                    // Save when app moves to background
                    coreDataManager.saveContext()
                }
                #endif
        }
    }
}</file><file path=".gitignore"># Xcode
#
# gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore &amp; Swift.gitignore

## User settings
xcuserdata/

## Compatibility with Xcode
*.moved-aside
*.xccheckout
*.xcscmblueprint

## Build generated
build/
DerivedData/

## Various settings
*.pbxuser
!default.pbxuser
*.mode1v3
!default.mode1v3
*.mode2v3
!default.mode2v3
*.perspectivev3
!default.perspectivev3

## Other
*.moved-aside
*.xcuserdata
*.xcscmblueprint

## Obj-C/Swift specific
*.hmap
*.ipa
*.dSYM.zip
*.dSYM

## Playgrounds
timeline.xctimeline
playground.xcworkspace

# Swift Package Manager
#
# Add this line if you want to avoid checking in source code from Swift Package Manager dependencies.
# Packages/
# Package.pins
# Package.resolved
# *.xcodeproj
#
# Xcode automatically generates this directory with a .xcworkspacedata file and xcuserdata
# hence it is not needed unless you have added a package configuration file to your project
# .swiftpm

# CocoaPods
#
# We recommend against adding the Pods directory to your .gitignore. However
# you should judge for yourself, the pros and cons are mentioned at:
# https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control
#
# Pods/
#
# Add this line if you want to avoid checking in source code from the Xcode workspace
# *.xcworkspace

# Carthage
#
# Add this line if you want to avoid checking in source code from Carthage dependencies.
# Carthage/Checkouts

Carthage/Build/

# Accio dependency management
Dependencies/
.accio/

# fastlane
#
# It is recommended to not store the screenshots in the git repo.
# Instead, use fastlane to re-generate the screenshots whenever they are needed.
# For more information about the recommended setup visit:
# https://docs.fastlane.tools/best-practices/source-control/#source-control

fastlane/report.xml
fastlane/Preview.html
fastlane/screenshots/**/*.png
fastlane/test_output

# Code Injection
#
# After new code Injection tools there&apos;s a generated folder /iOSInjectionProject
# https://github.com/johnno1962/injectionforxcode

iOSInjectionProject/

# macOS
.DS_Store

# cursor
.cursor/

# App specific
memory.jsonl 
.claude/
.repomix/
ai_docs/
specs/

# API Keys
TestoSim/Config.xcconfig
TestoSim/Config.plist</file><file path="README.md"># TestoSim

TestoSim is a testosterone pharmacokinetics simulation app that helps visualize injection protocols and predict hormone levels.

## Recent Changes and Updates

### Model Refinements (June 2024)
- **Removed TestosteroneEster Model**: Simplified the codebase by removing the redundant TestosteroneEster model in favor of the more flexible Compound model
- **Protocol Type Selection**: Protocols now clearly identify as either compound-based or blend-based
- **CloudKit Integration**: Fixed container ID issues in CoreDataManager and improved iCloud sync stability
- **UI Improvements**: Updated protocol creation process with a streamlined interface for compound and blend selection
- **Calibration View Fixes**: Resolved compiler issues with CalibrationResultView and parameter naming conflicts
- **Code Cleanup**: Fixed various Swift compiler warnings and improved view composition to avoid &quot;unable to type-check&quot; errors

The app now provides a more consistent experience when creating and managing protocols, with proper support for different compound types and routes of administration.

## Simulator Management

To prevent issues with multiple simulator instances, use the following scripts:

### Build Without Launching (Recommended)

```bash
./build-test.sh [clean]
```

- Use this script to build the application without launching a simulator
- Add `clean` parameter to perform a clean build
- After building, use SweetPad to run the app in a simulator

### Close All Simulators

```bash
./close-simulators.sh
```

- Shuts down all running simulator instances
- Use this if multiple simulators are running and causing issues

### Launch in a Single Simulator

```bash
./launch-test.sh [device_name]
```

- Builds, installs, and launches the app in a specified simulator
- Defaults to &quot;iPhone 16&quot; if no device is specified
- Example: `./launch-test.sh &quot;iPhone 16 Pro&quot;`
- Automatically closes other simulators before launching

## Development Workflow

For the best development experience:

1. Use VS Code with SweetPad extension:
   - Run task &quot;SweetPad: Build&quot; from the command palette (Cmd+Shift+P) or context menu
   - This builds and runs the app in a single simulator instance

2. For command-line builds:
   - Use `./build-test.sh` to build without launching simulators
   - Use `./close-simulators.sh` if you have multiple simulators running

3. For testing specific issues:
   - Use `./launch-test.sh` to launch in a specific simulator
   - This helps isolate issues by using a clean, single simulator instance

## Troubleshooting

If the app crashes during launch:
1. Close all simulators: `./close-simulators.sh`
2. Clean build: `./build-test.sh clean`
3. Launch with a specific device: `./launch-test.sh &quot;iPhone 16&quot;`

If errors still occur, check the device logs:
```bash
xcrun simctl spawn booted log stream --predicate &apos;processImagePath contains &quot;TestoSim&quot;&apos; --style compact
```

## CloudKit Integration

TestoSim uses CloudKit for cloud data synchronization across devices. This allows users to access their protocols, compounds, and bloodwork results on all their iOS devices.

### Key Features

- User profiles, protocols, and bloodwork data synchronize across devices
- Automatic conflict resolution and merging
- Offline capability with sync when connectivity is restored

### Implementation Details

- The app uses `NSPersistentCloudKitContainer` for Core Data + CloudKit integration
- CloudKit sync can be toggled on/off in the app settings
- Data is stored in the `iCloud.flight505.TestoSim` private database

### Requirements

- User must be signed into iCloud on the device
- iCloud Drive must be enabled
- Proper entitlements are included in the app bundle

### Troubleshooting CloudKit Sync

If data is not syncing properly:

1. Verify the user is signed into iCloud: Settings &gt; Apple ID &gt; iCloud
2. Check iCloud Drive is enabled
3. In the app, toggle CloudKit sync off and back on
4. Restart the app after changing sync settings for changes to take effect

## Compound Selection

TestoSim uses a comprehensive system for selecting compounds:

### Features

- **Compounds Library**: A full database of compounds with accurate pharmacokinetic parameters:
  - Testosterone esters (propionate, enanthate, cypionate, etc.)
  - Other compounds (nandrolone, trenbolone, boldenone, etc.)
  - Various administration routes (intramuscular, subcutaneous, oral, transdermal)

- **Vial Blends**: Support for commercial multi-compound blends:
  - Pre-defined blends like Sustanon 250/350
  - Each component tracked individually with proper pharmacokinetics

### Implementation

- Compounds are modeled with class types, esters, half-lives, and route-specific parameters
- Complete absorption and bioavailability characteristics for each compound and route
- Accurate simulation of single compounds and complex blends 

## API Key Configuration

The TestoSim app uses OpenAI&apos;s API for generating insights about hormone protocols and cycles. The app includes a free test API key with a $20 spending limit for all users.

### For Developers

When cloning this repository for development:

1. The app uses configuration files to store API keys:
   - `Config.xcconfig` - For build-time configuration
   - `Config.plist` - For runtime configuration
   
2. Sample files with placeholders are included in the repository:
   - `Config-Sample.xcconfig`
   - `Config-Sample.plist`
   
3. On first build, the script `copy-config.sh` will automatically copy the sample files to create the real config files if they don&apos;t exist.

4. To set up your own API key:
   - Open `TestoSim/Config.plist`
   - Replace the placeholder value with your OpenAI API key
   - Clean and rebuild the project

### Security Notes

- Both `Config.xcconfig` and `Config.plist` are excluded from git in `.gitignore`
- Users can toggle between using their own API key or the test API key in the AI settings
- The API key is never stored directly in the source code</file><file path="TestoSim/Models/PKModel.swift">import Foundation

/// Pharmacokinetic model for calculating hormone concentrations
struct PKModel {
    
    // MARK: - Constants
    
    /// Typical volume of distribution for a 70kg person in liters
    static let defaultVolumeOfDistribution70kg: Double = 15.0 // L (corrected from 70.0, typical Vd for testosterone)
    
    /// Default clearance for a 70kg person in L/day
    static let defaultClearance70kg: Double = 2.4 // L/day (Updated based on literature)
    
    /// Endogenous testosterone production rate in mg/day for adult males
    static let endogenousProductionRate: Double = 7.0 // mg/day
    
    /// Minimum reportable concentration to avoid numerical issues
    static let minimumReportableConcentration: Double = 0.01
    
    // MARK: - Properties
    
    /// Using two-compartment model (more accurate but more computationally intensive)
    /// Modern devices can handle this computation without issues
    var useTwoCompartmentModel: Bool = true
    
    /// Fixed compartment transfer rates for two-compartment model
    let k12: Double = 0.3 // d⁻¹
    let k21: Double = 0.15 // d⁻¹
    
    /// Flag to include endogenous production in calculations
    var includeEndogenousProduction: Bool = true
    
    // MARK: - Initialization
    
    init(useTwoCompartmentModel: Bool = true, includeEndogenousProduction: Bool = true) {
        // Always use two-compartment model, parameter kept for backward compatibility
        self.useTwoCompartmentModel = true
        self.includeEndogenousProduction = includeEndogenousProduction
    }
    
    // MARK: - Concentration Calculations
    
    /// Calculate concentration for a single dose administration, including endogenous production
    /// - Parameters:
    ///   - time: Time in days since administration
    ///   - dose: Dose in mg
    ///   - halfLifeDays: Half-life in days
    ///   - absorptionRateKa: Absorption rate constant (ka) in d⁻¹
    ///   - bioavailability: Fraction of drug absorbed (0-1)
    ///   - weight: Patient weight in kg (for allometric scaling)
    ///   - calibrationFactor: User-specific calibration factor
    /// - Returns: Concentration in the appropriate units
    func concentration(
        at time: Double,
        dose: Double,
        halfLifeDays: Double,
        absorptionRateKa: Double,
        bioavailability: Double,
        weight: Double = 70.0,
        calibrationFactor: Double = 1.0
    ) -&gt; Double {
        // Skip calculation if time is negative or zero
        guard time &gt; 0 &amp;&amp; halfLifeDays &gt; 0 else { 
            return includeEndogenousProduction ? calculateBaselineConcentration(weight: weight) : 0
        }
        
        // Elimination rate constant (ke) = ln(2)/t_1/2
        let ke = log(2) / halfLifeDays
        
        // Calculate clearance (CL) with allometric scaling
        let clearance = PKModel.defaultClearance70kg * pow(weight / 70.0, 0.75) // Use 0.75 power for clearance
        
        // Calculate volume of distribution with allometric scaling
        let vd = PKModel.defaultVolumeOfDistribution70kg * pow(weight / 70.0, 1.0)
        
        // Calculate baseline concentration (endogenous testosterone)
        let baselineConcentration = includeEndogenousProduction ? calculateBaselineConcentration(weight: weight) : 0
        
        // Skip calculation if ka ≤ ke (avoid division by zero or negative value)
        // Also skip two-compartment when ka is close to ke to avoid numerical instability
        if absorptionRateKa &lt;= (ke * 1.05) {
            let exogenousConcentration = oneCompartmentBolus(
                time: time,
                dose: dose,
                ke: ke,
                bioavailability: bioavailability,
                weight: weight,
                calibrationFactor: calibrationFactor
            )
            return exogenousConcentration + baselineConcentration
        }
        
        // Two-compartment model parameters
        // Using standard Bateman equation for PK with first-order absorption
        let scaledDose = dose * bioavailability
        
        // Calculate hybrid rate constants for two-compartment model
        // α and β are the hybrid first-order rate constants
        let sum = k12 + k21 + ke
        let product = k21 * ke
        
        // Check if discriminant will be positive to avoid numerical issues
        guard sum * sum &gt; 4 * product else {
            // If discriminant would be negative, use one-compartment model
            let oneCompResult = oneCompartmentBolus(
                time: time,
                dose: dose,
                ke: ke,
                bioavailability: bioavailability,
                weight: weight,
                calibrationFactor: calibrationFactor
            )
            return oneCompResult + baselineConcentration
        }
        
        let discriminant = sqrt(sum * sum - 4 * product)
        
        // Special case handling for eigenvalues
        let alpha: Double
        let beta: Double
        
        if abs(k12 + ke - k21) &lt; 0.001 {
            // Handle special case where eigenvalues are very close
            alpha = beta = (k12 + k21 + ke) / 2
            
            // Use one-compartment model for this special case
            let oneCompResult = oneCompartmentBolus(
                time: time,
                dose: dose,
                ke: ke,
                bioavailability: bioavailability,
                weight: weight,
                calibrationFactor: calibrationFactor
            )
            return oneCompResult + baselineConcentration
        } else {
            // Standard calculation
            alpha = 0.5 * (sum + discriminant)
            beta = 0.5 * (sum - discriminant)
        }
        
        // Prevent potential division by zero or very small denominators
        // This can happen when rate constants are very close to each other
        let epsilon = 0.001
        if abs(absorptionRateKa - alpha) &lt; epsilon || 
           abs(absorptionRateKa - beta) &lt; epsilon || 
           abs(alpha - beta) &lt; epsilon {
            // Fall back to one-compartment model if the rate constants are too close
            let oneCompResult = oneCompartmentBolus(
                time: time,
                dose: dose,
                ke: ke,
                bioavailability: bioavailability,
                weight: weight,
                calibrationFactor: calibrationFactor
            )
            return oneCompResult + baselineConcentration
        }
        
        // Calculate coefficients for the triexponential equation
        let A = (alpha - k21) * absorptionRateKa / (vd * (alpha - beta) * (absorptionRateKa - alpha))
        let B = (beta - k21) * absorptionRateKa / (vd * (beta - alpha) * (absorptionRateKa - beta))
        let C = k21 * absorptionRateKa / (vd * (absorptionRateKa - alpha) * (absorptionRateKa - beta))
        
        // Calculate concentration using the standard triexponential equation
        let exogenousConcentration = scaledDose * (
            A * (exp(-alpha * time)) +
            B * (exp(-beta * time)) +
            C * (exp(-absorptionRateKa * time))
        )
        
        // Check for numerical issues
        if exogenousConcentration.isNaN || exogenousConcentration.isInfinite {
            // Log warning and use one-compartment model
            print(&quot;Warning: Two-compartment model produced NaN/Infinite result. Parameters: ka=\(absorptionRateKa), ke=\(ke), k12=\(k12), k21=\(k21), Vd=\(vd)&quot;)
            let oneCompResult = oneCompartmentBolus(
                time: time,
                dose: dose,
                ke: ke,
                bioavailability: bioavailability,
                weight: weight,
                calibrationFactor: calibrationFactor
            )
            return oneCompResult + baselineConcentration
        }
        
        // Apply calibration factor to exogenous concentration only
        let calibratedExogenousConcentration = max(0, exogenousConcentration * calibrationFactor)
        
        // Near-zero check
        if calibratedExogenousConcentration &lt; PKModel.minimumReportableConcentration {
            print(&quot;Near-zero exogenous concentration calculated at time \(time): \(calibratedExogenousConcentration)&quot;)
        }
        
        // Add exogenous (from injection) and endogenous (baseline) concentrations
        return calibratedExogenousConcentration + baselineConcentration
    }
    
    /// Calculate baseline testosterone concentration from endogenous production
    /// - Parameter weight: Patient weight in kg
    /// - Returns: Baseline concentration
    private func calculateBaselineConcentration(weight: Double) -&gt; Double {
        // Calculate volume of distribution with allometric scaling
        let vd = PKModel.defaultVolumeOfDistribution70kg * pow(weight / 70.0, 1.0)
        
        // Calculate clearance with allometric scaling
        let clearance = PKModel.defaultClearance70kg * pow(weight / 70.0, 0.75)
        
        // For steady state, Concentration = Production Rate / Clearance
        let baseConcentration = PKModel.endogenousProductionRate / clearance
        
        // Convert to concentration units (ng/dL)
        // Assuming clearance is in L/day, we convert mg/L to ng/dL
        // 1 mg/L = 100 ng/dL
        return baseConcentration * 100
    }
    
    /// Calculate concentration for a bolus injection (immediate absorption)
    /// This is a fallback for when ka ≤ ke or as direct calculation when needed
    /// Returns only the exogenous contribution (does NOT include baseline)
    private func oneCompartmentBolus(
        time: Double,
        dose: Double,
        ke: Double,
        bioavailability: Double,
        weight: Double,
        calibrationFactor: Double
    ) -&gt; Double {
        // Calculate volume of distribution with allometric scaling
        let vd = PKModel.defaultVolumeOfDistribution70kg * pow(weight / 70.0, 1.0)
        
        // Simple one-compartment bolus model: C(t) = (F·D/Vd)·e^(-ke·t)
        let initialConcentration = (dose * bioavailability) / vd
        let result = initialConcentration * exp(-ke * time)
        
        // Apply log transformation for small values to avoid numerical issues
        if result &gt; 0 &amp;&amp; result &lt; PKModel.minimumReportableConcentration {
            // Log-transform the calculation to avoid underflow
            let logResult = log(initialConcentration) - ke * time
            let transformedResult = exp(logResult)
            return max(0, transformedResult * calibrationFactor)
        }
        
        return max(0, result * calibrationFactor) // Ensure non-negative result
    }
    
    /// Calculate the total concentration for a blend at a specific time
    /// - Parameters:
    ///   - time: Time in days since administration
    ///   - components: Array of tuples containing (compound, dose)
    ///   - route: Administration route
    ///   - weight: Patient weight in kg
    ///   - calibrationFactor: User-specific calibration factor
    /// - Returns: Total concentration
    func blendConcentration(
        at time: Double,
        components: [(compound: Compound, doseMg: Double)],
        route: Compound.Route,
        weight: Double = 70.0,
        calibrationFactor: Double = 1.0
    ) -&gt; Double {
        guard !components.isEmpty else {
            // If no components, return only baseline concentration
            return includeEndogenousProduction ? calculateBaselineConcentration(weight: weight) : 0
        }
        
        // For endogenous production, we should only add it once for the blend,
        // not for each component, to avoid double-counting
        let baselineConcentration = includeEndogenousProduction ? calculateBaselineConcentration(weight: weight) : 0
        
        // Create a copy of the current model with endogenous production turned off
        // to avoid adding baseline multiple times
        var tempModel = self
        tempModel.includeEndogenousProduction = false
        
        // Sum the exogenous concentrations of all components
        let totalExogenousConcentration = components.reduce(0.0) { totalConcentration, component in
            let bioavailability = component.compound.defaultBioavailability[route] ?? 1.0
            let absorptionRate = component.compound.defaultAbsorptionRateKa[route] ?? 0.7 // Default ka if not specified
            
            let componentConcentration = tempModel.concentration(
                at: time,
                dose: component.doseMg,
                halfLifeDays: component.compound.halfLifeDays,
                absorptionRateKa: absorptionRate,
                bioavailability: bioavailability,
                weight: weight,
                calibrationFactor: calibrationFactor
            )
            
            return totalConcentration + componentConcentration
        }
        
        // Add baseline concentration once for the entire blend
        return totalExogenousConcentration + baselineConcentration
    }
    
    /// Calculate the concentration over time for a protocol with multiple injections
    /// - Parameters:
    ///   - times: Array of time points in days to calculate concentrations for
    ///   - injectionDates: Dates of all injections
    ///   - compounds: Array of tuples containing (compound, dose per injection)
    ///   - route: Administration route
    ///   - weight: Patient weight in kg
    ///   - calibrationFactor: User-specific calibration factor
    /// - Returns: Array of concentrations at specified time points
    func protocolConcentrations(
        at times: [Date],
        injectionDates: [Date],
        compounds: [(compound: Compound, dosePerInjectionMg: Double)],
        route: Compound.Route,
        weight: Double = 70.0,
        calibrationFactor: Double = 1.0
    ) -&gt; [Double] {
        // Basic validation check
        if times.isEmpty {
            return []
        }
        
        if injectionDates.isEmpty || compounds.isEmpty {
            // Return baseline concentrations if no injections or compounds
            if includeEndogenousProduction {
                let baselineConcentration = calculateBaselineConcentration(weight: weight)
                return Array(repeating: baselineConcentration, count: times.count)
            } else {
                return Array(repeating: 0.0, count: times.count)
            }
        }
        
        // For endogenous production, we should only add baseline once per time point
        let baselineConcentration = includeEndogenousProduction ? calculateBaselineConcentration(weight: weight) : 0
        
        // Create a copy of the model with endogenous production turned off to avoid double-counting
        var tempModel = self
        tempModel.includeEndogenousProduction = false
        
        // Calculate concentration at each time point
        let results = times.map { timePoint in
            // Sum contributions from all injections (exogenous only)
            let totalExogenousConcentration = injectionDates.reduce(0.0) { totalConc, injectionDate in
                // Skip future injections
                guard injectionDate &lt;= timePoint else { return totalConc }
                
                // Calculate time difference in days
                let timeDiffDays = timePoint.timeIntervalSince(injectionDate) / (24 * 3600)
                
                // Skip negative time differences (should not happen, but just in case)
                guard timeDiffDays &gt;= 0 else { return totalConc }
                
                // Sum contributions from all compounds in this injection
                let injectionContribution = compounds.reduce(0.0) { compoundSum, compound in
                    let bioavailability = compound.compound.defaultBioavailability[route] ?? 1.0
                    let absorptionRate = compound.compound.defaultAbsorptionRateKa[route] ?? 0.7
                    
                    let contribution = tempModel.concentration(
                        at: timeDiffDays,
                        dose: compound.dosePerInjectionMg,
                        halfLifeDays: compound.compound.halfLifeDays,
                        absorptionRateKa: absorptionRate,
                        bioavailability: bioavailability,
                        weight: weight,
                        calibrationFactor: calibrationFactor
                    )
                    
                    return compoundSum + contribution
                }
                
                return totalConc + injectionContribution
            }
            
            // Add baseline concentration once per time point
            return totalExogenousConcentration + baselineConcentration
        }
        
        return results
    }
    
    // MARK: - Bayesian Calibration
    
    /// Struct to represent a blood sample with timestamp and lab value
    struct SamplePoint {
        let timestamp: Date
        let labValue: Double
    }
    
    /// Result of Bayesian calibration
    struct CalibrationResult {
        let adjustedKe: Double
        let adjustedKa: Double
        let originalKe: Double
        let originalKa: Double
        let halfLifeDays: Double
        let correlation: Double
        let samples: [SamplePoint]
        
        var halfLifeChangePercent: Double {
            let originalHalfLife = log(2) / originalKe
            let newHalfLife = log(2) / adjustedKe
            return ((newHalfLife / originalHalfLife) - 1.0) * 100.0
        }
    }
    
    /// Perform Bayesian calibration to refine ke and ka based on lab values
    /// - Parameters:
    ///   - samples: Dictionary of timestamps and lab values
    ///   - injectionDates: Dates of all injections
    ///   - compound: Compound being used
    ///   - dose: Dose in mg
    ///   - route: Administration route
    ///   - weight: Patient weight in kg
    /// - Returns: Calibration result with adjusted parameters
    func bayesianCalibration(
        samples: [SamplePoint],
        injectionDates: [Date],
        compound: Compound,
        dose: Double,
        route: Compound.Route,
        weight: Double = 70.0
    ) -&gt; CalibrationResult? {
        // Need at least 2 samples for meaningful calibration
        guard samples.count &gt;= 2, let defaultKa = compound.defaultAbsorptionRateKa[route] else {
            return nil
        }
        
        // Original parameters
        let originalKe = log(2) / compound.halfLifeDays
        let originalKa = defaultKa
        
        // Bioavailability for this route
        let bioavailability = compound.defaultBioavailability[route] ?? 1.0
        
        // Set up parameter bounds (ke and ka can&apos;t vary too much from literature values)
        let keMin = originalKe * 0.5  // Allow halving the elimination rate
        let keMax = originalKe * 2.0  // Allow doubling the elimination rate
        let kaMin = originalKa * 0.5  // Allow halving the absorption rate
        let kaMax = originalKa * 2.0  // Allow doubling the absorption rate
        
        // Initial parameter guesses
        var currentKe = originalKe
        var currentKa = originalKa
        var bestKe = originalKe
        var bestKa = originalKa
        var bestError = Double.greatestFiniteMagnitude
        
        // Function to calculate sum of squared errors for given parameters
        func calculateError(ke: Double, ka: Double) -&gt; Double {
            var sumSquaredError = 0.0
            
            for sample in samples {
                // Calculate predicted concentration at this sample time
                var predictedLevel = 0.0
                
                for injectionDate in injectionDates {
                    // Skip future injections
                    guard injectionDate &lt;= sample.timestamp else { continue }
                    
                    // Calculate time difference in days
                    let timeDiffDays = sample.timestamp.timeIntervalSince(injectionDate) / (24 * 3600)
                    guard timeDiffDays &gt;= 0 else { continue }
                    
                    // Calculate concentration for this injection
                    let vd = PKModel.defaultVolumeOfDistribution70kg * pow(weight / 70.0, 1.0)
                    
                    // Skip if ka and ke are too close (would cause division by zero)
                    if abs(ka - ke) &lt; 0.001 {
                        continue
                    }
                    
                    // One-compartment model with first-order absorption formula
                    let factor = (dose * bioavailability * ka) / (vd * (ka - ke))
                    let contribution = factor * (exp(-ke * timeDiffDays) - exp(-ka * timeDiffDays))
                    
                    predictedLevel += contribution
                }
                
                // Calculate squared error for this sample
                let error = sample.labValue - predictedLevel
                sumSquaredError += error * error
            }
            
            return sumSquaredError
        }
        
        // Gradient descent parameters
        let learningRate = 0.01
        let iterations = 100
        let earlyStopThreshold = 0.0001
        
        // Perform gradient descent optimization
        for _ in 0..&lt;iterations {
            let baseError = calculateError(ke: currentKe, ka: currentKa)
            
            // Calculate gradient for ke
            let keStep = currentKe * 0.01
            let keGradient = (calculateError(ke: currentKe + keStep, ka: currentKa) - baseError) / keStep
            
            // Calculate gradient for ka
            let kaStep = currentKa * 0.01
            let kaGradient = (calculateError(ke: currentKe, ka: currentKa + kaStep) - baseError) / kaStep
            
            // Update parameters
            currentKe -= learningRate * keGradient
            currentKa -= learningRate * kaGradient
            
            // Keep parameters within bounds
            currentKe = max(keMin, min(keMax, currentKe))
            currentKa = max(kaMin, min(kaMax, currentKa))
            
            // Check if this is the best result so far
            let currentError = calculateError(ke: currentKe, ka: currentKa)
            if currentError &lt; bestError {
                bestError = currentError
                bestKe = currentKe
                bestKa = currentKa
            }
            
            // Early stopping if improvement is minimal
            if abs(baseError - currentError) &lt; earlyStopThreshold {
                break
            }
        }
        
        // Calculate correlation coefficient
        let correlation = calculateCorrelation(
            ke: bestKe,
            ka: bestKa,
            samples: samples,
            injectionDates: injectionDates,
            dose: dose,
            bioavailability: bioavailability,
            weight: weight
        )
        
        return CalibrationResult(
            adjustedKe: bestKe,
            adjustedKa: bestKa,
            originalKe: originalKe,
            originalKa: originalKa,
            halfLifeDays: log(2) / bestKe,
            correlation: correlation,
            samples: samples
        )
    }
    
    /// Calculate correlation between observed and predicted values
    private func calculateCorrelation(
        ke: Double,
        ka: Double,
        samples: [SamplePoint],
        injectionDates: [Date],
        dose: Double,
        bioavailability: Double,
        weight: Double
    ) -&gt; Double {
        // Calculate predicted values
        var observed: [Double] = []
        var predicted: [Double] = []
        
        for sample in samples {
            observed.append(sample.labValue)
            
            var predictedLevel = 0.0
            for injectionDate in injectionDates {
                guard injectionDate &lt;= sample.timestamp else { continue }
                
                let timeDiffDays = sample.timestamp.timeIntervalSince(injectionDate) / (24 * 3600)
                guard timeDiffDays &gt;= 0 else { continue }
                
                let vd = PKModel.defaultVolumeOfDistribution70kg * pow(weight / 70.0, 1.0)
                
                if abs(ka - ke) &lt; 0.001 {
                    // For very close ka and ke, use bolus approximation
                    let initialConcentration = (dose * bioavailability) / vd
                    predictedLevel += initialConcentration * exp(-ke * timeDiffDays)
                } else {
                    let factor = (dose * bioavailability * ka) / (vd * (ka - ke))
                    predictedLevel += factor * (exp(-ke * timeDiffDays) - exp(-ka * timeDiffDays))
                }
            }
            
            predicted.append(predictedLevel)
        }
        
        // Calculate means
        let observedMean = observed.reduce(0.0, +) / Double(observed.count)
        let predictedMean = predicted.reduce(0.0, +) / Double(predicted.count)
        
        // Calculate Pearson correlation coefficient
        var numerator = 0.0
        var observedDenominator = 0.0
        var predictedDenominator = 0.0
        
        for i in 0..&lt;observed.count {
            let observedDiff = observed[i] - observedMean
            let predictedDiff = predicted[i] - predictedMean
            
            numerator += observedDiff * predictedDiff
            observedDenominator += observedDiff * observedDiff
            predictedDenominator += predictedDiff * predictedDiff
        }
        
        let denominator = sqrt(observedDenominator * predictedDenominator)
        
        // Protect against division by zero
        guard denominator &gt; 0 else { return 0.0 }
        
        return numerator / denominator
    }
    
    // MARK: - Time to Peak and Maximum Concentration
    
    /// Calculate the time to peak concentration for a given dose
    /// - Parameters:
    ///   - dose: Dose in mg
    ///   - halfLifeDays: Half-life in days
    ///   - absorptionRateKa: Absorption rate constant (ka) in d⁻¹
    ///   - bioavailability: Fraction of drug absorbed (0-1)
    ///   - weight: Patient weight in kg (for allometric scaling)
    ///   - calibrationFactor: User-specific calibration factor
    /// - Returns: Time to peak concentration in days
    func calculateTimeToMaxConcentration(
        dose: Double,
        halfLifeDays: Double,
        absorptionRateKa: Double,
        bioavailability: Double = 1.0,
        weight: Double = 70.0,
        calibrationFactor: Double = 1.0
    ) -&gt; Double {
        // Skip calculation if impossible parameters
        guard halfLifeDays &gt; 0 &amp;&amp; absorptionRateKa &gt; 0 else { return 0 }
        
        // Elimination rate constant (ke) = ln(2)/t_1/2
        let ke = log(2) / halfLifeDays
        
        // For one-compartment model with first-order absorption,
        // Tp = ln(ka/ke) / (ka - ke)
        // This is derived by setting the derivative of the concentration equation to zero
        guard absorptionRateKa &gt; ke else {
            // If ka &lt;= ke, then Tp is effectively 0 (immediate peak for IV bolus)
            return 0
        }
        
        // For two-compartment model, need numerical approach to find Tp
        // This is a simplified approximation - would use a more sophisticated
        // numerical method in a full implementation
        
        // Calculate alpha and beta for two-compartment model
        let beta = 0.5 * ((k12 + k21 + ke) - sqrt(pow(k12 + k21 + ke, 2) - 4 * k21 * ke))
        let _ = (k21 * ke) / beta
        
        // Approximate Tp using numerical search (rough estimate)
        var bestTime = 0.0
        var maxConc = 0.0
        
        // Search from 0 to about 5 half-lives with small steps
        let searchEnd = 5 * halfLifeDays
        let step = halfLifeDays / 50.0
        
        for t in stride(from: 0, through: searchEnd, by: step) {
            let conc = concentration(
                at: t,
                dose: dose,
                halfLifeDays: halfLifeDays,
                absorptionRateKa: absorptionRateKa,
                bioavailability: bioavailability,
                weight: weight,
                calibrationFactor: calibrationFactor
            )
            
            if conc &gt; maxConc {
                maxConc = conc
                bestTime = t
            }
        }
        
        return bestTime
    }
    
    /// Calculate the maximum concentration for a given dose
    /// - Parameters:
    ///   - dose: Dose in mg
    ///   - halfLifeDays: Half-life in days
    ///   - absorptionRateKa: Absorption rate constant (ka) in d⁻¹
    ///   - bioavailability: Fraction of drug absorbed (0-1)
    ///   - weight: Patient weight in kg (for allometric scaling)
    ///   - calibrationFactor: User-specific calibration factor
    /// - Returns: Maximum concentration
    func calculateMaxConcentration(
        dose: Double,
        halfLifeDays: Double,
        absorptionRateKa: Double,
        bioavailability: Double = 1.0,
        weight: Double = 70.0,
        calibrationFactor: Double = 1.0
    ) -&gt; Double {
        // Calculate time to peak
        let tp = calculateTimeToMaxConcentration(
            dose: dose,
            halfLifeDays: halfLifeDays,
            absorptionRateKa: absorptionRateKa,
            bioavailability: bioavailability,
            weight: weight,
            calibrationFactor: calibrationFactor
        )
        
        // Calculate concentration at time to peak
        return concentration(
            at: tp,
            dose: dose,
            halfLifeDays: halfLifeDays,
            absorptionRateKa: absorptionRateKa,
            bioavailability: bioavailability,
            weight: weight,
            calibrationFactor: calibrationFactor
        )
    }
    
    /// Calculate the time to peak and maximum concentration for a blend
    /// - Parameters:
    ///   - components: Array of tuples containing (compound, dose)
    ///   - route: Administration route
    ///   - weight: Patient weight in kg
    ///   - calibrationFactor: User-specific calibration factor
    /// - Returns: Tuple containing (time to peak in days, max concentration)
    func calculateBlendPeakDetails(
        components: [(compound: Compound, doseMg: Double)],
        route: Compound.Route,
        weight: Double = 70.0,
        calibrationFactor: Double = 1.0
    ) -&gt; (timeToMaxDays: Double, maxConcentration: Double) {
        // For blends, we need to do a numerical search to find overall Tp and Cmax
        // as different components will peak at different times
        
        // Search time range (0 to 30 days should cover most scenarios)
        let searchEnd = 30.0
        let step = 0.1 // Refine step size for better precision
        
        var maxConc = 0.0
        var maxTime = 0.0
        
        for t in stride(from: 0, through: searchEnd, by: step) {
            let conc = blendConcentration(
                at: t,
                components: components,
                route: route,
                weight: weight,
                calibrationFactor: calibrationFactor
            )
            
            if conc &gt; maxConc {
                maxConc = conc
                maxTime = t
            }
        }
        
        return (timeToMaxDays: maxTime, maxConcentration: maxConc)
    }
    
    /// Calculate peak details for a protocol (multiple injections)
    /// - Parameters:
    ///   - injectionDates: Dates of all injections
    ///   - compounds: Array of tuples containing (compound, dose per injection)
    ///   - route: Administration route
    ///   - timeWindow: Date range to search for peak
    ///   - weight: Patient weight in kg
    ///   - calibrationFactor: User-specific calibration factor
    /// - Returns: Tuple containing (peak date, max concentration)
    func calculateProtocolPeakDetails(
        injectionDates: [Date],
        compounds: [(compound: Compound, dosePerInjectionMg: Double)],
        route: Compound.Route,
        timeWindow: (start: Date, end: Date),
        weight: Double = 70.0,
        calibrationFactor: Double = 1.0
    ) -&gt; (peakDate: Date, maxConcentration: Double) {
        // For multiple injections, we need to search the entire time window
        let totalHours = timeWindow.end.timeIntervalSince(timeWindow.start) / 3600
        let step = 6.0 // 6-hour steps for reasonable precision
        
        var maxConc = 0.0
        var maxDate = timeWindow.start
        
        // Generate timepoints to evaluate
        var timePoints: [Date] = []
        for hour in stride(from: 0, through: totalHours, by: step) {
            let date = timeWindow.start.addingTimeInterval(hour * 3600)
            timePoints.append(date)
        }
        
        // Calculate concentrations at each timepoint
        let concentrations = protocolConcentrations(
            at: timePoints,
            injectionDates: injectionDates,
            compounds: compounds,
            route: route,
            weight: weight,
            calibrationFactor: calibrationFactor
        )
        
        // Find the maximum
        for (index, conc) in concentrations.enumerated() {
            if conc &gt; maxConc {
                maxConc = conc
                maxDate = timePoints[index]
            }
        }
        
        return (peakDate: maxDate, maxConcentration: maxConc)
    }
}</file><file path="TestoSim/ViewModels/OpenAIService.swift">import Foundation
import SwiftUI

/// Service for handling OpenAI API requests
class OpenAIService: ObservableObject {
    // MARK: - Properties
    
    /// Singleton instance
    static let shared = OpenAIService()
    
    /// OpenAI API endpoint
    private let apiEndpoint = &quot;https://api.openai.com/v1/chat/completions&quot;
    
    /// Test project API key with $20 spending limit (for test users)
    private var testApiKey: String {
        // Read the API key from Config.plist
        if let path = Bundle.main.path(forResource: &quot;Config&quot;, ofType: &quot;plist&quot;),
           let dict = NSDictionary(contentsOfFile: path),
           let key = dict[&quot;OPENAI_API_KEY&quot;] as? String {
            if key == &quot;PLACEHOLDER_API_KEY&quot; {
                // This is the placeholder value, log an error
                print(&quot;WARNING: Using placeholder API key. Please update Config.plist with a valid API key.&quot;)
                return &quot;&quot;
            }
            return key
        }
        // Fallback if key not found
        print(&quot;ERROR: API key not found in Config.plist.&quot;)
        return &quot;&quot;
    }
    
    /// Flag to determine if using test API key
    @Published private(set) var isUsingTestKey = false
    
    /// OpenAI API key
    private var apiKey: String {
        // If user has toggled to use the test key, return it
        if isUsingTestKey {
            return testApiKey
        }
        
        // Otherwise, get API key from UserDefaults or environment
        let userKey = UserDefaults.standard.string(forKey: &quot;openai_api_key&quot;) ?? 
                      ProcessInfo.processInfo.environment[&quot;OPENAI_API_KEY&quot;] ?? &quot;&quot;
        
        // If no user key is available, fall back to the test key
        return userKey.isEmpty ? testApiKey : userKey
    }
    
    /// The model to use for generating insights
    private let model = &quot;gpt-4o-mini&quot; // Using the more cost-effective GPT-4o-mini model
    
    // MARK: - Initialization
    
    /// Private initializer to enforce singleton pattern
    private init() {
        // Check if test key should be used by default
        self.isUsingTestKey = UserDefaults.standard.bool(forKey: &quot;use_test_api_key&quot;)
    }
    
    // MARK: - API Methods
    
    /// Save the API key to UserDefaults
    /// - Parameter key: The API key
    func saveAPIKey(_ key: String) {
        UserDefaults.standard.set(key, forKey: &quot;openai_api_key&quot;)
        isUsingTestKey = false
        UserDefaults.standard.set(false, forKey: &quot;use_test_api_key&quot;)
    }
    
    /// Check if an API key is available
    /// - Returns: True if an API key is available, false otherwise
    func hasAPIKey() -&gt; Bool {
        return !apiKey.isEmpty
    }
    
    /// Clear the saved API key
    func clearAPIKey() {
        UserDefaults.standard.removeObject(forKey: &quot;openai_api_key&quot;)
    }
    
    /// Toggle between using the test API key and the user&apos;s API key
    /// - Parameter useTestKey: Whether to use the test API key
    func toggleTestApiKey(_ useTestKey: Bool) {
        isUsingTestKey = useTestKey
        UserDefaults.standard.set(useTestKey, forKey: &quot;use_test_api_key&quot;)
    }
    
    /// Generate protocol insights using the OpenAI API
    /// - Parameters:
    ///   - protocol: The protocol to analyze
    ///   - profile: User profile information
    ///   - simulationData: Pharmacokinetic simulation data
    ///   - completion: Callback with the result
    func generateProtocolInsights(
        treatmentProtocol: InjectionProtocol,
        profile: UserProfile,
        simulationData: [DataPoint],
        compoundLibrary: CompoundLibrary,
        completion: @escaping (Result&lt;Insights, Error&gt;) -&gt; Void
    ) {
        // Build the chat message content
        let content = buildProtocolPrompt(
            treatmentProtocol: treatmentProtocol,
            profile: profile,
            simulationData: simulationData,
            compoundLibrary: compoundLibrary
        )
        
        // Create the request
        makeCompletionRequest(content: content) { result in
            switch result {
            case .success(let jsonResponse):
                do {
                    // Parse the insights from the response
                    let insights = try self.parseInsightsFromResponse(jsonResponse, forProtocol: treatmentProtocol)
                    completion(.success(insights))
                } catch {
                    completion(.failure(error))
                }
            case .failure(let error):
                completion(.failure(error))
            }
        }
    }
    
    /// Generate cycle insights using the OpenAI API
    /// - Parameters:
    ///   - cycle: The cycle to analyze
    ///   - profile: User profile information
    ///   - simulationData: Pharmacokinetic simulation data
    ///   - completion: Callback with the result
    func generateCycleInsights(
        cycle: Cycle,
        profile: UserProfile,
        simulationData: [DataPoint],
        compoundLibrary: CompoundLibrary,
        completion: @escaping (Result&lt;Insights, Error&gt;) -&gt; Void
    ) {
        // Build the chat message content
        let content = buildCyclePrompt(
            cycle: cycle,
            profile: profile,
            simulationData: simulationData,
            compoundLibrary: compoundLibrary
        )
        
        // Create the request
        makeCompletionRequest(content: content) { result in
            switch result {
            case .success(let jsonResponse):
                do {
                    // Parse the insights from the response
                    let insights = try self.parseInsightsFromResponse(jsonResponse, forCycle: cycle)
                    completion(.success(insights))
                } catch {
                    completion(.failure(error))
                }
            case .failure(let error):
                completion(.failure(error))
            }
        }
    }
    
    // MARK: - Private Methods
    
    /// Build the prompt for protocol insights
    private func buildProtocolPrompt(
        treatmentProtocol: InjectionProtocol,
        profile: UserProfile,
        simulationData: [DataPoint],
        compoundLibrary: CompoundLibrary
    ) -&gt; String {
        // Extract protocol details
        let protocolType = treatmentProtocol.protocolType
        let protocolName = treatmentProtocol.name
        var compoundOrBlendName = &quot;Unknown&quot;
        var compoundInfo = &quot;&quot;
        
        // Get compound or blend information
        if protocolType == .compound, let compoundID = treatmentProtocol.compoundID,
           let compound = compoundLibrary.compounds.first(where: { $0.id == compoundID }) {
            compoundOrBlendName = compound.commonName
            if let ester = compound.ester {
                compoundOrBlendName += &quot; \(ester)&quot;
            }
            compoundInfo = &quot;&quot;&quot;
            Compound: \(compound.commonName)
            Ester: \(compound.ester ?? &quot;None&quot;)
            Half-life: \(compound.halfLifeDays) days
            &quot;&quot;&quot;
        } else if protocolType == .blend, let blendID = treatmentProtocol.blendID,
                  let blend = compoundLibrary.blends.first(where: { $0.id == blendID }) {
            compoundOrBlendName = blend.name
            compoundInfo = &quot;&quot;&quot;
            Blend: \(blend.name)
            Manufacturer: \(blend.manufacturer ?? &quot;Unknown&quot;)
            Components:
            &quot;&quot;&quot;
            
            // Add blend components
            let components = blend.resolvedComponents(using: compoundLibrary)
            for component in components {
                compoundInfo += &quot;&quot;&quot;
                
                - \(component.compound.commonName) \(component.compound.ester ?? &quot;&quot;)
                  Concentration: \(component.mgPerML) mg/mL
                  Half-life: \(component.compound.halfLifeDays) days
                &quot;&quot;&quot;
            }
        }
        
        // Extract simulation statistics
        let maxLevel = simulationData.map { $0.level }.max() ?? 0
        let minLevel = simulationData.map { $0.level }.min() ?? 0
        let avgLevel = simulationData.map { $0.level }.reduce(0, +) / Double(max(1, simulationData.count))
        let fluctuation = maxLevel &gt; 0 ? (maxLevel - minLevel) / maxLevel * 100 : 0
        
        // Build the prompt
        return &quot;&quot;&quot;
        You are a specialized AI assistant for TestoSim, a hormone therapy simulation app. 
        Analyze the following protocol and simulation data, and provide insights in the specified JSON format.
        
        USER PROFILE:
        Weight: \(profile.weight ?? 0) kg
        Height: \(profile.heightCm ?? 0) cm
        Age: \(profile.age ?? 0)
        Biological sex: \(profile.biologicalSex.rawValue)
        
        PROTOCOL DETAILS:
        Name: \(protocolName)
        Type: \(protocolType.rawValue)
        \(compoundInfo)
        Dose: \(treatmentProtocol.doseMg) mg
        Frequency: Every \(treatmentProtocol.frequencyDays) days
        Route: \(treatmentProtocol.selectedRoute ?? &quot;intramuscular&quot;)
        
        SIMULATION STATISTICS:
        Average Level: \(avgLevel) ng/dL
        Maximum Level: \(maxLevel) ng/dL
        Minimum Level: \(minLevel) ng/dL
        Fluctuation: \(fluctuation)%
        
        BLOOD SAMPLES:
        \(treatmentProtocol.bloodSamples.map { &quot;Date: \($0.date), Value: \($0.value) \($0.unit)&quot; }.joined(separator: &quot;\n&quot;))
        
        Based on this information, provide insights about the protocol in the following JSON format:
        
        {
            &quot;title&quot;: &quot;Insights for [Protocol Name]&quot;,
            &quot;summary&quot;: &quot;A concise summary of the protocol analysis.&quot;,
            &quot;blendExplanation&quot;: &quot;Detailed explanation of what&apos;s in the blend and how it behaves over time (only for blend protocols, null otherwise).&quot;,
            &quot;keyPoints&quot;: [
                {
                    &quot;title&quot;: &quot;Short, specific point title&quot;,
                    &quot;description&quot;: &quot;Detailed explanation of the point&quot;,
                    &quot;type&quot;: &quot;information|positive|warning|suggestion&quot;
                }
            ]
        }
        
        Focus on practical insights about:
        1. Dosing frequency and stability
        2. Level fluctuations and their implications
        3. Potential optimizations to the protocol
        4. Educational content about the compounds or blend
        &quot;&quot;&quot;
    }
    
    /// Build the prompt for cycle insights
    private func buildCyclePrompt(
        cycle: Cycle,
        profile: UserProfile,
        simulationData: [DataPoint],
        compoundLibrary: CompoundLibrary
    ) -&gt; String {
        // Extract cycle details
        let cycleName = cycle.name
        let cycleStages = cycle.stages
        
        // Build stages information
        var stagesInfo = &quot;&quot;
        for (index, stage) in cycleStages.enumerated() {
            stagesInfo += &quot;&quot;&quot;
            
            Stage \(index + 1):
            Name: \(stage.name)
            Duration: \(stage.durationWeeks) weeks
            Start Week: \(stage.startWeek)
            &quot;&quot;&quot;
            
            // Add compounds in stage
            if !stage.compounds.isEmpty {
                stagesInfo += &quot;\nCompounds:&quot;
                for compound in stage.compounds {
                    stagesInfo += &quot;&quot;&quot;
                    
                      - \(compound.compoundName)
                          Dose: \(compound.doseMg) mg
                          Frequency: Every \(compound.frequencyDays) days
                          Route: \(compound.administrationRoute)
                    &quot;&quot;&quot;
                }
            }
            
            // Add blends in stage
            if !stage.blends.isEmpty {
                stagesInfo += &quot;\nBlends:&quot;
                for blend in stage.blends {
                    stagesInfo += &quot;&quot;&quot;
                    
                      - \(blend.blendName)
                          Dose: \(blend.doseMg) mg
                          Frequency: Every \(blend.frequencyDays) days
                          Route: \(blend.administrationRoute)
                    &quot;&quot;&quot;
                }
            }
        }
        
        // Extract simulation statistics
        let maxLevel = simulationData.map { $0.level }.max() ?? 0
        let minLevel = simulationData.map { $0.level }.min() ?? 0
        let avgLevel = simulationData.map { $0.level }.reduce(0, +) / Double(max(1, simulationData.count))
        let fluctuation = maxLevel &gt; 0 ? (maxLevel - minLevel) / maxLevel * 100 : 0
        
        // Build the prompt
        return &quot;&quot;&quot;
        You are a specialized AI assistant for TestoSim, a hormone therapy simulation app. 
        Analyze the following cycle and simulation data, and provide insights in the specified JSON format.
        
        USER PROFILE:
        Weight: \(profile.weight ?? 0) kg
        Height: \(profile.heightCm ?? 0) cm
        Age: \(profile.age ?? 0)
        Biological sex: \(profile.biologicalSex.rawValue)
        
        CYCLE DETAILS:
        Name: \(cycleName)
        Total Duration: \(cycle.totalWeeks) weeks
        \(stagesInfo)
        
        SIMULATION STATISTICS:
        Average Level: \(avgLevel) ng/dL
        Maximum Level: \(maxLevel) ng/dL
        Minimum Level: \(minLevel) ng/dL
        Fluctuation: \(fluctuation)%
        
        Based on this information, provide insights about the cycle in the following JSON format:
        
        {
            &quot;title&quot;: &quot;Insights for [Cycle Name]&quot;,
            &quot;summary&quot;: &quot;A concise summary of the cycle analysis.&quot;,
            &quot;stageBreakdown&quot;: [
                {
                    &quot;stageNumber&quot;: 1,
                    &quot;analysis&quot;: &quot;Analysis of what&apos;s happening in this stage and why&quot;
                }
            ],
            &quot;keyPoints&quot;: [
                {
                    &quot;title&quot;: &quot;Short, specific point title&quot;,
                    &quot;description&quot;: &quot;Detailed explanation of the point&quot;,
                    &quot;type&quot;: &quot;information|positive|warning|suggestion&quot;
                }
            ]
        }
        
        Focus on practical insights about:
        1. Stage progression and rationale
        2. Compound selection and synergies
        3. Level fluctuations and their implications
        4. Potential optimizations to the cycle
        5. Educational content about the compounds and how they work together
        &quot;&quot;&quot;
    }
    
    /// Make a completion request to the OpenAI API
    private func makeCompletionRequest(content: String, completion: @escaping (Result&lt;String, Error&gt;) -&gt; Void) {
        // Create URL
        guard let url = URL(string: apiEndpoint) else {
            completion(.failure(NSError(domain: &quot;OpenAIService&quot;, code: 0, userInfo: [NSLocalizedDescriptionKey: &quot;Invalid URL&quot;])))
            return
        }
        
        // Create request
        var request = URLRequest(url: url)
        request.httpMethod = &quot;POST&quot;
        request.addValue(&quot;Bearer \(apiKey)&quot;, forHTTPHeaderField: &quot;Authorization&quot;)
        request.addValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
        
        // Create request body
        let requestBody: [String: Any] = [
            &quot;model&quot;: model,
            &quot;messages&quot;: [
                [&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are a specialized AI assistant for a hormone therapy simulation app. Provide insights in JSON format only.&quot;],
                [&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: content]
            ],
            &quot;temperature&quot;: 0.3,
            &quot;max_tokens&quot;: 2000,
            &quot;response_format&quot;: [&quot;type&quot;: &quot;json_object&quot;]
        ]
        
        // Convert request body to JSON
        guard let jsonData = try? JSONSerialization.data(withJSONObject: requestBody) else {
            completion(.failure(NSError(domain: &quot;OpenAIService&quot;, code: 0, userInfo: [NSLocalizedDescriptionKey: &quot;Failed to serialize request body&quot;])))
            return
        }
        
        request.httpBody = jsonData
        
        // Make the request
        let task = URLSession.shared.dataTask(with: request) { (data, response, error) in
            // Handle error
            if let error = error {
                completion(.failure(error))
                return
            }
            
            // Handle no data
            guard let data = data else {
                completion(.failure(NSError(domain: &quot;OpenAIService&quot;, code: 0, userInfo: [NSLocalizedDescriptionKey: &quot;No data received&quot;])))
                return
            }
            
            // Parse response
            do {
                if let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                   let choices = json[&quot;choices&quot;] as? [[String: Any]],
                   let firstChoice = choices.first,
                   let message = firstChoice[&quot;message&quot;] as? [String: Any],
                   let content = message[&quot;content&quot;] as? String {
                    completion(.success(content))
                } else {
                    // Try to extract error message if available
                    if let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                       let error = json[&quot;error&quot;] as? [String: Any],
                       let message = error[&quot;message&quot;] as? String {
                        completion(.failure(NSError(domain: &quot;OpenAIService&quot;, code: 0, userInfo: [NSLocalizedDescriptionKey: message])))
                    } else {
                        completion(.failure(NSError(domain: &quot;OpenAIService&quot;, code: 0, userInfo: [NSLocalizedDescriptionKey: &quot;Failed to parse response&quot;])))
                    }
                }
            } catch {
                completion(.failure(error))
            }
        }
        
        task.resume()
    }
    
    /// API response structure for insights
    private struct APIInsightsResponse: Decodable {
        let title: String
        let summary: String
        let blendExplanation: String?
        let stageBreakdown: [APIStageBreakdown]?
        let keyPoints: [APIKeyPoint]
        
        struct APIKeyPoint: Decodable {
            let title: String
            let description: String
            let type: String
        }
        
        struct APIStageBreakdown: Decodable {
            let stageNumber: Int
            let analysis: String
        }
    }
    
    /// Stage analysis information
    private struct StageAnalysis {
        let stageNumber: Int
        let analysis: String
    }
    
    /// Parse insights from the OpenAI API response
    private func parseInsightsFromResponse(_ jsonString: String, forProtocol protocol: InjectionProtocol? = nil, forCycle cycle: Cycle? = nil) throws -&gt; Insights {
        let decoder = JSONDecoder()
        
        // Extract the JSON structure from the response
        guard let jsonData = jsonString.data(using: .utf8) else {
            throw NSError(domain: &quot;OpenAIService&quot;, code: 0, userInfo: [NSLocalizedDescriptionKey: &quot;Failed to convert response to data&quot;])
        }
        
        // Try to decode as APIInsightsResponse
        do {
            let response = try decoder.decode(APIInsightsResponse.self, from: jsonData)
            
            // Convert API response to Insights model
            var keyPoints: [KeyPoint] = []
            for point in response.keyPoints {
                let type: KeyPoint.KeyPointType
                switch point.type {
                case &quot;information&quot;: type = .information
                case &quot;positive&quot;: type = .positive
                case &quot;warning&quot;: type = .warning
                case &quot;suggestion&quot;: type = .suggestion
                default: type = .information
                }
                
                keyPoints.append(KeyPoint(title: point.title, description: point.description, type: type))
            }
            
            // Create the Insights object
            return Insights(
                title: response.title,
                summary: response.summary,
                blendExplanation: response.blendExplanation,
                keyPoints: keyPoints
            )
        } catch {
            print(&quot;Error parsing insights: \(error)&quot;)
            throw error
        }
    }
    
    // MARK: - Error Types
    
    /// API errors
    enum APIError: Error, LocalizedError {
        case missingAPIKey
        case invalidURL
        case invalidResponse
        case serverError(statusCode: Int)
        case noData
        case invalidResponseFormat
        case missingField(String)
        
        var errorDescription: String? {
            switch self {
            case .missingAPIKey:
                return &quot;OpenAI API key is missing&quot;
            case .invalidURL:
                return &quot;Invalid URL&quot;
            case .invalidResponse:
                return &quot;Invalid response from server&quot;
            case .serverError(let statusCode):
                return &quot;Server error with status code: \(statusCode)&quot;
            case .noData:
                return &quot;No data received from server&quot;
            case .invalidResponseFormat:
                return &quot;Invalid response format&quot;
            case .missingField(let field):
                return &quot;Missing field in response: \(field)&quot;
            }
        }
    }
}</file><file path="TestoSim/Views/ProtocolDetailView.swift">import SwiftUI

struct ProtocolDetailView: View {
    @EnvironmentObject var dataStore: AppDataStore
    @State private var showingAddBloodSheet = false
    @State private var showingCalibrateConfirm = false
    @State private var showingNotificationOptions = false
    @State private var showingEnableNotificationsAlert = false
    
    let injectionProtocol: InjectionProtocol
    
    // Try to get the compound for any protocol type
    var resolvedCompound: Compound? {
        // If protocol has a direct compound reference, use that
        if let compoundID = injectionProtocol.compoundID {
            return dataStore.compoundLibrary.compound(withID: compoundID)
        }
        return nil
    }
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 16) {
                // Protocol summary
                protocolSummaryView
                
                // Display the latest bloodwork info if available
                if let latestSample = injectionProtocol.bloodSamples.max(by: { $0.date &lt; $1.date }) {
                    latestBloodworkView(sample: latestSample)
                }
                
                // Chart
                TestosteroneChart(treatmentProtocol: injectionProtocol)
                    .frame(height: 300)
                
                // Next injection information
                nextInjectionView
                
                // Action buttons section
                actionButtonsView
            }
            .padding()
        }
        .navigationTitle(injectionProtocol.name)
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .primaryAction) {
                Button(&quot;Edit&quot;) {
                    dataStore.protocolToEdit = injectionProtocol
                    dataStore.isPresentingProtocolForm = true
                }
            }
        }
        .sheet(isPresented: $showingAddBloodSheet) {
            AddBloodworkView(injectionProtocol: injectionProtocol)
                .environmentObject(dataStore)
        }
        .alert(&quot;Calibration Updated&quot;, isPresented: $showingCalibrateConfirm) {
            Button(&quot;OK&quot;, role: .cancel) { }
        }
        .alert(&quot;Enable Notifications&quot;, isPresented: $showingEnableNotificationsAlert) {
            Button(&quot;Settings&quot;, role: .none) {
                showingNotificationOptions = true
            }
            Button(&quot;Cancel&quot;, role: .cancel) { }
        } message: {
            Text(&quot;Notifications are currently disabled. Would you like to enable them in settings?&quot;)
        }
        .sheet(isPresented: $showingNotificationOptions) {
            NotificationSettingsView()
                .environmentObject(dataStore)
        }
        .onAppear {
            dataStore.selectProtocol(id: injectionProtocol.id)
            dataStore.recalcSimulation()
            // Check if the protocol needs a compound fix
            fixProtocolCompound()
        }
    }
    
    // MARK: - Next Injection View
    
    var nextInjectionView: some View {
        let nextInjection = nextInjectionDate()
        
        return VStack(alignment: .leading, spacing: 8) {
            Text(&quot;Next Injection&quot;)
                .font(.headline)
            
            HStack {
                if let nextDate = nextInjection {
                    VStack(alignment: .leading) {
                        Text(nextDate, style: .date)
                            .font(.title3)
                            .foregroundColor(.primary)
                        
                        Text(daysUntilNextInjection(nextDate))
                            .foregroundColor(.secondary)
                    }
                    
                    Spacer()
                    
                    Button(action: {
                        if NotificationManager.shared.notificationsEnabled {
                            NotificationManager.shared.scheduleNotifications(
                                for: injectionProtocol,
                                using: dataStore.compoundLibrary
                            )
                        } else {
                            showingEnableNotificationsAlert = true
                        }
                    }) {
                        Label(&quot;Remind Me&quot;, systemImage: &quot;bell&quot;)
                    }
                    .buttonStyle(.borderedProminent)
                } else {
                    Text(&quot;No upcoming injections scheduled&quot;)
                        .foregroundColor(.secondary)
                        .italic()
                }
            }
        }
        .padding()
        .background(Color(.systemGray6))
        .cornerRadius(10)
    }
    
    // MARK: - Action Buttons View
    
    var actionButtonsView: some View {
        HStack {
            Button(action: {
                showingAddBloodSheet = true
            }) {
                Label(&quot;Add Bloodwork&quot;, systemImage: &quot;drop.fill&quot;)
            }
            .buttonStyle(.bordered)
            
            Spacer()
            
            // Record injection button (acknowledges adherence)
            Button(action: {
                if let nextDate = nextInjectionDate() {
                    dataStore.acknowledgeInjection(
                        protocolID: injectionProtocol.id,
                        injectionDate: nextDate
                    )
                }
            }) {
                Label(&quot;Record Injection&quot;, systemImage: &quot;checkmark.circle&quot;)
            }
            .buttonStyle(.bordered)
            .disabled(nextInjectionDate() == nil)
            
            Spacer()
            
            Button(action: {
                dataStore.calibrateProtocol(injectionProtocol)
                showingCalibrateConfirm = true
            }) {
                Label(&quot;Recalibrate&quot;, systemImage: &quot;slider.horizontal.3&quot;)
            }
            .buttonStyle(.bordered)
            .disabled(injectionProtocol.bloodSamples.isEmpty)
        }
        .padding(.horizontal)
    }
    
    // MARK: - Protocol summary based on protocol type
    
    var protocolSummaryView: some View {
        VStack(alignment: .leading, spacing: 8) {
            // Display information based on protocol type
            switch injectionProtocol.protocolType {
            case .compound:
                if let compoundID = injectionProtocol.compoundID,
                   let compound = dataStore.compoundLibrary.compound(withID: compoundID) {
                    compoundSummary(compound: compound)
                } else {
                    // Fallback: Try to extract compound name from protocol name
                    let esterNames = [&quot;propionate&quot;, &quot;phenylpropionate&quot;, &quot;isocaproate&quot;, &quot;enanthate&quot;, 
                                     &quot;cypionate&quot;, &quot;decanoate&quot;, &quot;undecanoate&quot;]
                    
                    let foundEster = esterNames.first { ester in
                        injectionProtocol.name.lowercased().contains(ester) ||
                        (injectionProtocol.notes ?? &quot;&quot;).lowercased().contains(ester)
                    }
                    
                    if let esterName = foundEster,
                       let compound = dataStore.compoundLibrary.compounds.first(where: { 
                           $0.classType == .testosterone &amp;&amp; 
                           $0.ester?.lowercased() == esterName.lowercased() 
                       }) {
                        // Found a matching compound, show it
                        compoundSummary(compound: compound)
                        
                        // This will be updated in onAppear
                        Text(&quot;Protocol will be updated&quot;)
                            .font(.caption)
                            .foregroundColor(.secondary)
                    } else {
                        Text(&quot;Invalid compound selection&quot;)
                            .foregroundColor(.red)
                    }
                }
                
            case .blend:
                if let blendID = injectionProtocol.blendID,
                   let blend = dataStore.compoundLibrary.blend(withID: blendID) {
                    blendSummary(blend: blend)
                } else {
                    Text(&quot;Invalid blend selection&quot;)
                        .foregroundColor(.red)
                }
            }
            
            // Common protocol details
            Divider()
            
            HStack {
                Text(&quot;Dose:&quot;)
                    .bold()
                Spacer()
                Text(&quot;\(injectionProtocol.doseMg, specifier: &quot;%.1f&quot;) mg&quot;)
            }
            
            HStack {
                Text(&quot;Frequency:&quot;)
                    .bold()
                Spacer()
                if injectionProtocol.frequencyDays == 7 {
                    Text(&quot;Weekly&quot;)
                } else if injectionProtocol.frequencyDays == 3.5 {
                    Text(&quot;Twice weekly&quot;)
                } else if injectionProtocol.frequencyDays == 1 {
                    Text(&quot;Daily&quot;)
                } else {
                    Text(&quot;Every \(injectionProtocol.frequencyDays, specifier: &quot;%.1f&quot;) days&quot;)
                }
            }
            
            // Show administration route if available
            if let routeString = injectionProtocol.selectedRoute,
               let route = Compound.Route(rawValue: routeString) {
                HStack {
                    Text(&quot;Route:&quot;)
                        .bold()
                    Spacer()
                    Text(route.displayName)
                }
            } else {
                // Default route if not specified
                HStack {
                    Text(&quot;Route:&quot;)
                        .bold()
                    Spacer()
                    Text(&quot;Intramuscular (IM)&quot;)
                }
            }
            
            HStack {
                Text(&quot;Start Date:&quot;)
                    .bold()
                Spacer()
                Text(injectionProtocol.startDate, style: .date)
            }
            
            if let notes = injectionProtocol.notes, !notes.isEmpty {
                Text(&quot;Notes:&quot;)
                    .bold()
                
                // Filter out the extended data JSON
                let filteredNotes = notes.contains(&quot;---EXTENDED_DATA---&quot;) 
                    ? notes.components(separatedBy: &quot;---EXTENDED_DATA---&quot;).first?.trimmingCharacters(in: .whitespacesAndNewlines) 
                    : notes
                
                if let filteredNotes = filteredNotes, !filteredNotes.isEmpty {
                    Text(filteredNotes)
                        .fixedSize(horizontal: false, vertical: true)
                }
            }
        }
        .padding()
        .background(Color(.systemGray6))
        .cornerRadius(10)
    }
    
    // MARK: - Protocol type-specific summaries
    
    func compoundSummary(compound: Compound) -&gt; some View {
        VStack(alignment: .leading) {
            HStack {
                Text(&quot;Compound:&quot;)
                    .bold()
                Spacer()
                Text(compound.fullDisplayName)
            }
            
            HStack {
                Text(&quot;Half-life:&quot;)
                    .bold()
                Spacer()
                Text(&quot;\(compound.halfLifeDays, specifier: &quot;%.1f&quot;) days&quot;)
            }
            
            HStack {
                Text(&quot;Class:&quot;)
                    .bold()
                Spacer()
                Text(compound.classType.displayName)
            }
        }
    }
    
    func blendSummary(blend: VialBlend) -&gt; some View {
        VStack(alignment: .leading) {
            HStack {
                Text(&quot;Blend:&quot;)
                    .bold()
                Spacer()
                Text(blend.name)
            }
            
            if let manufacturer = blend.manufacturer {
                HStack {
                    Text(&quot;Manufacturer:&quot;)
                        .bold()
                    Spacer()
                    Text(manufacturer)
                }
            }
            
            HStack {
                Text(&quot;Composition:&quot;)
                    .bold()
                Spacer()
            }
            
            Text(blend.compositionDescription(using: dataStore.compoundLibrary))
                .font(.caption)
                .foregroundColor(.secondary)
                .fixedSize(horizontal: false, vertical: true)
        }
    }
    
    // MARK: - Blood sample summary
    
    func latestBloodworkView(sample: BloodSample) -&gt; some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(&quot;Latest Blood Test&quot;)
                .font(.headline)
            
            HStack {
                Text(&quot;Date:&quot;)
                    .bold()
                Spacer()
                Text(sample.date, style: .date)
            }
            
            HStack {
                Text(&quot;Measured Level:&quot;)
                    .bold()
                Spacer()
                Text(&quot;\(formatValue(sample.value, unit: sample.unit)) \(sample.unit)&quot;)
            }
            
            // Calculate the model&apos;s prediction for the same date
            let modelPrediction = dataStore.predictedLevel(on: sample.date, for: injectionProtocol)
            
            HStack {
                Text(&quot;Model Prediction:&quot;)
                    .bold()
                Spacer()
                Text(&quot;\(formatValue(modelPrediction, unit: dataStore.profile.unit)) \(dataStore.profile.unit)&quot;)
            }
            
            // Show error percentage
            let errorPercentage = abs((modelPrediction - sample.value) / sample.value * 100)
            HStack {
                Text(&quot;Deviation:&quot;)
                    .bold()
                Spacer()
                Text(&quot;\(formatValue(errorPercentage, unit: &quot;%&quot;))%&quot;)
                    .foregroundColor(errorPercentage &lt; 10 ? .green : (errorPercentage &lt; 20 ? .yellow : .red))
            }
        }
        .padding()
        .background(Color(.systemGray6))
        .cornerRadius(10)
    }
    
    // MARK: - Helper for value formatting
    
    func formatValue(_ value: Double, unit: String) -&gt; String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        if unit == &quot;nmol/L&quot; {
            formatter.maximumFractionDigits = 1
        } else if unit == &quot;%&quot; {
            formatter.maximumFractionDigits = 1
        } else { // ng/dL typically whole numbers
            formatter.maximumFractionDigits = 0
        }
        formatter.minimumFractionDigits = formatter.maximumFractionDigits // Ensure consistency
        return formatter.string(from: NSNumber(value: value)) ?? &quot;\(value)&quot;
    }
    
    // MARK: - Helper Methods
    
    private func nextInjectionDate() -&gt; Date? {
        let today = Date()
        let endDate = today.addingTimeInterval(60 * 24 * 3600) // Look 60 days ahead
        let upcomingDates = injectionProtocol.injectionDates(from: today, upto: endDate)
        
        return upcomingDates.first
    }
    
    private func daysUntilNextInjection(_ nextDate: Date) -&gt; String {
        let today = Date()
        let calendar = Calendar.current
        let components = calendar.dateComponents([.day, .hour], from: today, to: nextDate)
        
        if let days = components.day, let hours = components.hour {
            if days == 0 {
                return &quot;Today&quot;
            } else if days == 1 {
                return &quot;Tomorrow&quot;
            } else {
                return &quot;In \(days) days, \(hours) hours&quot;
            }
        }
        
        return &quot;&quot;
    }
    
    // MARK: - Protocol Compound Auto-Fix
    
    private func fixProtocolCompound() {
        // Only fix protocols that don&apos;t have compounds
        if injectionProtocol.compoundID == nil {
            let esterNames = [&quot;propionate&quot;, &quot;phenylpropionate&quot;, &quot;isocaproate&quot;, &quot;enanthate&quot;, 
                             &quot;cypionate&quot;, &quot;decanoate&quot;, &quot;undecanoate&quot;]
            
            // Look for matching ester in name or notes
            let foundEster = esterNames.first { ester in
                injectionProtocol.name.lowercased().contains(ester) ||
                (injectionProtocol.notes ?? &quot;&quot;).lowercased().contains(ester)
            }
            
            if let esterName = foundEster,
               let compound = dataStore.compoundLibrary.compounds.first(where: { 
                   $0.classType == .testosterone &amp;&amp; 
                   $0.ester?.lowercased() == esterName.lowercased() 
               }) {
                // Found a matching compound, update protocol
                var updatedProtocol = injectionProtocol
                updatedProtocol.compoundID = compound.id
                updatedProtocol.selectedRoute = updatedProtocol.selectedRoute ?? 
                                             Compound.Route.intramuscular.rawValue
                
                // Update protocol in datastore
                dataStore.updateProtocol(updatedProtocol)
            }
        }
    }
}

#Preview {
    NavigationStack {
        ProtocolDetailView(injectionProtocol: InjectionProtocol(
            name: &quot;Test Protocol&quot;,
            doseMg: 100,
            frequencyDays: 7,
            startDate: Date()
        ))
        .environmentObject(AppDataStore())
    }
}</file><file path="TestoSim/ViewModels/AppDataStore.swift">import Foundation
import SwiftUI
import CoreData // Make sure CoreData is imported

@MainActor
class AppDataStore: ObservableObject {
    // MARK: - Published Properties
    @Published var profile: UserProfile
    @Published var simulationData: [DataPoint] = []
    @Published var selectedProtocolID: UUID?
    @Published var isPresentingProtocolForm = false
    @Published var protocolToEdit: InjectionProtocol?
    @Published var compoundLibrary = CompoundLibrary()

    // Cycle management
    @Published var cycles: [Cycle] = []
    @Published var selectedCycleID: UUID?
    @Published var isPresentingCycleForm = false // Used for presenting cycle creation form
    @Published var cycleToEdit: Cycle?          // Used for editing existing cycles
    @Published var isCycleSimulationActive = false
    @Published var cycleSimulationData: [DataPoint] = []

    // MARK: - Private Properties
    private static let coreDataManager = CoreDataManager.shared
    private let coreDataManager = CoreDataManager.shared
    private let notificationManager = NotificationManager.shared
    // PKModel instance - always use two-compartment model as per latest decision
    private let pkModel = PKModel(useTwoCompartmentModel: true)

    // MARK: - Constants
    let simulationDurationDays: Double = 90.0 // Default simulation length

    // MARK: - Computed Properties (Removed simulationEndDate as it&apos;s calculated dynamically now)

    // MARK: - Initialization
    init() {
        // Initialize profile with a default empty profile first
        self.profile = UserProfile()

        // Check migration status and load data accordingly
        if UserDefaults.standard.bool(forKey: &quot;migrated&quot;) {
            // Load profile from Core Data
            if let loadedProfile = AppDataStore.loadProfileFromCoreData() {
                self.profile = loadedProfile
            } else {
                // If loading fails after migration, create default and save
                self.profile = AppDataStore.createDefaultProfile()
                let context = coreDataManager.persistentContainer.viewContext
                _ = self.profile.saveToCD(context: context)
                do {
                    try context.save()
                } catch {
                    print(&quot;Error saving default profile to Core Data after failed load: \(error)&quot;)
                }
            }
            // Load cycles from Core Data if migrated
            loadCyclesFromCoreData()
        } else {
            // Not migrated yet, try loading from UserDefaults (old method)
            if let savedData = UserDefaults.standard.data(forKey: &quot;userProfileData&quot;),
               let decodedProfile = try? JSONDecoder().decode(UserProfile.self, from: savedData) {
                self.profile = decodedProfile
                // Trigger migration to Core Data
                coreDataManager.migrateUserProfileFromJSON() // This saves the migrated data
                UserDefaults.standard.set(true, forKey: &quot;migrated&quot;) // Mark as migrated
                print(&quot;Successfully migrated profile from UserDefaults to Core Data.&quot;)
            } else {
                // No old data and not migrated: Create default profile and save to Core Data
                self.profile = AppDataStore.createDefaultProfile()
                let context = coreDataManager.persistentContainer.viewContext
                _ = self.profile.saveToCD(context: context)
                do {
                    try context.save()
                } catch {
                    print(&quot;Error saving initial default profile to Core Data: \(error)&quot;)
                }
                UserDefaults.standard.set(true, forKey: &quot;migrated&quot;) // Mark as migrated even if creating default
            }
        }

        // Set initial selected protocol if any exist
        if !profile.protocols.isEmpty {
             // Ensure the selected protocol ID actually exists in the loaded profile
             if let firstValidProtocolID = profile.protocols.first?.id {
                  selectedProtocolID = firstValidProtocolID
             }
        } else {
             selectedProtocolID = nil // Explicitly nil if no protocols
        }


        // Generate initial simulation data for the selected protocol (if any)
        recalcSimulation() // This will handle the case where selectedProtocolID is nil

        // Schedule notifications for all protocols if enabled
        if notificationManager.notificationsEnabled {
            Task {
                await scheduleAllNotifications()
            }
        }
    }

    // MARK: - Helper: Create PK Model
    // Ensures the PK Model is created consistently with app settings
    private func createPKModel() -&gt; PKModel {
        // Always use two-compartment model with endogenous production included
        return PKModel(useTwoCompartmentModel: true, includeEndogenousProduction: true)
    }

    // MARK: - Helper: Generate Simulation Dates
    // Generates an array of Dates for simulation points
    private func generateSimulationDates(startDate: Date, endDate: Date, interval: Double) -&gt; [Date] {
        guard startDate &lt;= endDate, interval &gt; 0 else { return [] } // Basic validation

        var dates: [Date] = []
        var currentDate = startDate
        let intervalSeconds = interval * 24 * 3600 // Convert days to seconds

        while currentDate &lt;= endDate {
            dates.append(currentDate)
            // Ensure adding interval doesn&apos;t cause infinite loop with very small intervals near precision limits
            if let nextDate = Calendar.current.date(byAdding: .second, value: Int(intervalSeconds.rounded()), to: currentDate), nextDate &gt; currentDate {
                currentDate = nextDate
            } else {
                // Fallback or break if interval is too small or date calculation fails
                currentDate = currentDate.addingTimeInterval(intervalSeconds)
                if currentDate &lt;= dates.last ?? startDate { // Prevent infinite loop
                    print(&quot;Warning: Simulation date interval too small or calculation failed. Breaking loop.&quot;)
                    break
                }
            }
            // Safety break
            if dates.count &gt; 5000 { // Limit number of points to prevent excessive calculation
                print(&quot;Warning: Simulation date generation exceeded 5000 points. Breaking loop.&quot;)
                break
            }
        }
        // Ensure the end date is included if it wasn&apos;t hit exactly by the stride
        if let lastDate = dates.last, lastDate &lt; endDate {
            dates.append(endDate)
        }
        return dates
    }
    
    // MARK: - Helper: Find Legacy Compound (Temporary Fix)
    // Attempts to find a matching compound based on legacy notes/name
    private func findLegacyCompound(for injectionProtocol: InjectionProtocol) -&gt; Compound? {
         let esterNames = [&quot;propionate&quot;, &quot;phenylpropionate&quot;, &quot;isocaproate&quot;, &quot;enanthate&quot;,
                           &quot;cypionate&quot;, &quot;decanoate&quot;, &quot;undecanoate&quot;]
         let notes = injectionProtocol.notes ?? &quot;&quot;
         let name = injectionProtocol.name

         // Prioritize finding ester name in the dedicated field within notes if available
         var foundEsterName: String? = nil
         if let notesRange = notes.range(of: &quot;---EXTENDED_DATA---&quot;) {
             let jsonString = String(notes[notesRange.upperBound...]).trimmingCharacters(in: .whitespacesAndNewlines)
             if let jsonData = jsonString.data(using: .utf8),
                let extendedData = try? JSONSerialization.jsonObject(with: jsonData) as? [String: String] {
                 // Check if compoundID exists and find compound directly
                 if let compoundIDStr = extendedData[&quot;compoundID&quot;], let uuid = UUID(uuidString: compoundIDStr) {
                    if let directCompound = compoundLibrary.compound(withID: uuid) {
                         print(&quot;Legacy Fix: Found compound via ID in extended data.&quot;)
                         return directCompound
                    }
                 }
                 // Otherwise, continue searching by name/notes
             }
         }

         // If not found via ID, search by name/notes string matching
         foundEsterName = esterNames.first { ester in
             name.lowercased().contains(ester) || notes.lowercased().contains(ester)
         }

         if let esterName = foundEsterName {
             let matchingCompound = compoundLibrary.compounds.first {
                 $0.classType == .testosterone &amp;&amp; $0.ester?.lowercased() == esterName.lowercased()
             }
             if matchingCompound != nil { print(&quot;Legacy Fix: Found compound via name/notes string matching.&quot;) }
             return matchingCompound
         }
         print(&quot;Legacy Fix: Could not find matching compound for protocol &apos;\(name)&apos;&quot;)
         return nil
     }


    // MARK: - Core Data Loading/Saving
    private static func loadProfileFromCoreData() -&gt; UserProfile? {
        let context = coreDataManager.persistentContainer.viewContext
        let fetchRequest: NSFetchRequest&lt;CDUserProfile&gt; = CDUserProfile.fetchRequest()
        do {
            let results = try context.fetch(fetchRequest)
            if let cdProfile = results.first {
                print(&quot;Profile loaded successfully from Core Data.&quot;)
                return UserProfile(from: cdProfile)
            } else {
                print(&quot;No profile found in Core Data.&quot;)
            }
        } catch {
            print(&quot;Error fetching profile from Core Data: \(error)&quot;)
        }
        return nil
    }

    func saveProfile() {
        // Always save to Core Data now
        let context = coreDataManager.persistentContainer.viewContext
        _ = profile.saveToCD(context: context) // This handles create/update
        // Note: The actual context save is handled by CoreDataManager.saveContext()
        // which might be called elsewhere (e.g., on app background) or explicitly if needed immediately.
        // For robustness, you might call it here too, but be mindful of performance if called frequently.
        // coreDataManager.saveContext() // Uncomment if immediate save is desired after every profile change
        print(&quot;Profile prepared for saving to Core Data.&quot;)
    }

    // MARK: - Default Profile Creation
    private static func createDefaultProfile() -&gt; UserProfile {
        print(&quot;Creating default profile.&quot;)
        var profile = UserProfile()
        // Set up a complete test profile with realistic user data
        profile.name = &quot;Test User&quot;
        profile.unit = &quot;ng/dL&quot;
        profile.calibrationFactor = 1.0
        profile.dateOfBirth = Calendar.current.date(byAdding: .year, value: -35, to: Date())!
        profile.heightCm = 175.0 // cm
        profile.weight = 85.0 // kg
        profile.biologicalSex = .male
        profile.usesICloudSync = false

        // Add a variety of test protocols with compounds
        let compoundLibrary = CompoundLibrary() // Use a local instance for default creation

        // 1. Standard TRT protocol (cypionate)
        var weeklyProtocol = InjectionProtocol(
            name: &quot;Weekly Cypionate&quot;,
            doseMg: 100.0,
            frequencyDays: 7.0,
            startDate: Calendar.current.date(byAdding: .day, value: -60, to: Date())!,
            notes: &quot;Standard TRT protocol with weekly injections&quot;
        )
        if let cypionate = compoundLibrary.compounds.first(where: { $0.classType == .testosterone &amp;&amp; $0.ester?.lowercased() == &quot;cypionate&quot; }) {
            weeklyProtocol.compoundID = cypionate.id
            weeklyProtocol.selectedRoute = Compound.Route.intramuscular.rawValue
            // Add some test blood samples to the protocol
            weeklyProtocol.bloodSamples = [
                BloodSample(date: Calendar.current.date(byAdding: .day, value: -30, to: Date())!, value: 650.0, unit: &quot;ng/dL&quot;),
                BloodSample(date: Calendar.current.date(byAdding: .day, value: -15, to: Date())!, value: 720.0, unit: &quot;ng/dL&quot;)
            ]
            profile.protocols.append(weeklyProtocol)
        } else { print(&quot;Warning: Could not find Testosterone Cypionate in library for default profile.&quot;) }


        // 2. Split dose protocol (enanthate)
        var splitDoseProtocol = InjectionProtocol(
            name: &quot;Split Dose Enanthate&quot;,
            doseMg: 75.0,
            frequencyDays: 3.5,
            startDate: Calendar.current.date(byAdding: .day, value: -45, to: Date())!,
            notes: &quot;Split dose protocol for more stable levels&quot;
        )
        if let enanthate = compoundLibrary.compounds.first(where: { $0.classType == .testosterone &amp;&amp; $0.ester?.lowercased() == &quot;enanthate&quot; }) {
            splitDoseProtocol.compoundID = enanthate.id
            splitDoseProtocol.selectedRoute = Compound.Route.intramuscular.rawValue
            profile.protocols.append(splitDoseProtocol)
        } else { print(&quot;Warning: Could not find Testosterone Enanthate in library for default profile.&quot;) }


        // 3. Propionate protocol (more frequent injections)
        var propionateProtocol = InjectionProtocol(
            name: &quot;EOD Propionate&quot;,
            doseMg: 30.0,
            frequencyDays: 2.0,
            startDate: Calendar.current.date(byAdding: .day, value: -30, to: Date())!,
            notes: &quot;Every other day protocol with propionate&quot;
        )
        if let propionate = compoundLibrary.compounds.first(where: { $0.classType == .testosterone &amp;&amp; $0.ester?.lowercased() == &quot;propionate&quot; }) {
            propionateProtocol.compoundID = propionate.id
            propionateProtocol.selectedRoute = Compound.Route.subcutaneous.rawValue // Example different route
            profile.protocols.append(propionateProtocol)
        } else { print(&quot;Warning: Could not find Testosterone Propionate in library for default profile.&quot;) }

        return profile
    }

    // MARK: - Protocol Management
    func addProtocol(_ newProtocol: InjectionProtocol) {
        profile.protocols.append(newProtocol)
        selectedProtocolID = newProtocol.id // Select the newly added protocol
        recalcSimulation() // Simulate the newly added protocol
        saveProfile() // Prepare profile for saving
        coreDataManager.saveContext() // Save immediately
        // Schedule notifications for the new protocol
        if notificationManager.notificationsEnabled {
            notificationManager.scheduleNotifications(for: newProtocol, using: compoundLibrary)
        }
        print(&quot;Added protocol: \(newProtocol.name)&quot;)
    }

    func updateProtocol(_ updatedProtocol: InjectionProtocol) {
        if let index = profile.protocols.firstIndex(where: { $0.id == updatedProtocol.id }) {
            profile.protocols[index] = updatedProtocol
            if updatedProtocol.id == selectedProtocolID {
                recalcSimulation() // Resimulate if the selected protocol was updated
            }
            saveProfile() // Prepare profile for saving
            coreDataManager.saveContext() // Save immediately
            // Update notifications for the modified protocol
            if notificationManager.notificationsEnabled {
                notificationManager.scheduleNotifications(for: updatedProtocol, using: compoundLibrary)
            }
            print(&quot;Updated protocol: \(updatedProtocol.name)&quot;)
        } else {
            print(&quot;Error: Protocol to update not found (ID: \(updatedProtocol.id))&quot;)
        }
    }

    func removeProtocol(at offsets: IndexSet) {
        let deletedProtocols = offsets.map { profile.protocols[$0] }
        let deletedIDs = deletedProtocols.map { $0.id }

        profile.protocols.remove(atOffsets: offsets)

        // Check if selected protocol was deleted
        if let selectedID = selectedProtocolID, deletedIDs.contains(selectedID) {
            // Select the first remaining protocol, or none if list is empty
            selectedProtocolID = profile.protocols.first?.id
            recalcSimulation() // Recalculate simulation for new selection or empty state
        }

        saveProfile() // Prepare profile for saving
        coreDataManager.saveContext() // Save immediately

        // Cancel notifications for deleted protocols
        for item in deletedProtocols {
            notificationManager.cancelNotifications(for: item.id)
            print(&quot;Removed protocol: \(item.name)&quot;)
        }
    }

    func selectProtocol(id: UUID?) { // Allow nil to deselect
        guard let id = id else {
             selectedProtocolID = nil
             simulationData = [] // Clear simulation if no protocol selected
             print(&quot;Protocol deselected.&quot;)
             return
        }
        
        // Only proceed if the selected ID exists in the profile
        guard profile.protocols.contains(where: { $0.id == id }) else {
            print(&quot;Error: Attempted to select non-existent protocol ID: \(id)&quot;)
            // Optionally select the first available protocol if selection is invalid
            if let firstID = profile.protocols.first?.id {
                 selectedProtocolID = firstID
                 simulateProtocol(id: firstID) // Simulate the first one instead
            } else {
                 selectedProtocolID = nil
                 simulationData = []
            }
            return
        }

        // Check if selection actually changed or if simulation needs recalculating
        if selectedProtocolID != id || simulationData.isEmpty {
            selectedProtocolID = id
            simulateProtocol(id: id) // Always simulate when protocol is explicitly selected
            print(&quot;Selected protocol: \(profile.protocols.first { $0.id == id }?.name ?? &quot;Unknown&quot;)&quot;)
        }
    }

    // MARK: - Simulation Core Logic

    // Recalculates simulation based on the currently selected protocol
    func recalcSimulation() {
        guard let currentSelectedID = selectedProtocolID else {
            simulationData = [] // Clear data if no protocol is selected
            print(&quot;RecalcSimulation: No protocol selected, clearing data.&quot;)
            return
        }
        // Ensure the selected protocol exists before simulating
        if profile.protocols.contains(where: { $0.id == currentSelectedID }) {
             simulateProtocol(id: currentSelectedID)
        } else {
             print(&quot;RecalcSimulation: Selected protocol ID \(currentSelectedID) not found in profile. Clearing data.&quot;)
             simulationData = []
             selectedProtocolID = nil // Deselect invalid ID
        }
    }
    
    // Simulate a specific protocol - called by selectProtocol and recalcSimulation
    func simulateProtocol(id: UUID) {
        guard let treatmentProtocol = profile.protocols.first(where: { $0.id == id }) else {
            print(&quot;SimulateProtocol Error: Protocol with ID \(id) not found.&quot;)
            simulationData = [] // Clear data if protocol not found
            return
        }

        simulationData = generateSimulationData(for: treatmentProtocol)
        print(&quot;Simulation generated for protocol: \(treatmentProtocol.name)&quot;)
    }

    // Generates the DataPoint array for a given protocol&apos;s simulation
    // ** THIS IS THE REFACTORED VERSION **
    func generateSimulationData(for injectionProtocol: InjectionProtocol) -&gt; [DataPoint] {
        // 1. Determine simulation time range
        let calendar = Calendar.current
        let now = Date()
        let simulationStartDate: Date
        let daysBeforeStart = -7 // Show a week before start or now

        if injectionProtocol.startDate &gt; now {
            // Future protocol: start simulation view a week before protocol start
            simulationStartDate = calendar.date(byAdding: .day, value: daysBeforeStart, to: injectionProtocol.startDate) ?? injectionProtocol.startDate
        } else {
            // Protocol already started: show from a week before now or protocol start, whichever is earlier
            let aWeekBeforeNow = calendar.date(byAdding: .day, value: daysBeforeStart, to: now) ?? now
            simulationStartDate = min(aWeekBeforeNow, injectionProtocol.startDate)
        }

        // Determine end date: Ensure at least 90 days from protocol start AND 30 days from now are shown
        let minEndDate = calendar.date(byAdding: .day, value: Int(simulationDurationDays), to: injectionProtocol.startDate) ?? now // Use constant duration
        let thirtyDaysFromNow = calendar.date(byAdding: .day, value: 30, to: now) ?? now
        let simulationEndDate = max(minEndDate, thirtyDaysFromNow)

        // 2. Generate time points for the chart
        let simulationDates = generateSimulationDates(
            startDate: simulationStartDate,
            endDate: simulationEndDate,
             // Dynamic interval based on frequency, minimum 6 hours (0.25 days)
            interval: max(0.25, injectionProtocol.frequencyDays / 16.0) 
        )

        if simulationDates.isEmpty {
            print(&quot;Warning: No simulation dates generated for protocol \(injectionProtocol.name)&quot;)
            return []
        }

        // 3. Generate ALL relevant injection dates up to the simulation end date
        let allInjectionDates = injectionProtocol.injectionDates(
            from: injectionProtocol.startDate, // Base calculation from protocol start
            upto: simulationEndDate             // Include all injections needed for the simulation window
        )

        // 4. Get compounds/blend details
        var compounds: [(compound: Compound, dosePerInjectionMg: Double)] = []
        let route: Compound.Route
        if let routeString = injectionProtocol.selectedRoute, let selectedRoute = Compound.Route(rawValue: routeString) {
            route = selectedRoute
        } else {
            route = .intramuscular // Default route
        }

        // Determine the compounds and doses based on protocol type
        switch injectionProtocol.protocolType {
            case .compound:
                if let compoundID = injectionProtocol.compoundID, let compound = compoundLibrary.compound(withID: compoundID) {
                     if (compound.defaultBioavailability[route] ?? 0) &gt; 0 {
                          compounds = [(compound: compound, dosePerInjectionMg: injectionProtocol.doseMg)]
                     } else {
                          print(&quot;Warning: Selected route \(route.displayName) not supported for compound \(compound.commonName). Using default route.&quot;)
                          // Fallback to first supported route or default if none found
                          if let _ = compound.defaultBioavailability.keys.first(where: { (compound.defaultBioavailability[$0] ?? 0) &gt; 0 }) {
                               compounds = [(compound: compound, dosePerInjectionMg: injectionProtocol.doseMg)]
                               // Note: Ideally, update protocol&apos;s selectedRoute here, but that could trigger unwanted UI updates.
                          } else {
                               print(&quot;Error: Compound \(compound.commonName) has no supported routes defined.&quot;)
                               return [] // Cannot simulate without a valid route/compound combo
                          }
                     }
                }
            case .blend:
                if let blendID = injectionProtocol.blendID, let blend = compoundLibrary.blend(withID: blendID) {
                     // Blends usually assume IM, route check less critical here unless supporting SubQ blends later
                     let resolvedComponents = blend.resolvedComponents(using: compoundLibrary)
                     // Check if totalConcentration is valid before division
                      guard blend.totalConcentration &gt; 0 else {
                         print(&quot;Error: Blend \(blend.name) has zero total concentration.&quot;)
                         return []
                      }
                      compounds = resolvedComponents.map {
                         (compound: $0.compound, dosePerInjectionMg: $0.mgPerML * injectionProtocol.doseMg / blend.totalConcentration)
                      }
                }
        }
        
        // Final check for compounds, potentially attempt legacy fix
         if compounds.isEmpty {
              print(&quot;Warning: No valid compounds initially determined for protocol \(injectionProtocol.name). Attempting legacy fix...&quot;)
              if let fixedCompound = findLegacyCompound(for: injectionProtocol) {
                   // Ensure the route is valid for the fixed compound
                   if (fixedCompound.defaultBioavailability[route] ?? 0) &gt; 0 {
                        // Valid route - use it
                   } else if let firstSupported = fixedCompound.defaultBioavailability.keys.first(where: { (fixedCompound.defaultBioavailability[$0] ?? 0) &gt; 0 }) {
                        print(&quot;Legacy Fix: Using route \(firstSupported.displayName) for compound \(fixedCompound.commonName)&quot;)
                    } else {
                        print(&quot;Legacy Fix Error: Compound \(fixedCompound.commonName) has no supported routes.&quot;)
                        return []
                    }
                   compounds = [(compound: fixedCompound, dosePerInjectionMg: injectionProtocol.doseMg)]
                   print(&quot;Legacy fix applied. Using compound: \(fixedCompound.fullDisplayName)&quot;)
              } else {
                   print(&quot;Error: No valid compounds found for protocol \(injectionProtocol.name), even after legacy check. Cannot simulate.&quot;)
                   return []
              }
         }


        // 5. Call PKModel calculation ONCE
        let pkModel = createPKModel() // Ensure we use the correct model settings
        
        // Print summary of simulation setup (keep this but make it less verbose)
        print(&quot;Simulating protocol \(injectionProtocol.name): \(allInjectionDates.count) injections, \(compounds.count) compounds&quot;)
        
        let concentrations = pkModel.protocolConcentrations(
            at: simulationDates,
            injectionDates: allInjectionDates, // Pass ALL injection dates needed for the full timeline
            compounds: compounds,
            route: route, // Use the determined (or default) route
            weight: profile.weight ?? 70.0, // Use profile weight or default
            calibrationFactor: profile.calibrationFactor
        )
        
        // Keep brief summary of results
        let maxConcentration = concentrations.max() ?? 0
        print(&quot;Max concentration: \(Int(maxConcentration)) \(profile.unit)&quot;)

        // 6. Zip dates and concentrations into DataPoints
        let dataPoints = zip(simulationDates, concentrations).map { date, level in
            DataPoint(time: date, level: level.isNaN ? 0 : level) // Handle potential NaN results gracefully
        }

        return dataPoints
    }

    // MARK: - Single Point Level Calculation (for Calibration, etc.)
    // Calculates the concentration at a *single* specific date.
    private func calculateLevelForDate(_ date: Date, for injectionProtocol: InjectionProtocol) -&gt; Double {
        // 1. Get compounds/blend details
        var compounds: [(compound: Compound, dosePerInjectionMg: Double)] = []
        let route: Compound.Route
        if let routeString = injectionProtocol.selectedRoute, let selectedRoute = Compound.Route(rawValue: routeString) {
            route = selectedRoute
        } else {
            route = .intramuscular // Default route
        }

        switch injectionProtocol.protocolType {
            case .compound:
                if let compoundID = injectionProtocol.compoundID, let compound = compoundLibrary.compound(withID: compoundID) {
                     if (compound.defaultBioavailability[route] ?? 0) &gt; 0 {
                          compounds = [(compound: compound, dosePerInjectionMg: injectionProtocol.doseMg)]
                     } else { return 0.0 } // Invalid route for compound
                }
            case .blend:
                 if let blendID = injectionProtocol.blendID, let blend = compoundLibrary.blend(withID: blendID) {
                      guard blend.totalConcentration &gt; 0 else { return 0.0 }
                      compounds = blend.resolvedComponents(using: compoundLibrary).map {
                         (compound: $0.compound, dosePerInjectionMg: $0.mgPerML * injectionProtocol.doseMg / blend.totalConcentration)
                      }
                 }
        }

        // Attempt legacy fix if needed
         if compounds.isEmpty {
              if let fixedCompound = findLegacyCompound(for: injectionProtocol) {
                   // Check if route is valid, otherwise just use it anyway (the route validation should happen elsewhere)
                   if (fixedCompound.defaultBioavailability[route] ?? 0) &lt;= 0 {
                        // Route not supported, but we&apos;ll use it anyway and let the PKModel handle it
                        print(&quot;Warning: Selected route not optimal for legacy compound&quot;)
                   }
                   compounds = [(compound: fixedCompound, dosePerInjectionMg: injectionProtocol.doseMg)]
              } else {
                   print(&quot;Error: No valid compounds found for single date calculation: \(injectionProtocol.name)&quot;)
                   return 0.0
              }
         }

        // 2. Get ALL injection dates UP TO the target date
        let injectionDates = injectionProtocol.injectionDates(
            from: injectionProtocol.startDate, // Base calculation from protocol start
            upto: date                         // Only include injections up to the specific date
        )

        // 3. Call PKModel calculation for the single date
        let pkModel = createPKModel()
        let concentrations = pkModel.protocolConcentrations(
            at: [date], // Calculate only for this specific date
            injectionDates: injectionDates,
            compounds: compounds,
            route: route,
            weight: profile.weight ?? 70.0,
            calibrationFactor: profile.calibrationFactor // Use current factor for prediction
        )

        return concentrations.first ?? 0.0
    }

    // MARK: - Predicted Level (for UI display, potentially)
    // Primarily uses interpolation on existing simulation data for performance.
    func predictedLevel(on date: Date, for injectionProtocol: InjectionProtocol) -&gt; Double {
        // Option 1: Interpolate from existing simulationData (fast)
        if !simulationData.isEmpty,
            let firstDate = simulationData.first?.time,
            let lastDate = simulationData.last?.time,
            date &gt;= firstDate &amp;&amp; date &lt;= lastDate {

            // Find the two points surrounding the date using binary search for efficiency
             var lowerBound = 0
             var upperBound = simulationData.count - 1
             var midIndex = 0

             while lowerBound &lt;= upperBound {
                 midIndex = lowerBound + (upperBound - lowerBound) / 2
                 let midDate = simulationData[midIndex].time

                 if midDate == date {
                      return simulationData[midIndex].level // Exact match
                 } else if midDate &lt; date {
                      lowerBound = midIndex + 1
                 } else {
                      upperBound = midIndex - 1
                 }
             }

             // After loop, lowerBound points to the index *after* the target date&apos;s position
             // The surrounding points are at indices lowerBound - 1 and lowerBound
            
            // Check bounds
             guard lowerBound &gt; 0 &amp;&amp; lowerBound &lt; simulationData.count else {
                // Date is outside the range or at the exact start/end
                if date &lt;= firstDate { return simulationData.first?.level ?? 0 }
                if date &gt;= lastDate { return simulationData.last?.level ?? 0 }
                print(&quot;Interpolation index out of bounds.&quot;)
                return 0.0 // Should not happen if date is within range
             }


            let p1 = simulationData[lowerBound - 1]
            let p2 = simulationData[lowerBound]

            // Linear interpolation
            let timeIntervalTotal = p2.time.timeIntervalSince(p1.time)
            if timeIntervalTotal &lt;= 0 { return p1.level } // Avoid division by zero or negative interval

            let timeIntervalFromP1 = date.timeIntervalSince(p1.time)
            let fraction = timeIntervalFromP1 / timeIntervalTotal

            // Clamp fraction to [0, 1] to avoid extrapolation issues at edges
            let clampedFraction = max(0.0, min(1.0, fraction))

            return p1.level + (p2.level - p1.level) * clampedFraction
        }

        // Option 2: Date is outside the simulation range. Recalculate (can be slow if called often).
        print(&quot;Warning: Predicted level requested for date \(date) outside current simulation range. Recalculating single point.&quot;)
        return calculateLevelForDate(date, for: injectionProtocol) // Use the dedicated single-point calculator
    }

    // MARK: - Protocol Calibration

    // Simple calibration using the latest blood sample
    func calibrateProtocol(_ protocolToCalibrate: InjectionProtocol) {
        guard let latestSample = protocolToCalibrate.bloodSamples.max(by: { $0.date &lt; $1.date }) else {
            print(&quot;Cannot calibrate: No blood samples available for protocol \(protocolToCalibrate.name).&quot;)
            return
        }

        // Calculate the model&apos;s prediction AT THE SAMPLE DATE using the CURRENT calibration factor
        let modelPrediction = calculateLevelForDate(latestSample.date, for: protocolToCalibrate) // Uses the correct single-point calculation method

        guard modelPrediction.isFinite, modelPrediction &gt; 0.01 else {
            print(&quot;Calibration failed: Model prediction is zero or invalid (\(modelPrediction)) at sample date \(latestSample.date). Cannot calculate ratio.&quot;)
            return
        }

        // Calculate the adjustment ratio needed to match the latest sample
        let adjustmentRatio = latestSample.value / modelPrediction

         // Apply the adjustment to the global factor
         // Add bounds to prevent extreme calibration factors (e.g., 0.1x to 10x)
         let newFactor = max(0.1, min(10.0, profile.calibrationFactor * adjustmentRatio))
        
         print(&quot;Simple Calibration:&quot;)
         print(&quot;  - Latest Sample: \(latestSample.value) \(latestSample.unit) on \(latestSample.date)&quot;)
         print(&quot;  - Model Prediction (at sample date, current factor \(profile.calibrationFactor)): \(modelPrediction)&quot;)
         print(&quot;  - Adjustment Ratio: \(adjustmentRatio)&quot;)
         print(&quot;  - Old Factor: \(profile.calibrationFactor)&quot;)
         print(&quot;  - New Factor (Clamped): \(newFactor)&quot;)


        profile.calibrationFactor = newFactor
        recalcSimulation() // Update chart data with the new factor
        saveProfile()      // Persist the new factor
        coreDataManager.saveContext() // Save immediately
    }

    // Bayesian calibration (currently applies result as a simple factor adjustment)
    func calibrateProtocolWithBayesian(_ protocolToCalibrate: InjectionProtocol) {
        guard !protocolToCalibrate.bloodSamples.isEmpty, protocolToCalibrate.bloodSamples.count &gt;= 2 else {
            print(&quot;Bayesian calibration requires at least 2 blood samples. Falling back to simple calibration.&quot;)
            calibrateProtocol(protocolToCalibrate) // Fallback if not enough samples
            return
        }

        // Determine the compound/blend and dose for calibration
        var compoundForCalibration: Compound?
        var doseForCalibration: Double = protocolToCalibrate.doseMg
        let route: Compound.Route = {
            if let routeString = protocolToCalibrate.selectedRoute, let r = Compound.Route(rawValue: routeString) { return r }
            return .intramuscular
        }()

        switch protocolToCalibrate.protocolType {
        case .compound:
            compoundForCalibration = protocolToCalibrate.compoundID.flatMap { compoundLibrary.compound(withID: $0) }
        case .blend:
            // Use the component with the largest contribution or longest half-life for calibration?
            // For now, using the first component as an approximation. A more robust approach might be needed.
            if let blendID = protocolToCalibrate.blendID,
               let blend = compoundLibrary.blend(withID: blendID),
               let mainComponent = blend.resolvedComponents(using: compoundLibrary).max(by: { $0.mgPerML &lt; $1.mgPerML }) { // Choose component with highest mg/mL
                compoundForCalibration = mainComponent.compound
                // Adjust dose proportionally for the main component
                 guard blend.totalConcentration &gt; 0 else {
                      print(&quot;Bayesian Calibration Error: Blend has zero total concentration.&quot;)
                      calibrateProtocol(protocolToCalibrate); return // Fallback
                 }
                 doseForCalibration = mainComponent.mgPerML * protocolToCalibrate.doseMg / blend.totalConcentration
            }
        }

        guard let compound = compoundForCalibration else {
            print(&quot;Bayesian calibration failed: Could not determine valid compound for protocol \(protocolToCalibrate.name). Falling back.&quot;)
            calibrateProtocol(protocolToCalibrate)
            return
        }

        // Convert blood samples
        let samplePoints = protocolToCalibrate.bloodSamples.map {
            PKModel.SamplePoint(timestamp: $0.date, labValue: $0.value)
        }

        // Determine relevant injection dates (look back further for Bayesian)
        let firstSampleDate = protocolToCalibrate.bloodSamples.map { $0.date }.min() ?? Date()
        let lastSampleDate = protocolToCalibrate.bloodSamples.map { $0.date }.max() ?? Date()
        // Look back significantly to capture buildup phase effects for Bayesian
        let historyStartDate = Calendar.current.date(byAdding: .day, value: -180, to: firstSampleDate) ?? firstSampleDate
        let injectionDates = protocolToCalibrate.injectionDates(from: historyStartDate, upto: lastSampleDate)

        // Perform Bayesian calibration using the PKModel
        if let calibrationResult = pkModel.bayesianCalibration(
            samples: samplePoints,
            injectionDates: injectionDates,
            compound: compound,
            dose: doseForCalibration, // Use the potentially adjusted dose for blends
            route: route,
            weight: profile.weight ?? 70.0
        ) {
            // --- Apply Calibration Result ---
            // Option 1 (Current): Adjust the global calibration factor based on the overall fit improvement.
            // Calculate average error before and after Bayesian adjustment to find the improvement factor.
            let avgLabValue = samplePoints.reduce(0.0) { $0 + $1.labValue } / Double(samplePoints.count)
            
             // Calculate average prediction using the *original* parameters but *current* calibration factor
             // This represents the state *before* this Bayesian run, but after any previous simple calibrations
             let avgPredictionBeforeBayesian = samplePoints.reduce(0.0) { sum, point in
                  sum + calculateLevelForDate(point.timestamp, for: protocolToCalibrate) // Uses current profile.calibrationFactor internally
             } / Double(samplePoints.count)

            guard avgPredictionBeforeBayesian &gt; 0.01 else {
                 print(&quot;Bayesian Calibration Apply Failed: Pre-Bayesian prediction average is too low.&quot;)
                 calibrateProtocol(protocolToCalibrate) // Fallback
                 return
            }

            // Calculate the ratio needed to align the pre-Bayesian average prediction with the average lab value
            let adjustmentRatio = avgLabValue / avgPredictionBeforeBayesian
            let newFactor = max(0.1, min(10.0, profile.calibrationFactor * adjustmentRatio)) // Apply adjustment relative to current factor

            // Log details
            print(&quot;--- Bayesian Calibration Results ---&quot;)
            print(&quot;  Compound Used: \(compound.fullDisplayName)&quot;)
            print(&quot;  Original Half-life: \(String(format: &quot;%.2f&quot;, log(2) / calibrationResult.originalKe)) days (ke: \(calibrationResult.originalKe))&quot;)
            print(&quot;  Calibrated Half-life: \(String(format: &quot;%.2f&quot;, calibrationResult.halfLifeDays)) days (ke: \(calibrationResult.adjustedKe))&quot;)
            print(&quot;  Half-life Change: \(String(format: &quot;%.1f&quot;, calibrationResult.halfLifeChangePercent))%&quot;)
            print(&quot;  Original Ka: \(String(format: &quot;%.2f&quot;, calibrationResult.originalKa))&quot;)
            print(&quot;  Calibrated Ka: \(String(format: &quot;%.2f&quot;, calibrationResult.adjustedKa))&quot;)
            print(&quot;  Model Fit Correlation: \(String(format: &quot;%.3f&quot;, calibrationResult.correlation))&quot;)
             print(&quot;  Adjustment Applied:&quot;)
             print(&quot;    Avg Lab Value: \(avgLabValue)&quot;)
             print(&quot;    Avg Prediction (Before Bayesian, Factor \(profile.calibrationFactor)): \(avgPredictionBeforeBayesian)&quot;)
             print(&quot;    Adjustment Ratio: \(adjustmentRatio)&quot;)
             print(&quot;    Old Global Factor: \(profile.calibrationFactor)&quot;)
             print(&quot;    New Global Factor (Clamped): \(newFactor)&quot;)
            print(&quot;------------------------------------&quot;)


            // Apply the adjusted global factor
            profile.calibrationFactor = newFactor
            
            // Option 2 (Future): Store adjusted ke/ka per compound (more complex)
            // This would involve updating the CompoundLibrary or creating user-specific compound parameters.

            // Update simulation and save
            recalcSimulation()
            saveProfile()
            coreDataManager.saveContext() // Save immediately
        } else {
            print(&quot;Bayesian calibration failed to produce results. Falling back to simple calibration.&quot;)
            calibrateProtocol(protocolToCalibrate)
        }
    }

    // MARK: - Value Formatting
    func formatValue(_ value: Double, unit: String) -&gt; String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        if unit == &quot;nmol/L&quot; {
            formatter.maximumFractionDigits = 1
        } else if unit == &quot;%&quot; {
             formatter.maximumFractionDigits = 1
        } else { // ng/dL typically whole numbers
            formatter.maximumFractionDigits = 0
        }
        formatter.minimumFractionDigits = formatter.maximumFractionDigits // Ensure consistency
        // Handle potential NaN or infinity
        if !value.isFinite {
             return &quot;N/A&quot;
        }
        return formatter.string(from: NSNumber(value: value)) ?? &quot;\(value)&quot;
    }

    // MARK: - Peak Predictions
    func calculatePeakDetails(for injectionProtocol: InjectionProtocol) -&gt; (peakDate: Date, maxConcentration: Double) {
        // Reuse the logic from generateSimulationData to get compounds and route
         var compounds: [(compound: Compound, dosePerInjectionMg: Double)] = []
         let route: Compound.Route
         if let routeString = injectionProtocol.selectedRoute, let selectedRoute = Compound.Route(rawValue: routeString) {
             route = selectedRoute
         } else {
             route = .intramuscular // Default route
         }

         switch injectionProtocol.protocolType {
             case .compound:
                 if let compoundID = injectionProtocol.compoundID, let compound = compoundLibrary.compound(withID: compoundID) {
                      if (compound.defaultBioavailability[route] ?? 0) &gt; 0 {
                           compounds = [(compound: compound, dosePerInjectionMg: injectionProtocol.doseMg)]
                      }
                 }
             case .blend:
                  if let blendID = injectionProtocol.blendID, let blend = compoundLibrary.blend(withID: blendID) {
                       guard blend.totalConcentration &gt; 0 else { return (injectionProtocol.startDate, 0) }
                       compounds = blend.resolvedComponents(using: compoundLibrary).map {
                          (compound: $0.compound, dosePerInjectionMg: $0.mgPerML * injectionProtocol.doseMg / blend.totalConcentration)
                       }
                  }
         }
        
         if compounds.isEmpty {
              if let fixedCompound = findLegacyCompound(for: injectionProtocol) {
                   // Check if route is valid, otherwise just use it anyway (the route validation should happen elsewhere)
                   if (fixedCompound.defaultBioavailability[route] ?? 0) &lt;= 0 {
                        // Route not supported, but we&apos;ll try anyway
                        print(&quot;Warning: Selected route not optimal for peak calculation&quot;)
                        if !fixedCompound.defaultBioavailability.keys.contains(where: { (fixedCompound.defaultBioavailability[$0] ?? 0) &gt; 0 }) {
                             return (peakDate: injectionProtocol.startDate, maxConcentration: 0) // No valid routes at all
                        }
                   }
                   compounds = [(compound: fixedCompound, dosePerInjectionMg: injectionProtocol.doseMg)]
              } else {
                   print(&quot;Error calculating peak: No valid compounds for protocol \(injectionProtocol.name)&quot;)
                   return (peakDate: injectionProtocol.startDate, maxConcentration: 0)
              }
         }


        // Define time window (e.g., first 90 days of the protocol)
        let timeWindow = (
            start: injectionProtocol.startDate,
            end: injectionProtocol.startDate.addingTimeInterval(simulationDurationDays * 24 * 3600)
        )

        // Get all injection dates within the window
        let injectionDates = injectionProtocol.injectionDates(
            from: timeWindow.start, // Need injections from the actual start
            upto: timeWindow.end
        )

        // Use PKModel to calculate peak details
        let pkModel = createPKModel()
        return pkModel.calculateProtocolPeakDetails(
            injectionDates: injectionDates,
            compounds: compounds,
            route: route,
            timeWindow: timeWindow,
            weight: profile.weight ?? 70.0,
            calibrationFactor: profile.calibrationFactor
        )
    }

    func calculateSingleDosePeakDetails(for injectionProtocol: InjectionProtocol) -&gt; (timeToMaxDays: Double, maxConcentration: Double) {
         // Reuse logic to get compounds and route
         var compounds: [(compound: Compound, doseMg: Double)] = []
         let route: Compound.Route
         if let routeString = injectionProtocol.selectedRoute, let selectedRoute = Compound.Route(rawValue: routeString) {
             route = selectedRoute
         } else {
             route = .intramuscular // Default route
         }

         switch injectionProtocol.protocolType {
             case .compound:
                 if let compoundID = injectionProtocol.compoundID, let compound = compoundLibrary.compound(withID: compoundID) {
                      if (compound.defaultBioavailability[route] ?? 0) &gt; 0 {
                           compounds = [(compound: compound, doseMg: injectionProtocol.doseMg)]
                      }
                 }
             case .blend:
                  if let blendID = injectionProtocol.blendID, let blend = compoundLibrary.blend(withID: blendID) {
                       guard blend.totalConcentration &gt; 0 else { return (0, 0) }
                       compounds = blend.resolvedComponents(using: compoundLibrary).map {
                          (compound: $0.compound, doseMg: $0.mgPerML * injectionProtocol.doseMg / blend.totalConcentration)
                       }
                  }
         }
        
         if compounds.isEmpty {
              if let fixedCompound = findLegacyCompound(for: injectionProtocol) {
                   // Check if route is valid, otherwise just use it anyway (the route validation should happen elsewhere)
                   if (fixedCompound.defaultBioavailability[route] ?? 0) &lt;= 0 {
                        // Route not supported, but we&apos;ll try anyway
                        print(&quot;Warning: Selected route not optimal for single dose peak calculation&quot;)
                        if !fixedCompound.defaultBioavailability.keys.contains(where: { (fixedCompound.defaultBioavailability[$0] ?? 0) &gt; 0 }) {
                             return (0, 0) // No valid routes at all
                        }
                   }
                   compounds = [(compound: fixedCompound, doseMg: injectionProtocol.doseMg)]
              } else {
                  print(&quot;Error calculating single dose peak: No valid compounds.&quot;)
                   return (timeToMaxDays: 0, maxConcentration: 0)
              }
         }


        // For single dose peak, if it&apos;s a blend, use the specialized blend peak calculation
        if injectionProtocol.protocolType == .blend {
            let pkModel = createPKModel()
            return pkModel.calculateBlendPeakDetails(
                components: compounds,
                route: route,
                weight: profile.weight ?? 70.0,
                calibrationFactor: profile.calibrationFactor
            )
        }
        // Otherwise (single compound), use the standard single dose calculation
        else if let firstCompound = compounds.first {
            let bioavailability = firstCompound.compound.defaultBioavailability[route] ?? 1.0
            let absorptionRate = firstCompound.compound.defaultAbsorptionRateKa[route] ?? 0.7
            let pkModel = createPKModel()
            let timeToMax = pkModel.calculateTimeToMaxConcentration(
                dose: firstCompound.doseMg,
                halfLifeDays: firstCompound.compound.halfLifeDays,
                absorptionRateKa: absorptionRate,
                bioavailability: bioavailability,
                weight: profile.weight ?? 70.0,
                calibrationFactor: profile.calibrationFactor
            )
            let maxConc = pkModel.calculateMaxConcentration(
                dose: firstCompound.doseMg,
                halfLifeDays: firstCompound.compound.halfLifeDays,
                absorptionRateKa: absorptionRate,
                bioavailability: bioavailability,
                weight: profile.weight ?? 70.0,
                calibrationFactor: profile.calibrationFactor
            )
            return (timeToMaxDays: timeToMax, maxConcentration: maxConc)
        }

        return (timeToMaxDays: 0, maxConcentration: 0) // Fallback
    }

    // MARK: - Adherence Tracking Interface
    func acknowledgeInjection(protocolID: UUID, injectionDate: Date) {
        notificationManager.acknowledgeInjection(protocolID: protocolID, injectionDate: injectionDate)
        print(&quot;Acknowledged injection for protocol \(protocolID) scheduled on \(injectionDate)&quot;)
    }

    func adherenceStats() -&gt; (total: Int, onTime: Int, late: Int, missed: Int) {
        return notificationManager.adherenceStats()
    }

    func adherencePercentage() -&gt; Double {
        return notificationManager.adherencePercentage()
    }

    func injectionHistory(for protocolID: UUID? = nil) -&gt; [NotificationManager.InjectionRecord] {
        return notificationManager.injectionHistory(for: protocolID)
    }

    func cleanupOldRecords() {
        notificationManager.cleanupOldRecords()
        print(&quot;Cleaned up old injection records.&quot;)
    }

    // MARK: - Cycle Management
    func loadCyclesFromCoreData() {
        let context = coreDataManager.persistentContainer.viewContext
        let fetchRequest: NSFetchRequest&lt;CDCycle&gt; = CDCycle.fetchRequest()
        // Add sort descriptor to load cycles in a consistent order (e.g., by start date)
        fetchRequest.sortDescriptors = [NSSortDescriptor(key: &quot;startDate&quot;, ascending: true)]
        do {
            let cdCycles = try context.fetch(fetchRequest)
            self.cycles = cdCycles.map { Cycle(from: $0, context: context) } // Pass context if needed by Cycle init
            print(&quot;Loaded \(self.cycles.count) cycles from Core Data.&quot;)
        } catch {
            print(&quot;Error loading cycles from Core Data: \(error)&quot;)
            self.cycles = [] // Ensure cycles is empty on error
        }
    }

    func saveCycle(_ cycle: Cycle) {
        let context = coreDataManager.persistentContainer.viewContext
        // Save to Core Data (create or update)
        _ = cycle.save(to: context)
        do {
            try context.save()
            // Refresh cycles from Core Data to update the @Published array
            loadCyclesFromCoreData()
            print(&quot;Saved cycle: \(cycle.name)&quot;)
        } catch {
            print(&quot;Error saving cycle \(cycle.name): \(error)&quot;)
        }
    }

    func deleteCycle(with id: UUID) {
        let context = coreDataManager.persistentContainer.viewContext
        let fetchRequest: NSFetchRequest&lt;CDCycle&gt; = CDCycle.fetchRequest()
        fetchRequest.predicate = NSPredicate(format: &quot;id == %@&quot;, id as CVarArg)
        do {
            if let cdCycle = try context.fetch(fetchRequest).first {
                let cycleName = cdCycle.name ?? &quot;Unknown&quot;
                context.delete(cdCycle)
                try context.save()
                // Refresh cycles from Core Data
                loadCyclesFromCoreData()
                // If this was the selected cycle, deselect it
                if selectedCycleID == id {
                    selectedCycleID = nil
                    isCycleSimulationActive = false
                    cycleSimulationData = []
                }
                print(&quot;Deleted cycle: \(cycleName)&quot;)
            } else {
                print(&quot;Error deleting cycle: Cycle with ID \(id) not found.&quot;)
            }
        } catch {
            print(&quot;Error deleting cycle with ID \(id): \(error)&quot;)
        }
    }
    
    func selectCycle(id: UUID?) {
         guard let id = id else {
              selectedCycleID = nil
              cycleSimulationData = []
              isCycleSimulationActive = false
              print(&quot;Cycle deselected.&quot;)
              return
         }
        
         // Only proceed if the selected ID exists
         guard cycles.contains(where: { $0.id == id }) else {
              print(&quot;Error: Attempted to select non-existent cycle ID: \(id)&quot;)
              // Optionally select the first available cycle if selection is invalid
              if let firstID = cycles.first?.id {
                   selectedCycleID = firstID
                   simulateCycle(id: firstID) // Simulate the first one instead
              } else {
                   selectedCycleID = nil
                   cycleSimulationData = []
                   isCycleSimulationActive = false
              }
              return
         }

         // Simulate if selection changed or simulation isn&apos;t active
         if selectedCycleID != id || !isCycleSimulationActive {
              selectedCycleID = id
              simulateCycle(id: id)
              print(&quot;Selected cycle: \(cycles.first { $0.id == id }?.name ?? &quot;Unknown&quot;)&quot;)
         }
     }


    func simulateCycle(id: UUID) { // Changed parameter to non-optional for clarity
        guard let cycle = cycles.first(where: { $0.id == id }) else {
            print(&quot;SimulateCycle Error: Cycle with ID \(id) not found.&quot;)
            cycleSimulationData = []
            isCycleSimulationActive = false
            return
        }

        // Create temporary protocols for simulation
        let tempProtocols = cycle.generateTemporaryProtocols(compoundLibrary: compoundLibrary)

        if tempProtocols.isEmpty {
            print(&quot;No protocols generated for cycle \(cycle.name). Clearing simulation.&quot;)
            cycleSimulationData = []
            isCycleSimulationActive = false
            return
        }

        print(&quot;Simulating cycle: \(cycle.name) with \(tempProtocols.count) derived protocols...&quot;)
        let pkModel = createPKModel()
        cycleSimulationData = [] // Clear previous data

        // Determine simulation range based on cycle dates
        let calendar = Calendar.current
        let startDate = cycle.startDate
        // Ensure end date calculation is robust
        guard let endDate = calendar.date(byAdding: .day, value: cycle.totalWeeks * 7, to: startDate) else {
            print(&quot;Error calculating cycle end date.&quot;)
            cycleSimulationData = []
            isCycleSimulationActive = false
            return
        }

        let simulationDates = generateSimulationDates(
            startDate: startDate,
            endDate: endDate,
            interval: 0.5 // Consistent interval for cycle charts (e.g., twice daily)
        )

        if simulationDates.isEmpty {
            print(&quot;Error: No simulation dates generated for cycle.&quot;)
            cycleSimulationData = []
            isCycleSimulationActive = false
            return
        }

        var totalConcentrations = Array(repeating: 0.0, count: simulationDates.count)
        let weight = profile.weight ?? 70.0

        // Accumulate concentrations from each derived protocol
        for treatmentProtocol in tempProtocols {
            var compounds: [(compound: Compound, dosePerInjectionMg: Double)] = []
            let route: Compound.Route = {
                if let routeString = treatmentProtocol.selectedRoute, let r = Compound.Route(rawValue: routeString) { return r }
                return .intramuscular
            }()

            // Get compounds/blend for this temporary protocol
            switch treatmentProtocol.protocolType {
                case .compound:
                    if let compoundID = treatmentProtocol.compoundID, let c = compoundLibrary.compound(withID: compoundID), (c.defaultBioavailability[route] ?? 0) &gt; 0 {
                        compounds = [(c, treatmentProtocol.doseMg)]
                    }
                case .blend:
                    if let blendID = treatmentProtocol.blendID, let b = compoundLibrary.blend(withID: blendID), b.totalConcentration &gt; 0 {
                         compounds = b.resolvedComponents(using: compoundLibrary).map { rc in
                             (rc.compound, treatmentProtocol.doseMg * (rc.mgPerML / b.totalConcentration))
                         }
                    }
            }
            
            if compounds.isEmpty {
                print(&quot;Warning: Skipping empty/invalid protocol &apos;\(treatmentProtocol.name)&apos; in cycle simulation.&quot;)
                continue // Skip this protocol if no valid compounds
            }

            // Generate injection dates for this specific protocol within the cycle&apos;s timeframe
            let injectionDates = treatmentProtocol.injectionDates(from: startDate, upto: endDate)

            // Calculate concentrations for this protocol
            let concentrations = pkModel.protocolConcentrations(
                at: simulationDates,
                injectionDates: injectionDates,
                compounds: compounds,
                route: route,
                weight: weight,
                calibrationFactor: profile.calibrationFactor
            )

            // Add to the total concentrations
            for i in 0..&lt;min(totalConcentrations.count, concentrations.count) {
                totalConcentrations[i] += concentrations[i]
            }
        }

        // Convert to DataPoints
        cycleSimulationData = zip(simulationDates, totalConcentrations).map {
            DataPoint(time: $0, level: $1.isNaN ? 0 : $1)
        }
        isCycleSimulationActive = true // Mark simulation as active
        print(&quot;Cycle simulation complete for \(cycle.name). Generated \(cycleSimulationData.count) points.&quot;)
    }

    // MARK: - Notification Management Interface
    func toggleNotifications(enabled: Bool) {
        notificationManager.notificationsEnabled = enabled
        if enabled {
            Task {
                let granted = await notificationManager.requestNotificationPermission()
                if granted {
                    await scheduleAllNotifications()
                    print(&quot;Notifications enabled and scheduled.&quot;)
                } else {
                    // Permission denied - update state and potentially UI
                    await MainActor.run {
                        notificationManager.notificationsEnabled = false
                        self.profile.usesICloudSync = false // Example UI update if needed
                        print(&quot;Notification permission denied.&quot;)
                    }
                }
            }
        } else {
            notificationManager.cancelAllNotifications()
            print(&quot;Notifications disabled and cancelled.&quot;)
        }
    }

    func setNotificationSound(enabled: Bool) {
        notificationManager.soundEnabled = enabled
        // Reschedule all notifications to apply sound setting change
        if notificationManager.notificationsEnabled {
            Task {
                await scheduleAllNotifications()
                print(&quot;Notification sound setting updated and notifications rescheduled.&quot;)
            }
        }
    }

    func setNotificationLeadTime(_ leadTime: NotificationManager.LeadTime) {
        notificationManager.selectedLeadTime = leadTime
        // Reschedule all notifications to apply lead time change
        if notificationManager.notificationsEnabled {
            Task {
                await scheduleAllNotifications()
                print(&quot;Notification lead time updated to \(leadTime.rawValue) and notifications rescheduled.&quot;)
            }
        }
    }

    // Schedules notifications for ALL current protocols
    func scheduleAllNotifications() async {
        guard notificationManager.notificationsEnabled else { return }

        // Ensure permission is granted before scheduling
        let granted = await notificationManager.requestNotificationPermission()
        if !granted {
            await MainActor.run {
                 notificationManager.notificationsEnabled = false // Reflect denial in state
                 // Maybe update UI toggle? Requires binding or callback
            }
            print(&quot;Cannot schedule notifications: Permission denied.&quot;)
            return
        }

        print(&quot;Scheduling notifications for \(profile.protocols.count) protocols...&quot;)
        // Cancel all existing first to avoid duplicates if rescheduling
        notificationManager.cancelAllNotifications()
        // Schedule for each protocol
        for p in profile.protocols {
            notificationManager.scheduleNotifications(for: p, using: compoundLibrary)
        }
        print(&quot;Notification scheduling complete.&quot;)
    }
} // End of AppDataStore class</file></files></repomix>