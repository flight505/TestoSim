# TestoSim: Comprehensive Implementation Guide (Reflecting Codebase State)

## 1. Introduction

TestoSim is an iOS application developed to simulate hormone pharmacokinetics (PK), primarily focusing on testosterone and related compounds. Built iteratively based on Guide One and Guide Two, the application allows users to create and visualize injection protocols and cycles, track bloodwork, calibrate the simulation model, manage notifications for adherence, and gain AI-powered insights. This guide outlines the application's architecture and features as they are implemented in the provided codebase, reflecting how the development process unfolded according to the planning documents.

**Implemented Features:**

*   **Pharmacokinetic Simulation:** Utilizes a two-compartment model with allometric scaling for personalized concentration predictions. Supports various administration routes.
*   **Compound Library & Blends:** Contains a database of individual compounds and commercial multi-compound blends with detailed pharmacokinetic parameters.
*   **Protocol Management:** Users define single-compound or blend-based injection protocols with dose, frequency, start date, route, and notes.
*   **Cycle Planner:** Supports planning and simulation of multi-stage, multi-compound treatment cycles.
*   **Bloodwork Tracking:** Allows logging blood test results linked to protocols.
*   **Calibration:** Provides a simple model calibration mechanism based on the latest blood sample to refine concentration predictions. (Advanced Bayesian logic exists but is not fully integrated into the main UI flow).
*   **Notifications & Adherence:** Schedules injection reminders and tracks adherence statistics based on user acknowledgement.
*   **AI Insights:** Integrates with OpenAI (using `gpt-4o-mini`) to offer analytical insights into protocols and cycles. Includes a test API key by default.
*   **Persistence:** Uses Core Data for persistent storage, with optional CloudKit synchronization.
*   **User Profile:** Stores user details (name, measurements, preferences), calibration factor, and protocols/cycles.

## 2. Project Setup and Core Architecture

The application is built using SwiftUI, targeting iOS 16.0+ and macOS 13.0+.

*   **Project Initialization:** The project was initiated as a standard Xcode SwiftUI App template named `TestoSim` (`Codebase/TestoSim.xcodeproj`), as per Guide One (Story 1). Project groups (`Models`, `Views`, `ViewModels`, `Resources`) were created for organization.
*   **Main App Structure (`Codebase/TestoSim/TestoSimApp.swift`):** The application entry point (`@main`) initializes the core state manager (`AppDataStore`) as a `@StateObject` and injects it into the environment (`@EnvironmentObject`) for access by child views, aligning with Guide One (Story 1). It also provides the Core Data `managedObjectContext` to the environment. Logic is included to save the Core Data context when the app becomes inactive. Initial setup for the default OpenAI test API key preference in `UserDefaults` occurs here.
*   **Core Data Manager (`Codebase/TestoSim/ViewModels/CoreDataManager.swift`):** This class manages the application's persistence layer. It sets up the Core Data stack using `NSPersistentContainer`. Based on a flag in `UserDefaults` (`usesICloudSync`), it conditionally uses `NSPersistentCloudKitContainer` for CloudKit synchronization, utilizing the specified container ID `"iCloud.flight505.TestoSim"` as required by Guide Two (Story 10, Priority Task 6). It handles loading persistent stores, basic error logging, and provides a `saveContext()` method. A one-time migration function (`migrateUserProfileFromJSON()`) is implemented to transfer data from the older `UserDefaults` JSON format (used in Guide One) to the Core Data model, controlled by a `UserDefaults` flag (`migrated`). Methods for toggling and checking CloudKit sync status are provided.
*   **Main Data Store (`Codebase/TestoSim/ViewModels/AppDataStore.swift`):** As an `@MainActor ObservableObject`, this is the central hub for application state and logic, implementing much of the functionality outlined in both guides. It holds the user's `profile`, lists of `cycles`, simulation data arrays (`simulationData` for protocols, `cycleSimulationData` for cycles), selected item IDs, UI presentation flags (e.g., `isPresentingProtocolForm`), and the `compoundLibrary`. Its `init()` method loads the user profile and cycles from Core Data, handling the initial migration if necessary, and creates a default profile if no data is found (including test protocols and samples). It manages CRUD operations for protocols and cycles, triggering saving via the `CoreDataManager`. It contains methods to select protocols/cycles (`selectProtocol`, `selectCycle`) which, in turn, call the simulation logic (`recalcSimulation`, `simulateProtocol`, `simulateCycle`). It includes the simple calibration logic (`calibrateProtocol`) and integrates with `NotificationManager` for adherence features.
*   **Navigation (`Codebase/TestoSim/ContentView.swift`):** **Deviation:** Instead of solely using a `NavigationStack` starting from `ProtocolListView` as suggested in Guide One (Story 4), the codebase implements a top-level `TabView`. This `TabView` provides access to four main sections: Protocols, Cycles, Insights, and Profile. Each of these tabs then uses its own `NavigationStack` for internal navigation.

## 3. Data Modeling and Persistence

The application's data is represented using Swift structs for internal logic and persisted using Core Data entities.

*   **Core Data Model (`Codebase/TestoSim/TestoSim.xcdatamodeld`):** Defines the persistent structure as specified in Guide Two (Story 10). Entities include `CDUserProfile`, `CDInjectionProtocol`, `CDBloodSample`, `CDCompound`, `CDVialBlend`, `CDVialComponent`, `CDCycle`, and `CDCycleStage`, with appropriate relationships defined. Code generation is set to "category".
*   **Swift Models:**
    *   **`Compound` (`Codebase/TestoSim/Models/Compound.swift`):** This model, introduced in Guide Two (Story 8), replaces the simpler `TestosteroneEster` struct from Guide One (Story 2). It defines individual compounds with `commonName`, `classType` (enum), `ester`, `halfLifeDays`, and route-specific parameters (`defaultBioavailability`, `defaultAbsorptionRateKa`). It includes a `Route` enum.
    *   **`VialBlend` (`Codebase/TestoSim/Models/VialBlend.swift`):** Introduced in Guide Two (Story 8), represents commercial blends. It contains `name`, `manufacturer`, `description`, and an array of `Component` structs, each linking a `compoundID` to its `mgPerML`.
    *   **`CompoundLibrary` (`Codebase/TestoSim/Models/CompoundLibrary.swift`):** An `ObservableObject` holding static lists of `Compound` and `VialBlend` data, populated in its `init()` based on literature values detailed in Guide Two (Story 8). Provides lookup and filtering methods.
    *   **`InjectionProtocol` (`Codebase/TestoSim/Models/ProtocolModel.swift`):** Represents an injection schedule. Properties include `id`, `name`, `doseMg`, `frequencyDays`, `startDate`, `notes`, and `bloodSamples`. **Deviation:** As evolved in Guide Two (Story 8, Priority Task 1 & 7), it no longer holds a direct `TestosteroneEster` struct, but instead uses optional `compoundID` and `blendID` to link to either a `Compound` or `VialBlend`. It also includes `selectedRoute: String?` (Guide Two, Priority Task 2). A computed `protocolType` (`.compound` or `.blend`) determines its type. The `injectionDates` helper function is included.
    *   **`BloodSample` (`Codebase/TestoSim/Models/BloodworkModel.swift`):** Simple struct for blood test results (`id`, `date`, `value`, `unit`), implemented as in Guide One (Story 2).
    *   **`UserProfile` (`Codebase/TestoSim/Models/ProfileModel.swift`):** Stores user-specific data. Includes basic properties from Guide One (Story 2) (`id`, `name`, `unit`, `calibrationFactor`), extended in Guide Two (Story 10) with physical measurements (`dateOfBirth`, `heightCm`, `weight`, `biologicalSex`), `usesICloudSync`, and `useTwoCompartmentModel`. It holds the array of `protocols`. Computed properties for `bodySurfaceArea` and `age` are included.
    *   **`Cycle` / `CycleStage` (`Codebase/TestoSim/Models/CycleModel.swift`):** Introduced in Guide Two (Story 12), models for multi-stage treatment plans. `Cycle` contains overall details and an array of `CycleStage`s. `CycleStage` defines a period and lists items (`CompoundStageItem`, `BlendStageItem`) used. Conversion methods for simulation are included.
    *   **`DataPoint` (`Codebase/TestoSim/Models/DataPoint.swift`):** Simple struct (`Identifiable`) for chart data points (`time`, `level`), implemented as in Guide One (Story 3).
    *   **`CoreDataExtensions.swift`:** This file provides extensions to map data between the Swift structs and Core Data entities. **Deviation:** Due to the Core Data model not yet having direct fields for `compoundID`, `blendID`, and `selectedRoute` on `CDInjectionProtocol`, the save logic in the extension serializes this information into a JSON string stored in the `notes` field. The loading logic deserializes this JSON from `notes`. This is a workaround described in Guide Two (Priority Task 6 migration) to maintain backward compatibility with the schema during the transition to the richer data model.

## 4. Pharmacokinetic Engine (`Codebase/TestoSim/Models/PKModel.swift`)

The `PKModel` struct contains the core logic for simulating hormone concentrations.

*   **Model Type:** **Deviation:** While Guide Two (Story 9) mentioned an "Optional two-compartment flag," the implementation in `PKModel.swift` and its usage via `AppDataStore.createPKModel()` indicates the **two-compartment model is always used** (`useTwoCompartmentModel` is hardcoded as `true`). The structure includes fixed transfer rates (`k12`, `k21`). A simplified one-compartment bolus calculation (`oneCompartmentBolus`) exists but serves primarily as a fallback for edge numerical cases.
*   **Key Parameters:** Standard PK parameters (`ka`, `ke`, `F`, `Vd`, `CL`) are used. `ke` is derived from `halfLifeDays`.
*   **Allometric Scaling:** Implemented as described in Guide Two (Story 9). `Vd` and `CL` are scaled based on the user's `weight` from `UserProfile` relative to a 70kg standard. The `ProfileView` links to the `AllometricInfoView` explaining this.
*   **Concentration Calculation Functions:**
    *   `concentration(at:dose:halfLifeDays:...)`: Calculates the concentration for a single dose at a specific time using the two-compartment model (or one-compartment fallback).
    *   `blendConcentration(at:components:...)`: Calculates total concentration for a blend dose by summing component contributions.
    *   `protocolConcentrations(at:injectionDates:compounds:...)`: Calculates concentrations over multiple time points for a full protocol by summing contributions from all past injections up to each time point, using the two-compartment model. This is the function primarily called by `AppDataStore`.
*   **Peak Calculations (`Tp`, `Cmax`):** Functions like `calculateTimeToMaxConcentration`, `calculateMaxConcentration` (for single dose), `calculateBlendPeakDetails`, and `calculateProtocolPeakDetails` (for blends/protocols) are implemented using numerical search over a time window to find peak levels and times, as described in Guide Two (Story 9, Priority Task 4). `AppDataStore` methods expose these for the selected protocol.
*   **Calibration:**
    *   **Simple Factor Adjustment (Implemented in UI):** The "Recalibrate" button in `ProtocolDetailView` and the "Add Sample and Calibrate" option in `AddBloodworkView` trigger `AppDataStore.calibrateProtocol()`. This function implements the simple calibration logic described in Guide One (Story 6), adjusting the global `profile.calibrationFactor` based on the ratio of the latest blood sample value to the model's prediction *at that sample date* using the current factor.
    *   **Bayesian Calibration (Model Logic Exists):** The `PKModel.bayesianCalibration()` function implementing the advanced gradient descent optimization described in Guide Two (Story 9) *is present* in the codebase. It attempts to adjust `ke` and `ka` based on multiple samples.
    *   **Deviation:** Although the Bayesian calibration logic exists, the main UI actions ("Recalibrate", "Add Sample and Calibrate") are linked to the *simple global factor adjustment* function in `AppDataStore`, not the `PKModel.bayesianCalibration` method. The `CalibrationResultView.swift`, designed to display detailed Bayesian results, is also present but appears disconnected from the main UI flow that triggers calibration. `AppDataStore.calibrateProtocolWithBayesian` exists but seems to fall back to the simple `calibrateProtocol` in many cases.

## 5. User Interface (`Codebase/TestoSim/Views/`)

The user interface is built using SwiftUI, organized into distinct views.

*   **Main Navigation (`ContentView.swift`):** Uses a `TabView` (Deviation from Guide One) to provide main navigation to Protocols, Cycles, Insights, and Profile screens. Each tab embeds a `NavigationStack`.
*   **Protocols Tab (`ProtocolListView.swift`, `ProtocolDetailView.swift`, `ProtocolFormView.swift`):**
    *   `ProtocolListView`: Displays protocols in a `List` with `NavigationLink`s to detail views. Supports swipe-to-delete (`onDelete`). Toolbar includes buttons for adding a protocol (presenting `ProtocolFormView` sheet) and navigating to `ProfileView`. Protocol rows display name, dose, compound/blend, and frequency, adapting dynamically based on the `protocolType` (Guide Two, Priority Task 7). Handles empty state.
    *   `ProtocolDetailView`: Shows details for a selected protocol. Includes a summary view adapting for Compound/Blend/Route (Guide Two, Priority Task 7, 2), latest bloodwork comparison, the `TestosteroneChart`, next injection info, and action buttons ("Add Bloodwork", "Record Injection", "Recalibrate"). An "Edit" toolbar button presents `ProtocolFormView` to edit. `.onAppear` calls `dataStore.selectProtocol` and `dataStore.recalcSimulation`. Includes logic (`fixProtocolCompound`) to attempt to link legacy protocols to compounds on load.
    *   `ProtocolFormView`: Presented as a sheet for adding/editing protocols. Includes a segmented picker for `protocolType` (Compound/Blend - Guide Two, Priority Task 1), buttons to present sheets for selecting a `Compound` (`CompoundListView`) or `VialBlend` (`VialBlendListView`), and a dynamic `Picker` for `selectedRoute` filtered by supported routes for the chosen compound (Guide Two, Priority Task 2). Fields for name, dose (numeric keyboard specified for iOS), frequency (numeric keyboard for iOS), start date, and notes are included.
*   **Compound/Blend Selection (`CompoundListView.swift`, `VialBlendListView.swift`):** Presented as sheets from `ProtocolFormView` (Guide Two, Story 8, Priority Task 1). `CompoundListView` supports search and filtering by Class and Route. `VialBlendListView` supports search.
*   **Chart (`TestosteroneChart.swift`):** Uses `Swift Charts`. Displays `dataStore.simulationData` as a `LineMark` with a gradient filled `AreaMark` below. **Deviation:** Injection markers are shown as green `PointMark`s on the curve and vertical dashed green `RuleMark`s, diverging from the annotation plan in Guide One (Story 5). Blood samples are *not* plotted directly on this chart in the provided code, a deviation from Guide One (Story 5). Features an interactive `.chartOverlay` for selecting points to show details. Axes are customized.
*   **Bloodwork (`AddBloodworkView.swift`):** Presented as a sheet from `ProtocolDetailView` (Guide One, Story 6). Form with fields for value, date, and notes. Offers buttons to "Add Sample Only" or "Add Sample and Calibrate". The latter triggers the simple calibration factor adjustment in `AppDataStore`.
*   **Profile Tab (`ProfileView.swift`):** Uses a `Form`. Sections for User (name, sex, DOB), Physical Measurements (height/weight, BSA display, link to `AllometricInfoView` - Guide Two, Story 9 UI), Notifications & Adherence (links to settings/history views - Guide Two, Story 11 UI, shows adherence rate), Settings (unit picker, iCloud toggle - Guide Two, Story 10 UI, PK Model info alert - Guide Two, Story 9 UI), and Calibration (factor display, reset button). Saves profile changes `onDisappear`.
*   **Cycles Tab (`CyclePlannerView.swift`, `CycleFormView.swift`, `CycleStageFormView.swift`, `CycleDetailView.swift`, `CycleChartView.swift`):** Implemented based on Guide Two (Story 12). `CyclePlannerView` lists cycles and shows the combined simulation curve (`CycleChartView`) for the selected one. It presents `CycleFormView` for adding cycles. `CycleDetailView` displays stage information (with a timeline visualization placeholder) and the cycle simulation. `CycleStageFormView` is used to add/edit stages, allowing the inclusion of compounds and blends for that stage using sub-views (`CompoundPickerView`, `BlendPickerView`, `ItemConfigurationView`).
*   **Insights Tab (`AIInsightsView.swift`, `AISettingsView.swift`):** Implemented based on Guide Two (Story 13). `AIInsightsView` displays AI-generated insights from `AIInsightsGenerator` for the selected protocol or cycle. It shows loading/error states, a test key indicator, and structured, expandable insights. `AISettingsView` allows management of the OpenAI API key preference (test key vs. personal key).
*   **Notifications UI (`NotificationSettingsView.swift`, `InjectionHistoryView.swift`):** Implemented based on Guide Two (Story 11 UI). `NotificationSettingsView` manages notification preferences (enable, sound, lead time) and displays adherence stats (`NotificationAdherenceStatsView`). `InjectionHistoryView` lists past scheduled injections, their status, and includes overall adherence stats (`InjectionAdherenceStatsView`) and a cleanup option.
*   **Calibration Result View (`CalibrationResultView.swift`):** This view exists as described in Guide Two (Story 9 UI) for displaying detailed calibration results (parameters, correlation, chart comparison). **Deviation:** As noted earlier, this view is not currently integrated into the main UI flow triggered by the calibration actions in `ProtocolDetailView`/`AddBloodworkView`. Its sample data in the preview confirms its structure, but it's not the view the user sees when performing calibration through the app's primary UI.

## 6. Advanced Features Implementation

Several advanced features were implemented based on Guide Two's requirements.

*   **Notifications & Adherence (Story 11):** The `NotificationManager.swift` class orchestrates user notifications for injections using `UNUserNotificationCenter`. It handles requesting permissions, scheduling future reminders based on protocol schedules and user-defined lead time (1h/6h/12h), and canceling notifications. It persists `InjectionRecord` structs in `UserDefaults` to track scheduled injections and when the user acknowledges them, calculating adherence status (on-time, late, missed). `AppDataStore` acts as an interface for the UI to interact with the `NotificationManager` (e.g., toggling notifications, setting sound/lead time, acknowledging injections, retrieving history/stats).
*   **Cycle Builder (Story 12):** Cycle data structures (`Cycle`, `CycleStage`, `CompoundStageItem`, `BlendStageItem`) are defined in `CycleModel.swift`. Persistence is handled by mapping these structs to `CDCycle` and `CDCycleStage` Core Data entities, with `CoreDataExtensions.swift` managing the conversion and using JSON serialization within the `CDCycleStage` entity to store compound/blend lists. `AppDataStore` provides CRUD operations for cycles. The simulation logic (`simulateCycle` in `AppDataStore`) generates temporary `InjectionProtocol`s from cycle stages and accumulates their individual concentration curves calculated by the `PKModel` over the cycle's timeline to produce the combined `cycleSimulationData`.
*   **AI Insights (Story 13):** The `OpenAIService.swift` class is responsible for communicating with the OpenAI API, using the `gpt-4o-mini` model. It manages the API key (reading from `Config.plist` for the test key or `UserDefaults` for the user's key, with a toggle preference). It constructs prompts including user profile, protocol/cycle details, and simulation data, expecting a structured JSON response. The `AIInsightsGenerator.swift` class is an `ObservableObject` that calls `OpenAIService`, manages the loading/error state, caches results, and provides a mock fallback if the API key is missing or API calls fail. `AIInsightsView` displays the results from the `AIInsightsGenerator`, and `AISettingsView` allows users to manage their API key preference. Configuration files (`Config-Sample.plist`, `Config-Sample.xcconfig`) and the `copy-config.sh` script are used to manage API keys outside of version control.

## 7. Configuration & Setup

*   **API Keys:** OpenAI API key configuration is implemented using `Config.plist` (read at runtime) and `Config.xcconfig` (potentially used for build-time settings, although the code primarily relies on `Config.plist` and `UserDefaults`). Sample files (`Config-Sample.plist`, `Config-Sample.xcconfig`) are provided and copied by `copy-config.sh` on the first build. Sensitive keys are excluded from git via `.gitignore`. A default test API key from `Config.plist` is used unless the user provides their own via the `AISettingsView`.
*   **CloudKit:** CloudKit synchronization is configured via the `TestoSim.entitlements` file specifying the container ID. `CoreDataManager` sets up the `NSPersistentCloudKitContainer` when the user enables the "Use iCloud Sync" toggle in `ProfileView` (which saves the preference to `UserDefaults`). Users are instructed that a restart is needed after changing this setting.

## 8. Development & Troubleshooting Workflow

The README provides scripts and guidance for developers building and running the application, especially concerning simulator management.

*   **Simulator Management:** `build-test.sh` builds without launching, `close-simulators.sh` shuts down all instances, and `launch-test.sh` builds and runs in a single specified device.
*   **Recommended Workflow:** Use VS Code with the SweetPad extension for a streamlined development cycle, leveraging `build-test.sh` internally. Command-line scripts offer alternatives for specific needs.
*   **Troubleshooting:** Guidance is provided for resolving launch crashes (closing simulators, clean build, launching specific device) and accessing device logs.

## 9. Future Work

Based on the status marked in Guide Two, the following aspects of the project were planned but noted as incomplete in the provided guides:

*   **Story 14: UI/UX Polish & Animations:** Enhancing visual design, implementing animations (including Lottie integration), improving chart interactivity (scroll-zoom, point selection), and implementing haptic feedback and sounds.
*   **Story 15: Testing & Validation:** Conducting comprehensive unit tests (specifically including validation of PK calculations against known data), UI testing, and performance testing.
*   **Story 16: Help Center & Documentation:** Building a dedicated in-app help center with detailed explanations of the application's features, PK model concepts, and usage guides.

These areas represent the planned next steps to refine the application's user experience, verify its accuracy, and provide comprehensive in-app documentation.

## References

The references listed in Guide Two, which provided source material for half-lives, PK equations, allometric scaling, and implementation details, are relevant context for the codebase's development and are included for completeness.

[References list as provided in Guide Two]

This guide describes the TestoSim application as it is implemented in the provided codebase, explaining how it was built by following and evolving from the plans laid out in Guide One and Guide Two, while noting specific points where the implementation differs from aspects of those plans.